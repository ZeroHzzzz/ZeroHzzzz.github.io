<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十万个为什么之数据链路层</title>
    <link href="/2024/12/05/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/12/05/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>#计算机网络</p><h1 id="什么是数据链路层"><a href="#什么是数据链路层" class="headerlink" title="什么是数据链路层"></a>什么是数据链路层</h1><p>首先我们需要知道数据链路层这个玩意是干啥的。数据链路层是计算机网络中负责在两台直接相连设备之间传输数据的层，它位于物理层之上，网络层之下。它的核心任务是确保数据从一台设备可靠地传输到另一台设备。</p><p>省流一下就是主要解决三个问题：<code>封装成帧</code>、<code>透明传输</code>和<code>差错检测</code>。</p><p>他的工作确保了网络通信的基础，使上层协议能够在稳定的链路上进行有效的数据交换。</p><h1 id="什么是透明传输"><a href="#什么是透明传输" class="headerlink" title="什么是透明传输"></a>什么是透明传输</h1><p><strong>透明传输</strong> 是数据链路层的一项关键特性，简单来说就两个作用：确保数据完整、对上层协议透明。</p><h2 id="为什么叫透明"><a href="#为什么叫透明" class="headerlink" title="为什么叫透明"></a>为什么叫透明</h2><p>在<strong>透明传输</strong>中，”透明”这个词指的是数据链路层对数据的处理是<strong>无缝的</strong>，即数据传输的过程对上层协议和应用程序是<strong>透明的</strong>，它们不需要知道链路层的内部处理细节。</p><p>链路层处理数据时，不会干扰或改变数据的内容，也不会让上层协议感知到数据在链路层传输过程中所做的任何操作。</p><h2 id="为什么需要透明传输"><a href="#为什么需要透明传输" class="headerlink" title="为什么需要透明传输"></a>为什么需要透明传输</h2><p>在数据链路层进行数据传输时，通常会使用某些特殊的控制字符来标识数据帧的<strong>开始</strong>和<strong>结束</strong>（例如 <code>01111110</code> 作为以太网帧的边界标识）。如果传输的数据本身包含了这些特殊字符，链路层可能误将数据中的内容当作帧的开始或结束标识，从而导致数据解析错误或丢失。</p><p><strong>透明传输</strong> 就是为了避免这种情况发生，它确保无论数据中包含什么内容，链路层都能正确地识别数据帧的边界，并且不受到数据本身的干扰。</p><h2 id="透明传输是如何实现的？"><a href="#透明传输是如何实现的？" class="headerlink" title="透明传输是如何实现的？"></a>透明传输是如何实现的？</h2><p>透明传输通常通过 <strong>位填充（Bit Stuffing）</strong> 或 <strong>字符填充（Byte Stuffing）</strong> 技术来实现。</p><h3 id="1-位填充（Bit-Stuffing）"><a href="#1-位填充（Bit-Stuffing）" class="headerlink" title="1. 位填充（Bit Stuffing）"></a>1. <strong>位填充（Bit Stuffing）</strong></h3><p>位填充是在数据中插入额外的比特（通常是 <code>0</code>），避免数据中出现连续的特殊标志位模式（如“11111”）。这样就能确保这些标志位不会被误判为帧的开始或结束标志。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>假设链路层用一个特定的比特模式（例如连续的 5 个 <code>1</code> 比特 <code>11111</code>）作为帧的开始和结束标志。</li><li>如果数据中包含了连续的 <code>11111</code>，链路层会在该模式后插入一个 <code>0</code>，打破连续的 <code>1</code>，避免它被误认为是帧的边界。</li><li>接收方收到数据时，会去掉多余的 <code>0</code>，还原原始数据。</li></ul><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><ul><li>如果数据流中有 <code>11111</code>，而 <code>11111</code> 作为帧的边界标志，链路层会在其后插入一个 <code>0</code>，变成 <code>111110</code></li><li>接收方在解码时，去掉多余的 <code>0</code>，还原为 <code>11111</code>。</li></ul><h3 id="2-字符填充（Byte-Stuffing）"><a href="#2-字符填充（Byte-Stuffing）" class="headerlink" title="2. 字符填充（Byte Stuffing）"></a>2. <strong>字符填充（Byte Stuffing）</strong></h3><p>字符填充是在数据流中插入特定的转义字符，避免数据中包含链路层的帧边界字符。</p><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>假设链路层使用某些特定的字节（例如 <code>0x7E</code>）作为帧的起始和结束标志。</li><li>如果数据中出现了 <code>0x7E</code>，链路层会将它转义为另一个字节（如 <code>0x7D 0x5E</code>），避免它被误认为是帧的边界。</li><li>接收方收到数据后，会知道这些转义字符，去掉它们，还原数据。</li></ul><h4 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h4><ul><li>如果数据部分包含 <code>0x7E</code>，链路层会将其替换为 <code>0x7D 0x5E</code>。</li><li>接收方收到 <code>0x7D 0x5E</code> 时，知道应该还原为 <code>0x7E</code>。</li></ul><h1 id="什么是协议数据单元（PDU）"><a href="#什么是协议数据单元（PDU）" class="headerlink" title="什么是协议数据单元（PDU）"></a>什么是协议数据单元（PDU）</h1><p>了解数据链路层之前我我们还需要了解一个概念——协议数据单元（PDU）。什么是协议数据单元（PDU）？</p><p><strong>协议数据单元（PDU）</strong> 是指在网络通信中，数据在每一层协议中被封装后的单位。每一层协议都有其自己的PDU，用于在该层与其它设备交换数据。简而言之，PDU 是协议处理的数据块，不同层协议的 PDU 在结构和格式上是不同的。</p><p>最重要的是，他其实是数据在网络中从一层传递到另一层的过程的缩影。</p><h2 id="各层协议的-PDU"><a href="#各层协议的-PDU" class="headerlink" title="各层协议的 PDU"></a>各层协议的 PDU</h2><ul><li><strong>物理层</strong>：物理层传输的是比特（Bit），因此物理层的 PDU 是 <strong>比特</strong>。</li><li><strong>数据链路层</strong>：数据链路层将网络层传递下来的数据封装成 <strong>帧（Frame）</strong>，所以数据链路层的 PDU 是帧。</li><li><strong>网络层</strong>：网络层负责将数据封装成 <strong>数据包（Packet）</strong>，所以网络层的 PDU 是数据包。</li><li><strong>传输层</strong>：传输层将数据分为 <strong>段（Segment）</strong>（TCP协议）或 <strong>数据报（Datagram）</strong>（UDP协议），所以传输层的 PDU 是段或数据报。</li><li><strong>会话层、表示层、应用层</strong>：这些层通常传输 <strong>数据（Data）</strong>，所以它们的 PDU 一般被称为数据。</li></ul><h2 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h2><ol><li>网络层从上层接收到数据（比如应用层的数据），会将这些数据封装为 <strong>数据包</strong>，并附加必要的网络层信息，如目标IP地址。</li><li>数据链路层则会将网络层的 <strong>数据包</strong> 封装为 <strong>帧</strong>，并附加链路层的信息（如MAC地址）。</li><li>物理层再将这些 <strong>帧</strong> 转换成 <strong>比特</strong>，通过物理媒介发送。</li></ol><h2 id="数据链路层的帧是什么样的"><a href="#数据链路层的帧是什么样的" class="headerlink" title="数据链路层的帧是什么样的"></a>数据链路层的帧是什么样的</h2><p>虽然不同的网络协议可能有不同的帧结构，但一般来说，帧都包含以下几个部分：</p><ul><li><strong>帧头（Header）</strong><ul><li><strong>目的地址（Destination MAC Address）</strong>：接收设备的 MAC 地址。就像信封上的收件人地址，确保数据能到达正确的设备。</li><li><strong>源地址（Source MAC Address）</strong>：发送设备的 MAC 地址。类似信封上的发件人地址，让接收方知道是谁发送的。</li><li><strong>类型（Type/Protocol）</strong>：表明帧中携带的数据类型。例如，以太网帧会标明数据是上层的 IP 数据包还是 ARP 请求。</li><li><strong>控制信息（Control Information）</strong>：一些帧格式中可能包括如流量控制、优先级、顺序等信息，帮助处理数据传输中的细节。</li></ul></li><li><strong>数据部分（Payload/Data）</strong><ul><li>这是帧的主要内容，包含了网络层传来的数据包（如 IP 数据包）。这部分数据将被封装在帧内部，并在数据链路层传输。</li><li>数据部分的大小根据协议不同有所不同，但通常有一个最小值（例如，以太网帧的最小有效负载为 46 字节），否则帧可能会被填充。</li></ul></li><li><strong>帧尾（Trailer）</strong><ul><li><strong>错误检测码（FCS/CRC）</strong>：帧尾通常包含一个 <strong>循环冗余校验（CRC）</strong> 或 <strong>帧校验序列（FCS）</strong>，用来进行 <strong>错误检测</strong>。接收方会根据这个校验码检查数据是否在传输过程中出现了错误。如果错误检测码与接收到的内容不符，接收方会丢弃帧并请求重传。</li></ul></li></ul><h1 id="数据链路层，在干啥？"><a href="#数据链路层，在干啥？" class="headerlink" title="数据链路层，在干啥？"></a>数据链路层，在干啥？</h1><p>数据链路层的任务是保证设备之间的通信能顺利进行。它就像是负责包裹的工作人员，确保数据被正确打包、检查、发送，并且没有错误。它控制了数据的流动速度，确保多个设备不会“抢”数据，保证数据能准确到达目的地。就像是为信息传输提供安全和高效的“道路”，确保一切顺畅进行。</p><h2 id="帧的封装与解封装"><a href="#帧的封装与解封装" class="headerlink" title="帧的封装与解封装"></a>帧的封装与解封装</h2><h3 id="为什么需要封装成帧？"><a href="#为什么需要封装成帧？" class="headerlink" title="为什么需要封装成帧？"></a>为什么需要封装成帧？</h3><p>网络层传输的是<strong>数据包（Packet）</strong>，而数据链路层需要将这个数据包封装成帧。帧不仅包含数据包的内容，还加上了数据链路层所需的控制信息（如地址、错误检测码等）。这样做的好处是：</p><ul><li><strong>寻址</strong>：确保数据能够传输到正确的设备。</li><li><strong>错误检测</strong>：检查数据是否在传输过程中损坏。</li><li><strong>数据控制</strong>：包括流量控制和介质访问控制等。</li></ul><h3 id="如何解封装"><a href="#如何解封装" class="headerlink" title="如何解封装"></a>如何解封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tree">接收物理层数据（比特流）<br>         |<br>  数据链路层接收帧<br>         |<br>    检查目的地址 → 如果不匹配，丢弃帧<br>         |<br>   计算 FCS 校验 → 如果校验失败，丢弃帧<br>         |<br>     去除帧头和帧尾 - (去除以太网帧头和 FCS)<br>         |<br>   提取有效负载（上层数据包）<br>         |<br>    将数据传递给网络层<br></code></pre></td></tr></table></figure><h2 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h2><p>错误检测主要发生在帧的解封装流程中，这里为了凸显出数据链路层的特性因此把他单独拿出来说。</p><p>首先我们要搞清楚 FCS 和 CRC 的概念。<strong>FCS</strong> 是帧检查序列，通常作为帧尾的一部分，在数据链路层用于检测在数据传输过程中是否发生了位错误。FCS 是一种冗余信息，它通过某种算法生成并附加到数据帧中，用于接收方验证数据的完整性。</p><p>而<strong>CRC</strong> 是一种常用的差错检测技术，它通过对数据帧进行数学运算（通常是除法运算），生成一个冗余值（校验码），然后将这个冗余值附加到数据后面作为帧的一部分。接收方在收到数据时，使用相同的 CRC 算法重新计算数据的校验码，并与接收到的 CRC 校验码进行比较。如果两者一致，则认为数据未发生错误；如果不一致，则说明数据在传输过程中发生了错误。</p><p><strong>CRC 是一种差错检测算法，而 FCS 是使用 CRC 算法计算出的校验码，并附加在数据帧中</strong>。FCS 是实际在帧中传输的校验信息。</p><p>至于错误检测出来怎么办，这个就不归数据链路层管了。</p><h3 id="CRC-怎么计算"><a href="#CRC-怎么计算" class="headerlink" title="CRC 怎么计算"></a>CRC 怎么计算</h3><p>我看下面视频学会的（</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=713069598&bvid=BV1XX4y1M79c&cid=264454435&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=713069598&bvid=BV1XX4y1M79c&cid=264453700&p=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="为什么需要流量控制？"><a href="#为什么需要流量控制？" class="headerlink" title="为什么需要流量控制？"></a>为什么需要流量控制？</h3><p>在通信中，发送方和接收方的处理能力往往是不一样的。如果发送方比接收方处理得更快，接收方的缓冲区可能会满，导致数据丢失。发送方一直以过快的速度发送数据，接收方无法及时处理，可能会造成网络拥塞，影响其他通信。</p><h3 id="点对点信道的数据链路层流量控制"><a href="#点对点信道的数据链路层流量控制" class="headerlink" title="点对点信道的数据链路层流量控制"></a>点对点信道的数据链路层流量控制</h3><p>点对点信道指的是在两个设备之间直接进行通信的场景，如以太网的两个主机直接连接、串行通信、VPN连接等。在点对点信道中，流量控制通常关注的是 <strong>发送方和接收方</strong> 之间的数据流动，确保数据能够被有效且高效地传输。</p><h4 id="流量控制机制："><a href="#流量控制机制：" class="headerlink" title="流量控制机制："></a>流量控制机制：</h4><ul><li><strong>滑动窗口协议（Sliding Window Protocol）</strong>：常用于点对点的流量控制，特别是在 <strong>全双工</strong> 信道中（即双方可以同时发送和接收）。滑动窗口协议通过动态调整窗口的大小来控制发送方可以发送多少数据。<br>在滑动窗口协议中，接收方会告诉发送方它的缓冲区可用空间（即窗口大小）。发送方根据窗口大小控制发送的数据量，确保不会超出接收方的接收能力。</li><li><strong>停等协议（Stop-and-Wait）</strong>：另一种常见的流量控制机制。在这种协议中，发送方每发送完一个数据帧后会停止，等待接收方的确认（ACK）消息。如果接收方的缓冲区满了，它会通过确认消息告诉发送方暂停发送数据，直到接收方有足够的空间。</li></ul><h3 id="广播信道的数据链路层流量控制"><a href="#广播信道的数据链路层流量控制" class="headerlink" title="广播信道的数据链路层流量控制"></a>广播信道的数据链路层流量控制</h3><p>广播信道指的是多个设备共享同一个传输信道，数据从一个发送方广播到多个接收方的情景。例如，以太网中的广播通信、Wi-Fi 无线网络等，都是典型的广播信道。广播信道的特点是发送方会向网络中所有设备发送数据，可能导致多个接收方同时接收到数据。</p><h4 id="CSMA-CD（Carrier-Sense-Multiple-Access-with-Collision-Detection）"><a href="#CSMA-CD（Carrier-Sense-Multiple-Access-with-Collision-Detection）" class="headerlink" title="CSMA/CD（Carrier Sense Multiple Access with Collision Detection）"></a>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）</h4><p>用于以太网中的广播信道，主要解决的是发送方如何避免与其他设备的冲突。虽然它不是严格意义上的流量控制机制，但它通过监听信道并检测冲突来减少流量的无效发送，避免了数据的过度发送。</p><p>CSMA/CD 工作流程如下：</p><ol><li>发送方在发送数据前首先监听信道，确保信道空闲。</li><li>如果信道空闲，则开始发送数据。如果信道繁忙，发送方将等待。</li><li>冲突检测：当发送方开始发送数据时，数据链路层的MAC子层会<strong>监控信道</strong>，并通过物理层的信号传输来检测信道是否发生冲突。如果冲突发生，MAC层会<strong>检测到信号不一致</strong>，即自己发送的信号与接收到的信号不匹配。一旦冲突被检测到，MAC层会通过物理层发送冲突信号（在物理层以电气信号的形式传播），然后<strong>中止发送</strong>并开始重试机制。</li><li>如果发生数据碰撞，发送方会暂停一段时间后重新发送。<br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412031817335.png" alt="image.png"></li></ol><ul><li>在 t ＝ 0 时，A 发送数据。B 检测到信道为空闲。</li><li>在 t ＝ τ − δ 时（这里 τ &gt; δ &gt; 0 ），A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。</li><li>经过时间 δ / 2 后，即在 t ＝ τ − δ / 2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。</li><li>在 t ＝ τ 时，B 检测到发生了碰撞，于是停止发送数据。</li><li>在 t ＝ 2 τ − δ 时，A 也检测到发生了碰撞，因而也停止发送数据。</li><li>A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</li></ul><p>那么问题来了，碰撞之后，什么时候重发呢？</p><h4 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h4><p>其基本思想就是设备在检测到冲突后等待一个随机的时间间隔再尝试重新发送数据，<strong>时间间隔是以“倍数递增”的方式选择的</strong>，即随着重试次数的增加，等待的随机时间间隔范围逐渐变大。这种递增范围是以 <strong>指数增长</strong> 的方式实现的。</p><h1 id="数据链路层使用的信道"><a href="#数据链路层使用的信道" class="headerlink" title="数据链路层使用的信道"></a>数据链路层使用的信道</h1><p>在数据链路层中，<strong>信道</strong>（Channel）通常指的是数据在网络中传输的媒介或路径。它是物理设备和通信协议之间的一种逻辑或物理连接通道，用于在网络中的设备之间传递数据。信道可以是物理的（如电缆、光纤、无线电波等），也可以是逻辑上的（如虚拟连接、交换机、路由器等设备之间的路径）。</p><p>根据信道的类型，我们主要将信道分为两种。</p><h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><p>是指两个设备直接连接的信道。数据传输仅限于这两个设备之间，不涉及其他设备的干扰或竞争，因此点对点信道通常具有较高的稳定性和较低的延迟。在点对点信道中，常见的协议包括<strong>PPP协议</strong>。</p><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>PPP（Point-to-Point Protocol）协议是一种广泛应用于点对点连接的协议，常用于通过电话线、串口线、专用线路或虚拟专用网络（VPN）等方式进行两台设备间的数据通信。PPP协议提供了链路建立、认证、数据传输和链路终止等功能。其工作原理可以分为以下几个阶段：</p><h4 id="链路建立"><a href="#链路建立" class="headerlink" title="链路建立"></a>链路建立</h4><p>在这个阶段，PPP协议通过一系列的控制帧来建立物理链路。链路建立过程使用 <strong>LCP（Link Control Protocol）</strong> 来进行。</p><ul><li><strong>LCP协商</strong>：双方通过LCP交换配置请求、配置确认、配置拒绝等信息来协商链路的基本参数，如最大接收单元（MRU）、认证方式等。</li><li><strong>链路质量监控</strong>：LCP还会检测链路质量，比如链路的可靠性、有效性等。</li></ul><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p>PPP可以选择是否进行身份验证，通常在需要对通信的两方进行身份验证时，使用 <strong>PAP（Password Authentication Protocol）</strong> 或 <strong>CHAP（Challenge Handshake Authentication Protocol）</strong> 来完成。</p><ul><li><strong>PAP</strong>：简单的密码验证协议，发送用户名和密码以进行身份验证，存在一定的安全风险。</li><li><strong>CHAP</strong>：一种更为安全的认证方式，通过发送挑战（challenge）信息和响应（response）信息进行身份验证，且会定期重新认证。</li></ul><h4 id="网络层协议协商"><a href="#网络层协议协商" class="headerlink" title="网络层协议协商"></a>网络层协议协商</h4><p>在这个阶段，PPP会协商并启用网络层协议（如IP、IPX等）。这一步使用 <strong>NCP（Network Control Protocol）</strong> 协议来进行。NCP允许PPP协议与不同的网络层协议进行交互，确保网络协议的数据能够通过点对点链路传输。</p><ul><li><strong>NCP协商</strong>：通过NCP，PPP协商启用某些网络层协议，如IP协议、IPX协议等。</li><li>每个网络层协议都有自己独立的NCP。例如，IP协议使用 <strong>IPCP（IP Control Protocol）</strong>。</li></ul><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>一旦链路建立并完成了身份验证与协议协商，PPP就进入数据传输阶段。在这个阶段，数据通过PPP的封装格式进行传输。</p><ul><li>PPP的数据帧包括：起始标志、地址字段、控制字段、协议字段、数据字段、循环冗余检查（CRC）字段等。</li><li>PPP使用一种简单的帧结构来传输数据，具有较低的协议开销。</li></ul><h4 id="链路终止"><a href="#链路终止" class="headerlink" title="链路终止"></a>链路终止</h4><p>在通信结束时，PPP协议会终止链路。链路终止使用LCP来完成，LCP交换终止请求和确认消息以断开链路。</p><h3 id="PPP帧结构"><a href="#PPP帧结构" class="headerlink" title="PPP帧结构"></a>PPP帧结构</h3><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412051744463.png" alt="image.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>协议独立性</strong>：PPP支持多种网络层协议，能够在同一链路上并行使用多种协议。</li><li><strong>错误检测</strong>：PPP提供了强大的错误检测功能，通过CRC校验保证数据传输的可靠性。</li><li><strong>可扩展性</strong>：PPP支持链路控制、身份验证和网络层协议的扩展。</li></ul><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p><strong>广播信道</strong>（Broadcast Channel）是指允许一个设备同时向多个设备发送数据的信道。广播信道支持多设备间的通信，通常在共享信道中多个设备共用同一物理介质。常见的广播信道协议包括<strong>VLAN协议</strong>和<strong>CSMA/CD协议</strong>。</p><p>首先我们需要了解一个概念：<strong>网络广播风暴</strong></p><p>在一个局域网中，当一个设备发送广播包时，所有在同一广播域内的设备都会接收该包并进行处理。如果网络拓扑没有正确管理（比如存在环路），广播包可能会不断地在网络中循环传播，从而造成广播风暴。</p><p>因此我们需要有一个东西来隔离广播域，限制广播流量的传播范围，从而减少网络中的广播风暴，提升网络性能和可管理性。我们使用到的这个技术就是<strong>VLAN（虚拟局域网）协议</strong></p><h3 id="VLAN协议"><a href="#VLAN协议" class="headerlink" title="VLAN协议"></a>VLAN协议</h3><p>VLAN工作在数据链路层（OSI模型的第2层），其核心是通过交换机进行流量转发。每个VLAN通过给网络设备上的数据帧添加一个<strong>VLAN标签</strong>来进行识别。VLAN标签通常位于以太网帧的头部，遵循<strong>IEEE 802.1Q</strong>标准。</p><p>VLAN技术把用户划分成多组逻辑的网络，组内可以通信，组间不允许通信。二层转发的单播、<a href="https://so.csdn.net/so/search?q=%E7%BB%84%E6%92%AD&amp;spm=1001.2101.3001.7020">组播</a>、广播报文只能在组内转发。为了实现转发控制，在待转发的<a href="https://so.csdn.net/so/search?q=%E4%BB%A5%E5%A4%AA%E7%BD%91&amp;spm=1001.2101.3001.7020">以太网</a>帧中添加 VLAN标签 ，然后<strong>设定交换机端口</strong>对该标签和帧的处理方式。方式包括丢弃帧、转发帧、添加标签、移除标签。</p><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412051842602.png" alt="image.png"></p><ul><li>标签协议标识TPID：固定取值为0x8100，表明这是一个携带802.1Q标签的帧</li><li>优先级PRI：指明帧的优先级。0-7，表示8种优先级，提供有差别的转发服务。</li><li>标准格式指示CFI：在以太网环境中，这个字段始终为0。</li><li><p>VLAN标识：它唯一地标志了以太网帧属于哪一个VLAN</p><ul><li><p>VID的取值范围是0~ 4095 （0 ~ 212-1），0和4095都不用来表示VLAN，因此用于表示VLAN的VID的有效取值范围是1 ~ 4094。</p><p>802.1Q帧是由交换机来处理的，而不是用户主机来处理的</p></li></ul></li><li><p>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”。</p></li><li>当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“去标签”。<br>端口上接收时总希望能够打上标签，发送出去时候总希望能去除标签</li></ul><h4 id="VLAN间通信"><a href="#VLAN间通信" class="headerlink" title="VLAN间通信"></a>VLAN间通信</h4><p>VLAN隔离了二层广播域，也就严格地隔离了各个VLAN之间的任何流量，分属于不同VLAN的用户不能互相通信。</p><p>不同VLAN 之间的流量不能直接跨越VLAN 的边界，需要使用路由，通过路由将报文从一个VLAN 转发到另外一个VLAN。</p><p>在主机设置默认网关，对于非本地的通信，主机会自动寻找默认网关，并把报文交给默认网关转发而不是直接发给目的主机。</p><p>让VLAN之间互通有几种方法。一是为每个VLAN 分配一个单独的路由接口，每一个VLAN使用一条独占的物理连接连接到路由器的一个接口上，但是这种方法会耗费大量的路由接口，因此并不常用。第二种是多个VLAN公用一条物理连接，这种方式也称为独臂路由或者<strong>单臂路由</strong>，它只需要一个以太网接口，通过创建子接口可以承担所有VLAN 的网关，从而在不同的VLAN 间转发数据。还有一种就是三层交换机。</p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p><strong>以太网（Ethernet</strong>是一种广泛使用的局域网（LAN）技术，用于计算机、设备和其他网络节点之间的数据传输。基于<strong>数据链路层（OSI模型的第2层</strong>和<strong>物理层（第1层）</strong>，提供可靠的、快速的和低成本的通信方式。</p><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><h3 id="理想情况下的信道利用率（无碰撞）"><a href="#理想情况下的信道利用率（无碰撞）" class="headerlink" title="理想情况下的信道利用率（无碰撞）"></a>理想情况下的信道利用率（无碰撞）</h3><p>在理想情况下，假设没有碰撞和重传，信道利用率可以通过以下公式来计算： <script type="math/tex">\text{信道利用率} = \frac{\text{有效数据传输时间}}{\text{总时间}} = \frac{\text{数据帧长度}}{\text{数据帧长度} + \text{间隔时间} + \text{帧间空闲时间}}</script><br>其中：</p><ul><li><strong>有效数据传输时间</strong>：指数据帧的传输时间。</li><li><strong>总时间</strong>：包括有效数据传输时间、间隔时间和帧间空闲时间。</li></ul><h2 id="考虑碰撞的信道利用率（实际情况）"><a href="#考虑碰撞的信道利用率（实际情况）" class="headerlink" title="考虑碰撞的信道利用率（实际情况）"></a>考虑碰撞的信道利用率（实际情况）</h2><p>实际情况中，由于使用了<strong>CSMA/CD</strong>协议，会发生碰撞和重传，从而影响信道利用率。计算实际信道利用率时需要考虑碰撞概率和重传的影响。</p><h3 id="有效传输时间"><a href="#有效传输时间" class="headerlink" title="有效传输时间"></a>有效传输时间</h3><p>在<strong>CSMA/CD</strong>中，发送设备会首先检查信道是否空闲，如果信道空闲，才开始传输数据。如果发生碰撞，数据丢失，需要重新传输。有效的传输时间是指成功传输数据的时间，不包括重传时间。</p><h3 id="碰撞和重传"><a href="#碰撞和重传" class="headerlink" title="碰撞和重传"></a>碰撞和重传</h3><p>碰撞发生后，设备需要等待随机的<strong>退避时间</strong>后再次发送数据。碰撞和重传占用了额外的时间，增加了信道的空闲时间，从而降低了信道的利用率。碰撞率越高，信道利用率越低。</p><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>实际情况下，以太网的信道利用率 U 可以通过以下公式来估算： <script type="math/tex">U = \frac{T*{\text{frame}}}{T*{\text{frame}} + T*{\text{collision}} + T*{\text{backoff}}}</script> 其中：</p><ul><li>$T_{\text{frame}}$ ：是数据帧的传输时间，等于数据长度除以传输速率。</li><li>$T_{\text{collision}}$：是发生碰撞后的恢复时间。</li><li>$T_{\text{backoff}}$：是退避时间，即发生碰撞后设备等待的随机时间。</li></ul><h2 id="以太网的吞吐量与信道利用率"><a href="#以太网的吞吐量与信道利用率" class="headerlink" title="以太网的吞吐量与信道利用率"></a>以太网的吞吐量与信道利用率</h2><p>信道利用率与吞吐量（Throughput）密切相关。吞吐量是单位时间内成功传输的数据量。当信道利用率较高时，吞吐量也较高。吞吐量的计算公式为： <script type="math/tex">\text{吞吐量} = \text{信道利用率} \times \text{信道带宽}</script> 在没有碰撞的情况下，吞吐量接近信道的最大带宽（例如 10Mbps、100Mbps 等）。但如果发生碰撞，吞吐量会减少，因为数据包丢失后需要重传。</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412051925899.png" alt="image.png"></p><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412051932804.png" alt="image.png"></p><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发，具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口<br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412051930620.png" alt="image.png"></p><p>和集线器不同的是，集线器在转发帧时，不对传输媒体进行检测，而且网桥在转发帧之前必须执行 CSMA/CD 算法，若在发送过程中出现碰撞，就必须停止发送和进行退避</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机的交换方式主要有几种，一是存储转发方式，把整个数据帧先缓存后再进行处理，第二种是直通 方式，接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度，缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p><p>交换机的转发依然是依赖于转发表，以太网交换机运行<strong>自学习算法</strong>自动维护转发表。<br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412052023918.png" alt="image.png"><br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412052024847.png" alt="image.png"><br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412052024677.png" alt="image.png"><br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412052024379.png" alt="image.png"></p><h1 id="数据链路层的子层"><a href="#数据链路层的子层" class="headerlink" title="数据链路层的子层"></a>数据链路层的子层</h1><p>数据链路层其实可以被进一步划分为两个子层：<strong>逻辑链路控制（LLC）子层</strong>和<strong>媒体访问控制（MAC）子层</strong></p><h2 id="逻辑链路控制（LLC）子层"><a href="#逻辑链路控制（LLC）子层" class="headerlink" title="逻辑链路控制（LLC）子层"></a>逻辑链路控制（LLC）子层</h2><p>LLC子层位于数据链路层的上层，主要负责为不同的网络协议提供统一的接口，并处理与网络层之间的交互。主要功能就是前面提及的帧的封装与解封装、错误控制与流量控制等。这里不再赘述，我们主要讲解的是数据链路层当中的MAC层。</p><h2 id="媒体访问控制（MAC）子层"><a href="#媒体访问控制（MAC）子层" class="headerlink" title="媒体访问控制（MAC）子层"></a>媒体访问控制（MAC）子层</h2><p>MAC子层负责数据链路层下层的功能，主要控制对物理介质的访问，确保在共享信道上多台设备能够有效地传输数据。其主要功能有下面几种</p><h3 id="地址寻址与识别"><a href="#地址寻址与识别" class="headerlink" title="地址寻址与识别"></a>地址寻址与识别</h3><p>MAC子层使用<strong>MAC地址</strong>（物理地址）来标识网络中的设备，确保数据能够正确地发送到目标设备。每个设备在其网卡中都有一个唯一的MAC地址，数据帧中包括源MAC地址和目标MAC地址。</p><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>MAC子层负责控制设备如何访问共享的通信介质。它使用不同的协议来避免不同设备在同一时刻发送数据导致碰撞。例如，在传统的以太网中，MAC使用<strong>CSMA/CD</strong>（载波侦听多路访问/碰撞检测）协议来解决设备争用信道的问题。</p><h3 id="帧的封装与传输"><a href="#帧的封装与传输" class="headerlink" title="帧的封装与传输"></a>帧的封装与传输</h3><p>MAC子层负责将网络层传来的数据封装成帧，并将这些帧通过物理介质发送出去。它也负责从物理介质接收帧，并将其传递给LLC子层进行解封装。</p><h3 id="错误检测-1"><a href="#错误检测-1" class="headerlink" title="错误检测"></a>错误检测</h3><p>MAC子层使用<strong>循环冗余校验</strong>（CRC）来检测数据传输过程中是否发生了错误。然后怎么处理错误就不是我们应该管的了</p><h2 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h2><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202412052043289.png" alt="image.png"></p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="MAC-子层怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议？"><a href="#MAC-子层怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议？" class="headerlink" title="MAC 子层怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议？"></a>MAC 子层怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议？</h3><p>在 以太网V2 的 MAC 帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC 子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？我们在前面讲述的曼彻斯特编码时已经讲过，这种曼彻斯特编码的一个重要特点就是：在曼彻斯特编码的每一个码元（不管码元是 1 或 0 ）的正中间一定有一次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送 1 ，也不发送 0 ）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数 4 字节（ FCS 字段长度是 4 字节），就能确定数据字段的结束位置。</p><h3 id="上层协议如何知道填充字段的长度？"><a href="#上层协议如何知道填充字段的长度？" class="headerlink" title="上层协议如何知道填充字段的长度？"></a>上层协议如何知道填充字段的长度？</h3><p>当数据字段的长度小于 46 字节时，MAC 子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。我们应当注意到，MAC 帧的首部并没有指出数据字段的长度是多少。在有填充字段的情况下，接收端的 MAC 子层在剥去首部和尾部后就把数据字段和填充字段一起交给上层协议。现在的问题是：上层协议如何知道填充字段的长度呢？（ IP 层应当丢弃没有用处的填充字段。）可见，上层协议必须具有识别有效的数据字段长度的功能。我们知道，当上层使用 IP 协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于 MAC 帧数据字段的长度。例如，当 IP数据报 的总长度为 42 字节时，填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后，IP 层就把其中最后 4 字节的填充字段丢弃。</p><h3 id="物理层比-MAC-层多出来的-8-个字节是什么"><a href="#物理层比-MAC-层多出来的-8-个字节是什么" class="headerlink" title="物理层比 MAC 层多出来的 8 个字节是什么"></a>物理层比 MAC 层多出来的 8 个字节是什么</h3><p>在传输媒体上实际传送的要比 MAC 帧还多8个字节。这是因为当一个站在刚开始接收 MAC 帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此 MAC 帧的最前面的若干位就无法接收，结果使整个的 MAC 成为无用的帧。为了接收端迅速实现位同步，从 MAC 子层向下传到物理层时还要在帧的前面插入 8 字节（由硬件生成），它由两个字段构成。第一个字段是 7 个字节的前同步码（ 1 和 0 交替码），它的作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”（位同步就是比特同步的意思）。第二个字段是帧开始定界符，定义为 10101011 。它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“ MAC 帧的信息马上就要来了，请适配器注意接收”。 MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片加载报错403，但可以单独打开图片链接——图片防盗链</title>
    <link href="/2024/11/24/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%8A%A5%E9%94%99403%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E6%89%93%E5%BC%80%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE/"/>
    <url>/2024/11/24/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%8A%A5%E9%94%99403%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E6%89%93%E5%BC%80%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>#杂项<br>最近在写博客的时候引用了一些图片链接，但是奇怪的是，页面上的图片是没有办法正常显示的，但是我们单独打开图片链接的时候又发现他是正常的。而这个现象其实就是图片加了防盗链。</p><h2 id="什么是防盗链？"><a href="#什么是防盗链？" class="headerlink" title="什么是防盗链？"></a>什么是防盗链？</h2><p>GPT说：<strong>图片防盗链</strong>是指通过技术手段限制未经授权的外部网站直接引用自己服务器上的图片资源。其目的是防止其他网站在未经许可的情况下，直接嵌入图片链接，从而盗用带宽和服务器资源，甚至侵犯图片版权。</p><p>比方说某校微学工发的不知道从哪来的天气预报的图片：<br><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/YRS0cSKfDj7DvMAz6ics7OcMiaeyRicF6KLg5GlGmG0D3apuRXr9Hln5AOh8yROibvCP1aAt066PYAsnzibtKibJYrqQ/640?wx_fmt=png&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="example"></p><p>看上面这张照片，我们博客里面看到的就会是类似“此图片来自微信公众平台，未经允许不可饮用”的字样，但是我们单独打开图片的时候（比如新标签页打开链接），图片就会显示正常。这其实就是给图片上了防盗链的表现</p><h2 id="他怎么知道的？"><a href="#他怎么知道的？" class="headerlink" title="他怎么知道的？"></a>他怎么知道的？</h2><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202411242254490.png" alt="image.png"><br>其实也简单，我们看上面这张图片，图中可以看出，我们请求体的header中有一个referrer字段，也就是</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">https:</span>//blog.zerohzzzz.cn/<span class="hljs-number">2024</span>/<span class="hljs-number">11</span>/<span class="hljs-number">24</span>/<span class="hljs-variable">%E5</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%BE</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%89</span><span class="hljs-variable">%87</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>A<span class="hljs-variable">%A0</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>A<span class="hljs-variable">%A5</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%94</span><span class="hljs-variable">%99403</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E4</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%AF</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%95</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%AC</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%89</span><span class="hljs-variable">%93</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%BE</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%89</span><span class="hljs-variable">%87</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%93</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%A5</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%97</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%A2</span><span class="hljs-variable">%98</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%95</span>/<br></code></pre></td></tr></table></figure><p>发起 HTTP 请求时，可以携带来源地址的信息，也就是 Referrer。这个 Referrer 信息是可选的，可以选择是否携带，但无法修改其具体内容，不能自定义 Referrer 的值。</p><p>服务器接收到 Referrer 后，可以基于此信息进行处理。例如，对于图片资源，服务器可以检查 Referrer 是否来自本站。如果不是，则返回 403 状态码或重定向到其他内容，以实现图片防盗链机制。出现 403 的原因通常是因为请求了其他服务器的资源，但请求中带上了自身的 Referrer 信息，被对方服务器识别并拦截，因此返回了 403 错误。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><h3 id="直接判断-Referrer"><a href="#直接判断-Referrer" class="headerlink" title="直接判断 Referrer"></a>直接判断 Referrer</h3><p>对于后端来说，判断这个东西其实是相对简单的。我们可以直接用Nginx来实现：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~* \.(gif|jpg|jpeg|png)$</span> &#123;<br>    <span class="hljs-attribute">valid_referers</span> <span class="hljs-literal">none</span> <span class="hljs-literal">blocked</span> yourdomain.com <span class="hljs-regexp">*.yourdomain.com</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$invalid_referer</span>) &#123;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然我们还有很多其他的方法，也不一定要使用判断 Referrer 的方法。</p><h3 id="图片动态加载"><a href="#图片动态加载" class="headerlink" title="图片动态加载"></a>图片动态加载</h3><p>我们可以实现一个图片动态加载服务，访问图片时并不暴露图片的实际路径，而是通过动态生成的 URL 提供访问。比方说下面我们使用 Go 来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/image&quot;</span>, imageHandler)<br><br>log.Println(<span class="hljs-string">&quot;Starting server on :8080...&quot;</span>)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 获取图片的名称，例如 /image?name=cat.jpg</span><br>imageName := r.URL.Query().Get(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-keyword">if</span> imageName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Image name not provided&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 拼接图片的实际路径</span><br>imagePath := <span class="hljs-string">&quot;./images/&quot;</span> + imageName<br><br><span class="hljs-comment">// 打开图片文件</span><br>file, err := os.Open(imagePath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Image not found&quot;</span>, http.StatusNotFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 设置响应头，声明返回的内容是图片</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;image/jpeg&quot;</span>)<br><br><span class="hljs-comment">// 将图片数据写入响应</span><br>_, err = io.Copy(w, file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Error serving the image&quot;</span>, http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── images<br>│   ├── cat<span class="hljs-selector-class">.jpg</span><br>│   ├── dog<span class="hljs-selector-class">.jpg</span><br>├── <span class="hljs-selector-tag">main</span>.go<br></code></pre></td></tr></table></figure><p>但是这个方法会有一些缺陷，因为后端会多一个 I/O 操作，大量并发请求可能导致服务器压力增加，因此并不是一个很好的办法。</p><h3 id="签名-URL"><a href="#签名-URL" class="headerlink" title="签名 URL"></a>签名 URL</h3><p>还有一种办法就是使用签名 URL 的办法，在生成图片 URL 时，附加一个<strong>签名</strong>（通常是基于哈希算法的加密字符串），这个签名与时间戳等信息结合，用于验证图片访问的合法性。签名 URL 一旦过期或被篡改，访问请求会被拒绝。验证逻辑由 CDN 或后端简单验证就行，这样性能会更好。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/hmac&quot;</span><br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;encoding/hex&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 定义密钥，用于生成和验证签名</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&quot;mysecretkey123&quot;</span><br><br><span class="hljs-comment">// 图片文件存储路径</span><br><span class="hljs-keyword">const</span> imagePath = <span class="hljs-string">&quot;./images/&quot;</span><br><br><span class="hljs-comment">// 生成签名 URL</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateSignedURL</span><span class="hljs-params">(imageName <span class="hljs-type">string</span>, validDuration time.Duration)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 过期时间戳</span><br>expiry := time.Now().Add(validDuration).Unix()<br><br><span class="hljs-comment">// 生成签名字符串</span><br>signature := createSignature(imageName, expiry)<br><br><span class="hljs-comment">// 生成签名 URL</span><br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;/image?name=%s&amp;expiry=%d&amp;signature=%s&quot;</span>, imageName, expiry, signature)<br>&#125;<br><br><span class="hljs-comment">// 生成签名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createSignature</span><span class="hljs-params">(imageName <span class="hljs-type">string</span>, expiry <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>data := fmt.Sprintf(<span class="hljs-string">&quot;%s|%d&quot;</span>, imageName, expiry)<br>h := hmac.New(sha256.New, []<span class="hljs-type">byte</span>(secretKey))<br>h.Write([]<span class="hljs-type">byte</span>(data))<br><span class="hljs-keyword">return</span> hex.EncodeToString(h.Sum(<span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// 验证签名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateSignature</span><span class="hljs-params">(imageName <span class="hljs-type">string</span>, expiry <span class="hljs-type">int64</span>, signature <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 检查是否过期</span><br><span class="hljs-keyword">if</span> expiry &lt; time.Now().Unix() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 重新生成签名</span><br>expectedSignature := createSignature(imageName, expiry)<br><br><span class="hljs-comment">// 验证签名是否一致</span><br><span class="hljs-keyword">return</span> hmac.Equal([]<span class="hljs-type">byte</span>(expectedSignature), []<span class="hljs-type">byte</span>(signature))<br>&#125;<br><br><span class="hljs-comment">// 图片处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 获取请求参数</span><br>imageName := r.URL.Query().Get(<span class="hljs-string">&quot;name&quot;</span>)<br>expiryStr := r.URL.Query().Get(<span class="hljs-string">&quot;expiry&quot;</span>)<br>signature := r.URL.Query().Get(<span class="hljs-string">&quot;signature&quot;</span>)<br><br><span class="hljs-comment">// 验证参数完整性</span><br><span class="hljs-keyword">if</span> imageName == <span class="hljs-string">&quot;&quot;</span> || expiryStr == <span class="hljs-string">&quot;&quot;</span> || signature == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Invalid request parameters&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 转换过期时间戳</span><br>expiry, err := strconv.ParseInt(expiryStr, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Invalid expiry parameter&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 验证签名</span><br><span class="hljs-keyword">if</span> !validateSignature(imageName, expiry, signature) &#123;<br>http.Error(w, <span class="hljs-string">&quot;Invalid or expired signature&quot;</span>, http.StatusForbidden)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 拼接图片路径</span><br>filePath := imagePath + imageName<br><br><span class="hljs-comment">// 打开图片文件</span><br>file, err := http.Dir(imagePath).Open(imageName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Image not found&quot;</span>, http.StatusNotFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 设置响应头并返回图片内容</span><br>http.ServeFile(w, r, filePath)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 生成示例签名 URL</span><br>imageName := <span class="hljs-string">&quot;cat.jpg&quot;</span><br>validDuration := <span class="hljs-number">10</span> * time.Minute<br>signedURL := generateSignedURL(imageName, validDuration)<br>fmt.Printf(<span class="hljs-string">&quot;Generated signed URL: http://localhost:8080%s\n&quot;</span>, signedURL)<br><br><span class="hljs-comment">// 注册路由</span><br>http.HandleFunc(<span class="hljs-string">&quot;/image&quot;</span>, imageHandler)<br><br><span class="hljs-comment">// 启动服务器</span><br>fmt.Println(<span class="hljs-string">&quot;Starting server on :8080...&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error starting server:&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#杂项</tag>
      
      <tag>Nginx</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境下从源码编译OpenCV</title>
    <link href="/2024/11/13/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OpenCV/"/>
    <url>/2024/11/13/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OpenCV/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu #OpenCV<br>最近我需要用到OpenCV来过正方图片验证码，而我们使用apt源中的OpenCV版本是<code>4.5.0</code>，过于古老，由于我在这个场景下只需要用到核心的模块，不用去搞opencv_contrib的部分。因此我选择从源码进行编译，在此做一个记录。</p><h2 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update &amp;&amp; <span class="hljs-built_in">sudo</span> apt install -y cmake g++ wget unzip<br></code></pre></td></tr></table></figure><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O opencv.zip https://github.com/opencv/opencv/archive/4.x.zip<br><br>unzip opencv.zip<br><br><span class="hljs-built_in">mkdir</span> -p build &amp;&amp; <span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>然后我们使用cmake去生成makefile，这里也就不再赘述了，仅记录几个坑点：</p><h3 id="pkg-config安装"><a href="#pkg-config安装" class="headerlink" title="pkg-config安装"></a>pkg-config安装</h3><p><code>pkg-config</code> 是一个工具，用于在编译和链接程序时查找和设置依赖库的编译参数。在使用 OpenCV 等库时，<code>pkg-config</code> 可以帮助我们获取这些库所需的编译和链接标志，解放双手，丢掉大脑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://pkg-config.freedesktop.org/releases/pkg-config-0.29.2.tar.gz<br><br>tar -zxvf pkg-config-0.29.2.tar.gz<br><br><span class="hljs-built_in">cd</span> pkg-config-0.29.2/<br>./configure<br>make<br>make check<br><span class="hljs-built_in">sudo</span> make install<br><br>pkg-config --version<br></code></pre></td></tr></table></figure><h3 id="无-opencv-pc-文件，编译依赖-OpenCV-的项目时需要手动指定库的路径"><a href="#无-opencv-pc-文件，编译依赖-OpenCV-的项目时需要手动指定库的路径" class="headerlink" title="无 opencv.pc 文件，编译依赖 OpenCV 的项目时需要手动指定库的路径"></a>无 opencv.pc 文件，编译依赖 OpenCV 的项目时需要手动指定库的路径</h3><p>这个文件会包含 OpenCV 的编译和链接信息，以便通过 <code>pkg-config</code> 命令获取这些参数。没有这个玩意后面会有点麻烦。因此我建议还是在cmake中启用<code>OPENCV_GENERATE_PKGCONFIG</code>选项</p><h3 id="可执行文件运行时找不到共享库"><a href="#可执行文件运行时找不到共享库" class="headerlink" title="可执行文件运行时找不到共享库"></a>可执行文件运行时找不到共享库</h3><p>由于我们Linux默认是动态链接的，即有些共享库是在可执行文件运行时才链接进来的。因此我们正确地链接生成可执行文件之后并不能保证正确地运行，可能会找不到共享库报错，但是实际上我们是有这个共享库的。</p><p>这时，我们就应该通过指定环境变量<code>LD_LIBRARY_PATH</code>来告诉系统我们想要搜索的共享库目录。即通过以下命令将<code>/usr/local/lib</code>添加到共享库搜索目录的环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#OpenCV</tag>
      
      <tag>#Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode配置java环境</title>
    <link href="/2024/09/16/Vscode%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/09/16/Vscode%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>#java #VSCode<br>由于上课的需要，我开始考虑使用vscode作为java的ide。在此作为一个记录</p><p>我到VsCode的官网翻了翻，发现他提供了一个Coding Pack，里面包含了VS Code、JDK以及一些必要的插件，因此如果嫌麻烦直接用下面的链接安装就好了。</p><p><a href="https://aka.ms/vscode-java-installer-win">Windows - Coding Pack</a><br><a href="https://aka.ms/vscode-java-installer-mac">MacOS - Coding Pack</a></p><p>但是很显然我并没有用这个，<del>主要是因为刚开始我没看到</del></p><p>如果按照正常的安装流程，我们需要先有VsCode，这个自不必多言。然后就需要安装<a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack">Extension Pack for Java</a>这个插件包，里面提供包含了一些可能需要的插件。但是我看了一眼发现这个插件包只有两个插件是必要的，也就是- <a href="https://marketplace.visualstudio.com/items?itemName=redhat.java">Language Support for Java™ by Red Hat</a>和 <a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug">Debugger for Java</a></p><p>接下来我们就需要安装JDK~</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="什么是JDK？"><a href="#什么是JDK？" class="headerlink" title="什么是JDK？"></a>什么是JDK？</h3><p>JDK（Java Development Kit）是Java开发工具包，用于开发Java应用程序，它包含了编写、编译、调试Java代码的工具，最重要的工具是<code>javac</code>，用于将Java源代码编译成字节码。</p><p>而JRE是Java运行时环境，专门用于运行Java程序。JDK包含了JRE，所以它可以执行和开发Java程序。因此，JDK = JRE + 开发工具</p><p>因此我们需要用到的是JDK而不是JRE。因为我们需要编译并运行代码。</p><h3 id="安装哪个JDK？"><a href="#安装哪个JDK？" class="headerlink" title="安装哪个JDK？"></a>安装哪个JDK？</h3><p>Java的特点是百花齐放，不像c#或者go只有一家主导。因此我们不止有JDK的发行版需要选择，还有JDK的版本需要选择。有以下发行版可供选择：</p><ul><li><a href="https://aws.amazon.com/corretto">Amazon Corretto</a></li><li><a href="https://www.azul.com/downloads/?package=jdk">Azul Zulu</a></li><li><a href="https://adoptium.net/">Eclipse Adoptium’s Temurin</a></li><li><a href="https://developer.ibm.com/languages/java/semeru-runtimes">IBM Semeru Runtimes</a></li><li><a href="https://www.microsoft.com/openjdk">Microsoft Build of OpenJDK</a></li><li><a href="https://www.oracle.com/java/technologies/javase-downloads.html">Oracle Java SE</a></li><li><a href="https://developers.redhat.com/products/openjdk/download">Red Hat build of OpenJDK</a></li><li><a href="https://sapmachine.io/">SapMachine</a></li></ul><p>一般来说，我更推荐Eclipse Adoptium’s Temurin，因为它的前身是著名的AdoptOpenJDK，更新到jdk16后就停止更新了，因为AdoptOpenJDK移交给Eclipse基金会后改名为：Adoptium Eclipse Temurin，后续维护工作就交给Eclipse基金会了。当然如果你公司不怕花钱，你可以选择用甲骨文Oracle官方的JDK，最后的甲骨文免费版是jdk8u202，想用后面的版本就得花钱了，甲骨文的JDK肯定是最稳定、最效率、最专业的，如果不想花钱那就推荐用Adoptium Eclipse Temurin这个OpenJDK发行版。它背后是Eclipse基金会，项目稳定，多家大厂支持，不受制于某一特定厂家。</p><p>现在是版本。一般来说常用的是JDK8、JDK11、JDK17和最新的JDK21这几个版本，除此之外还有一堆。我更推荐JDK17，他是当前热门的 LTS 版本，但是相对来说，JDK8和JDK11是最常用的长期支持版本。JDK11的生态不太行，参杂在JDK8与JDK17之间。</p><p>知乎大佬直呼：</p><p>一直以来，Java8 都是 Java 社区心头的痛。因为它代表着以稳定性为主的企业管理层，与拥抱变化为主的底层码农层之间的、爱的魔力拉锯战。</p><p>不升！成为各大厂心照不宣的选择。</p><p>现在，这种平衡或将打破。因为 Java 届的霸主框架 SpringBoot，选择了最小支持的 Java lts 版本，就是最新的 Java17。</p><p>看来看去，还是选择了JDK17。</p><h2 id="你的第一份Java代码"><a href="#你的第一份Java代码" class="headerlink" title="你的第一份Java代码"></a>你的第一份Java代码</h2><p>创建一个新的java文件，然后输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409160250810.png" alt="image.png"></p><p>然后点击RUN即可。</p><blockquote><p>[!Note] 一点小提示<br>如果你在 VS Code 中打开一个 Java 文件但不打开其所在的文件夹，Java 语言服务器可能无法正常工作。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>#VSCode</tag>
      
      <tag>#java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ADB实现短信发送</title>
    <link href="/2024/09/13/%E4%BD%BF%E7%94%A8ADB%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/"/>
    <url>/2024/09/13/%E4%BD%BF%E7%94%A8ADB%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/</url>
    
    <content type="html"><![CDATA[<p>#ADB #短信服务 #安卓<br>最近社团工作需要使用短信发送面试通知，本来我们是想直接使用诸如阿里云一类的<a href="https://www.aliyun.com/product/sms">短信服务</a>的，但由于短信模板审核一直无法通过，我不得不寻求其他替代方案。最终，我想到可以利用ADB（Android Debug Bridge）实现短信的自动发送。在这过程中遇到了一些挑战，特此记录下来，帮助后人少走弯路</p><h2 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h2><p>实现这个功能的核心在于两条ADB命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 打开系统默认的短信应用并填充内容<br>adb shell am start -a android.intent.action.SENDTO -d sms:&lt;phone&gt; --es sms_body <span class="hljs-string">&quot;&lt;text&gt;&quot;</span><br><br>// 模拟点击发送按键<br>adb shell input tap &lt;x&gt; &lt;y&gt;<br></code></pre></td></tr></table></figure><p>第一条命令的含义是打开系统默认的短信引用并填充内容，但是并不会自动发送，因此我们需要第二条命令模拟点击发送按键。为了获取点击位置，一个简单的方式就是通过我们手机的开发者选项，打开“显示触摸操作”和“显示指针位置”之类的设置，然后我们手动进行测试得出触摸屏幕的xy坐标即可。</p><p>这个方式在shell使用的时候是正常的，然而当我将这些命令移植到Python脚本中时，发现它并不总是如预期般顺利，也就是会失效而导致无法正确获取焦点，导致后面的输入都会出现问题。想来可能是因为设备没有足够的时间去处理每个命令，因此我们可以尝试使用滑动的命令或者使用<code>time.sleep(0)</code>的方法延长操作时间，让设备有足够的时间处理命令。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell input swipe &lt;from_x&gt; &lt;from_y&gt; &lt;to_x&gt; &lt;to_y&gt;<br></code></pre></td></tr></table></figure><p>接下来我们需要进入下一个问题的解决。对于面试短信而言，那当然包含面试人姓名、面试时间、面试地点等信息，那简单来说，其实我们正常做一个短信模板，然后把变量填充进去，然后直接通过上面的命令填充到短信应用发送就完了。但是显然这一切并没有这么简单。</p><h2 id="处理多行短信内容"><a href="#处理多行短信内容" class="headerlink" title="处理多行短信内容"></a>处理多行短信内容</h2><p>面试通知的短信模板通常会包含诸如面试者姓名、面试时间、地点等多个变量的信息。按理说，可以将这些变量填充进短信模板，然后使用上面的命令发送即可。然而，在实际操作中，使用<code>adb shell am start -a android.intent.action.SENDTO -d sms:&lt;phone&gt; --es sms_body &quot;&lt;text&gt;&quot;</code>命令发送多行文本时，只有第一行被填充，其他行被忽略。</p><p>既然这个不行，那我分成多行输入不就得了。但是这个时候又出现了一个问题，那就上面这个写法是覆写文本框而不是追加内容。因此这种方法并不可行。</p><h2 id="逐步填充文本框"><a href="#逐步填充文本框" class="headerlink" title="逐步填充文本框"></a>逐步填充文本框</h2><p>于是我只能尝试使用一个很呆的方法，那就是用上面这个命令打开短信应用但不填充内容，然后再通过点击文本框获取焦点，逐行填充内容。也就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开默认短信应用</span><br>adb shell am start -a android.intent.action.SENDTO -d sms:&lt;phone&gt;<br><br><span class="hljs-comment"># 点击文本框获取焦点</span><br>adb shell input tap &lt;x&gt; &lt;y&gt;<br><br><span class="hljs-comment"># 填充内容</span><br>adb shell input text &lt;text&gt;<br></code></pre></td></tr></table></figure><p>此时出现了一个新的问题：<code>adb shell input text</code>命令无法输入中文，导致报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exception occurred <span class="hljs-keyword">while</span> executing <span class="hljs-string">&#x27;text&#x27;</span>:<br>java.lang.NullPointerException: Attempt to get length of null array<br></code></pre></td></tr></table></figure><h2 id="ADBKeyBoard"><a href="#ADBKeyBoard" class="headerlink" title="ADBKeyBoard"></a>ADBKeyBoard</h2><p>上面的问题是因为<code>adb shell input text</code>命令不能输入中文，因为它并不是为此目的而设计的。但是幸运的是，有这个项目的存在：<a href="[senzhk/ADBKeyBoard: Android Virtual Keyboard Input via ADB (Useful for Test Automation">ADBKeyboard</a> (github.com)](<a href="https://github.com/senzhk/ADBKeyBoard))，这使得后续的工作得以顺利进行。">https://github.com/senzhk/ADBKeyBoard))，这使得后续的工作得以顺利进行。</a></p><p>因此我们只需要先<a href="https://github.com/senzhk/ADBKeyBoard/blob/master/ADBKeyboard.apk">下载</a>并安装ADBKeyBoard，然后再命令行中启用ADBKeyBoard并将其设置为默认输入法即可。可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell ime <span class="hljs-built_in">enable</span> com.android.adbkeyboard/.AdbIME<br>adb shell ime <span class="hljs-built_in">set</span> com.android.adbkeyboard/.AdbIME<br></code></pre></td></tr></table></figure><p>当我们完成任务的时候，可以使用以下命令来将系统输入法服务重置为默认选项，省去手动切换的麻烦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell ime reset<br></code></pre></td></tr></table></figure><h2 id="脚本，启动！"><a href="#脚本，启动！" class="headerlink" title="脚本，启动！"></a>脚本，启动！</h2><p>知道了这些，后面就简单了。接下来就是编写实际的Python脚本，根据Excel表格中的数据逐条发送面试通知短信。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill_template_from_excel</span>(<span class="hljs-params">template_path, excel_path</span>):<br>    <span class="hljs-keyword">try</span>:<br>        df = pd.read_excel(excel_path)<br>        <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():<br>            phone = row[<span class="hljs-string">&#x27;Phone&#x27;</span>]<br>            variables = &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: row[<span class="hljs-string">&#x27;Name&#x27;</span>],<br>                <span class="hljs-string">&quot;time&quot;</span>: row[<span class="hljs-string">&#x27;Time&#x27;</span>]<br>            &#125;<br><br>            output_lines = []<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(template_path, <span class="hljs-string">&#x27;r&#x27;</span>,<br>             encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>                    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> variables.items():<br>                    <span class="hljs-comment"># 如果变量存在于当前行，则进行替换</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">f&quot;&#123;&#123;<span class="hljs-subst">&#123;key&#125;</span>&#125;&#125;&quot;</span> <span class="hljs-keyword">in</span> line:<br>                            line = line.replace(<span class="hljs-string">f&quot;&#123;&#123;<span class="hljs-subst">&#123;key&#125;</span>&#125;&#125;&quot;</span>, value)<br>                    output_lines.append(line)<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;生成的消息（第 <span class="hljs-subst">&#123;index + <span class="hljs-number">1</span>&#125;</span> 行）：&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;手机号：<span class="hljs-subst">&#123;phone&#125;</span>&quot;</span>)<br>           <br>            os.system(<span class="hljs-string">f&quot;adb shell am start -a android.intent.action.SENDTO -d sms:<span class="hljs-subst">&#123;phone&#125;</span>&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 这里不能太快，不然会出现焦点错误的问题</span><br>            os.system(<span class="hljs-string">&quot;adb shell input tap 389 2305&quot;</span>)<br>           <br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> output_lines:<br>                os.system(<span class="hljs-string">f&quot;adb shell am broadcast -a ADB_INPUT_TEXT --es msg \&quot;<span class="hljs-subst">&#123;line&#125;</span>\&quot;&quot;</span>)<br>                <span class="hljs-comment"># 系统默认回车</span><br>                os.system(<span class="hljs-string">&quot;adb shell input keyevent 66&quot;</span>)<br> <br>            <span class="hljs-comment"># 发送按键位置</span><br>            os.system(<span class="hljs-string">&quot;adb shell input swipe 985 2140 985 2140&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">50</span>)<br><br>    <span class="hljs-keyword">except</span> FileNotFoundError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件未找到: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Excel 文件中缺少所需的列: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;读取文件或处理数据时发生错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    template_path = <span class="hljs-string">&quot;text.txt&quot;</span><br>    excel_path = <span class="hljs-string">&quot;data.xlsx&quot;</span><br>   <br>    fill_template_from_excel(template_path, excel_path)<br></code></pre></td></tr></table></figure><h2 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h2><p>实际使用的时候，有可能会出现这个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Broadcast completed: result=0<br>Broadcasting: Intent &#123; act=ADB_INPUT_TEXT dat=8: flg=0x400000 (has extras) &#125;<br></code></pre></td></tr></table></figure><p>然后文本框输入时空的。这是因为输入的文本中有不应存在的空格….就是系统会将文本中的空格识别为命令分隔符，因此没有输入也算是正常。此时我们是使用<br><code>%s</code>表示空格是没有用的，因此我们需要对空格进行转义…（也就我随便试试才知道这个逆天的操作的）</p><p>是的，你没有看错。我们需要对文本进行转义。例如：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> 面试时间：<span class="hljs-number">9</span>月<span class="hljs-number">21</span>日&#123;time&#125;<br></code></pre></td></tr></table></figure><p>说实话，这种写法，我也是头一回见到。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>通过上述方法，我们成功实现了利用ADB自动化发送面试通知短信的过程。虽然使用ADB的方式在稳定性上不如专业的短信服务，但在某些特定场景下，它依然可以作为一种临时解决方案。</p><p>其实正如冰冰学长提到，如果是他，他可能会选择使用KDE Connect这类工具来实现类似的功能。而KDE Connect是一种用于跨设备通信和共享的工具，可能提供更加灵活和便捷的方式来处理短信发送。不过由于时间关系，我还没来得及对这种方法进行实验和验证。希望后续有时间能探索更优的解决方案，尝试使用他所说的工具甚至是使用开发安卓应用等方式实现短信发送<del>（看起来不会那么呆，安卓应用的话几行就写完了）</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>#ADB</tag>
      
      <tag>#短信服务</tag>
      
      <tag>#安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git warning：LF will be replaced by CRLF the next time Git touches it</title>
    <link href="/2024/09/11/Git%20warning%EF%BC%9ALF%20will%20be%20replaced%20by%20CRLF%20the%20next%20time%20Git%20touches%20it/"/>
    <url>/2024/09/11/Git%20warning%EF%BC%9ALF%20will%20be%20replaced%20by%20CRLF%20the%20next%20time%20Git%20touches%20it/</url>
    
    <content type="html"><![CDATA[<p>#github</p><p>这个警告表明文件的行尾符（Line Feed，简称 LF）将被替换为回车符和换行符（Carriage Return Line Feed，简称 CRLF）——也就是说，文件的行尾格式会发生变化。</p><p>这其实是由于不同操作系统对行尾符的处理方式不同：</p><ul><li><strong>Linux 和 macOS</strong> 使用 LF (<code>\n</code>) 作为行尾符。</li><li><strong>Windows</strong> 使用 CRLF (<code>\r\n</code>) 作为行尾符。</li></ul><p>Git 提供了一些配置来处理这种跨平台的行尾符差异：<br><code>core.autocrlf</code> 设置</p><ul><li>当它被设置为 <code>true</code> 时，Git 在将文件检出到工作目录时，会自动将 LF 转换为 CRLF；而在提交时，又会将 CRLF 转换回 LF。</li><li>当它被设置为 <code>input</code> 时，Git 只会在提交时将 CRLF 转换为 LF，而不对检出时的行尾符进行转换。- 设置为 <code>false</code> 时，Git 不会进行任何行尾符的转换。</li></ul><p>如果我们希望避免这个警告，可以根据项目的需求或系统的习惯调整 <code>core.autocrlf</code> 配置，使得 Git 不会自动修改行尾符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.autocrlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>我们也可以在项目的 <code>.gitattributes</code> 文件中指定行尾符的处理方式，使得 Git 会强制所有 HTML 文件使用 LF 行尾符。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.html text eol=lf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL：”NAT 模式下的 WSL 不支持 localhost 代理“提示以及mirrored网络模式与TUN模式的冲突</title>
    <link href="/2024/09/11/WSL%EF%BC%9A%E2%80%9DNAT%20%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%20WSL%20%E4%B8%8D%E6%94%AF%E6%8C%81%20localhost%20%E4%BB%A3%E7%90%86%E2%80%9C%E6%8F%90%E7%A4%BA%E4%BB%A5%E5%8F%8Amirrored%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E4%B8%8ETUN%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%B2%E7%AA%81/"/>
    <url>/2024/09/11/WSL%EF%BC%9A%E2%80%9DNAT%20%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%20WSL%20%E4%B8%8D%E6%94%AF%E6%8C%81%20localhost%20%E4%BB%A3%E7%90%86%E2%80%9C%E6%8F%90%E7%A4%BA%E4%BB%A5%E5%8F%8Amirrored%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E4%B8%8ETUN%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p>#wsl #nat #网络<br>我们在启动wsl的时候经常看到这样的提示，这样我很是不爽</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。<br></code></pre></td></tr></table></figure><p>这个问题其实是因为我使用了TUN模式进行代理，它会将系统的所有流量通过代理，包括 <code>localhost</code> 流量。<del>但是这个问题对我来说其实问题不大毕竟我用TUN</del></p><p>这个要说的话其实是WSL2更新了一种新的网络模式。首先我们就需要说一下这个wsl和wsl2的区别了。</p><p>WSL 1 与 Windows 系统共享同一个 IP 地址。因此，网络请求的处理比较简单，Linux 子系统内的应用程序可以直接通过 Windows 的 IP 地址进行访问。而WSL 2 使用了 Hyper-V 虚拟化技术，在运行时有一个独立的虚拟机。因此，WSL 2 的 Linux 子系统有自己的虚拟机 IP 地址，不再与 Windows 系统共享同一个 IP。</p><p>由于 WSL 2 使用独立的 IP，默认情况下服务无法通过 <code>localhost</code> 访问，需要获取 WSL 2 的 IP 地址才能访问。因此Windows 增加了一个机制，通过一些额外的配置，使得 WSL 2 内的服务可以通过 <code>localhost</code> 访问。这个也就是后面我们要说的网络的mirror模式。</p><p>如果我们需要使用这个镜像模式，只需要在用户文件夹下将<code>.wslconfig</code>文件中，添加网络模式相关配置就行了。即：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">experimental</span>]<br><span class="hljs-string">networkingMode=NAT</span><br></code></pre></td></tr></table></figure><p>这样一来就和wsl有点像了，主机中的localhost和WSL2中的成为同一个，也就是将<code>localhost</code>镜像到WSL中了。</p><p>但是这个模式虽然方便，但是还是会给我们带来一些问题。例如我们使用tun模式进行代理的时候，WSL2内部会出现一个断网的现象。这是由于WSL2网络接口的mtu为1500，而tun模式虚拟出来的网卡接口mtu为9000，因此数据传输的过程中会出现一些问题。因此我们在WSL2中将这个tun模式的虚拟接口mtu改为1500即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev &lt;Ethernet interface&gt; mtu 1500<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#wsl</tag>
      
      <tag>#nat</tag>
      
      <tag>#网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2 图形界面</title>
    <link href="/2024/09/10/WSL2%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    <url>/2024/09/10/WSL2%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>#wsl #x11<br>VcXsrv、X410 和 Xming 都是用于在 Windows 系统上运行 X11 应用程序的开源 X 服务器，主要作用是在 Windows 系统上为 X11 应用程序提供显示支持。但是考虑到近几年的Xming在维护方面较为落后，而且听说虽然X410需要付费但是可以一直试用，因此我们选择了X410作为我们的X服务器</p><p>首先我们需要了解一下，什么是X11，以及这些东西到底是做什么的。</p><h2 id="X11-协议"><a href="#X11-协议" class="headerlink" title="X11 协议"></a>X11 协议</h2><p><strong>X11</strong> 是一种网络透明的窗口系统协议，常用于 Unix/Linux 系统上。它允许图形用户界面的应用程序通过网络将其显示内容发送到 X 服务器。X 服务器负责显示窗口和处理用户输入（如鼠标点击、键盘输入等）。</p><p>在这种架构中，X 服务器负责屏幕输出和输入管理，<strong>X 客户端</strong>（应用程序）与 <strong>X 服务器</strong>通信来展示图形界面。而X 服务器是一个负责绘制图形和管理窗口的服务。在 Linux 系统上，X 服务器直接运行在本地，提供桌面显示。</p><p>当我们在 Windows 上运行 VcXsrv 或 Xming 时，它们就相当于一个虚拟的 X 服务器，模拟 Linux 系统的 X 服务器环境。Linux 应用程序通过 X11 协议将绘图请求发送给 VcXsrv/Xming，后者再把这些请求转化为 Windows 系统可以理解的图形指令，从而在 Windows 上显示。</p><p>在 WSL 中，X11 请求是通过 <code>localhost</code> 进行本地转发，因此性能非常高，并且通信延迟较低</p><h2 id="WSLg-WSL-GUI-支持"><a href="#WSLg-WSL-GUI-支持" class="headerlink" title="WSLg (WSL GUI 支持)"></a>WSLg (WSL GUI 支持)</h2><p>WSL其实是有自己的图形化界面的解决方法的。自 <strong>WSL 2</strong> 之后，微软推出了原生支持 GUI 应用的 <strong>WSLg (Windows Subsystem for Linux GUI)</strong> 功能。它无需手动安装 VcXsrv 或 Xming，直接通过 WSL 提供对 Linux GUI 应用程序的原生支持。WSLg 在后台自动管理 X 服务器，使 Linux 应用程序的图形界面可以无缝显示在 Windows 上。</p><p>但是这个方法我觉得页面相对比较简陋，示例如下：<br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409102007318.png" alt="image.png"></p><h2 id="使用X服务器"><a href="#使用X服务器" class="headerlink" title="使用X服务器"></a>使用X服务器</h2><p>我使用的是X410，因此下面的内容我将会用X410作为例子，并详细记录我探索的过程。</p><p>现在我们看到的页面就是这样了：</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409110051138.png" alt="image.png"></p><p>根据官方文档中的说法，我们只需要配置一个环境变量<code>DISPLAY</code>，让wsl中的应用知道将图形请求发送到哪里就行了。</p><p>为了简单，我们直接编辑 <code>.bashrc</code> 文件，设置 <code>DISPLAY</code> 环境变量就行了。对于wsl1而言，我们这样做就足够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export DISPLAY=localhost:0.0&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>这将确保在每次启动 WSL 时，<code>DISPLAY</code> 变量都被正确设置。</p><p>但是我使用的是wsl2，这两个最大的区别就是，wsl的localhost和宿主机是同一个，而wsl2是不同的，因此也衍生出后面的mirror-mode网络模式，<del>给我带来了一堆问题</del></p><p>根据官网的说法，我们需要这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DISPLAY=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="hljs-string">&#x27;&#123;print $2; exit;&#125;&#x27;</span>):0.0<br></code></pre></td></tr></table></figure><p>整个命令的作用就是从<code>/etc/resolv.conf</code>这个文件中提取当前系统的 <code>nameserver</code> IP 地址，并将它与 <code>:0.0</code> 结合，设置为 <code>DISPLAY</code> 变量。这种方法也许是有效的，但是我的情况有点复杂，并没有成功。</p><p>但是依旧出现了问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: Can<span class="hljs-string">&#x27;t open display: 10.255.255.254:0.0</span><br></code></pre></td></tr></table></figure><p>我们重新回去看刚才所执行的设置<code>DISPLAY</code>变量的命令，这句命令中获取的主机server的ip是从<code>resolv.conf</code>文件中提取出来的。我们看到，这个文件里面是长这个样子的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span><br><span class="hljs-comment"># [network]</span><br><span class="hljs-comment"># generateResolvConf = false</span><br><span class="hljs-string">nameserver</span> <span class="hljs-number">10.255</span><span class="hljs-number">.255</span><span class="hljs-number">.254</span><br></code></pre></td></tr></table></figure><p>但是我们使用<code>ip route</code>的时候看到的内容是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">default via 172.18.16.1 dev eth0 proto kernel<br>172.18.16.0/20 dev eth0 proto kernel scope <span class="hljs-built_in">link</span> src 172.18.31.70<br></code></pre></td></tr></table></figure><p>也就是说，此时<code>resolv.conf</code>显示的nameserver并不是指向主机的虚拟网络接口。因此无法显示是正常的。那么这个东西指向的是什么呢？</p><p>查了一下资料，<code>resolv.conf</code>这个文件用于指定域名解析（DNS）服务器的地址。目前来看，他指向的是<code>10.255.255.254</code>这个地址。我们返回去使用<code>ip a</code>命令查看的时候，我们看到的是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet 10.255.255.254/32 brd 10.255.255.254 scope global lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host<br>       valid_lft forever preferred_lft forever<br>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:15:5d:04:f9:94 brd ff:ff:ff:ff:ff:ff<br>    inet 172.18.31.70/20 brd 172.18.31.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::215:5dff:fe04:f994/64 scope <span class="hljs-built_in">link</span><br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>我有开始怀疑，这个地址指向的是wls虚拟的 DNS 隧道，然后这个DNS隧道再将信息传递给主机系统的 DNS 服务。我们尝试将wsl2的dns隧道功能关闭之后，这个文件中的内容变成了这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span><br><span class="hljs-comment"># [network]</span><br><span class="hljs-comment"># generateResolvConf = false</span><br><span class="hljs-string">nameserver</span> <span class="hljs-number">172.18</span><span class="hljs-number">.16</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>这进一步证实了我刚才的想法。而我们在主机中通过<code>ipconfig</code>命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">以太网适配器 vEthernet (WSL (Hyper-V firewall)):<br><br>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::b828:9895:d8cb:57e7%71<br>   IPv4 地址 . . . . . . . . . . . . : 172.18.16.1<br>   子网掩码  . . . . . . . . . . . . : 255.255.240.0<br>   默认网关. . . . . . . . . . . . . :<br></code></pre></td></tr></table></figure><p>我们看到，这个确实是WSL所虚拟出来的网络接口的地址。这种变化是因为我关闭了 WSL2 的 DNS 隧道管理。关闭隧道后，WSL2 不再自动生成 <code>10.255.255.254</code> 这样的虚拟 DNS，转而使用与 Windows 主机共享的虚拟网络适配器 (<code>172.18.16.1</code>)，通过此适配器进行网络通信和 DNS 查询。</p><p>因此为了规避这个问题，我们使用以下命令就能将图形请求发送到正确的接口上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DISPLAY=$(ip route | grep default | awk <span class="hljs-string">&#x27;&#123;print $3; exit;&#125;&#x27;</span>):0.0<br></code></pre></td></tr></table></figure><p>但是当我们同时使用mirrored网络模式和DNS隧道，然后还使用tun模式进行代理的的时候，以上两种方法获取到的主机接口都是错误的（属实是buff叠满了）。此时只能我们手动去配置。因此我的建议是使用nat网络模式，这样会使得一切都变得简单起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#wsl</tag>
      
      <tag>#x11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Action自动部署Hexo博客</title>
    <link href="/2024/09/08/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/09/08/%E4%BD%BF%E7%94%A8Github%20Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>#github #GitHubPages #hexo</p><p>因为懒所以懒</p><p>之前不是用Obsidian的git插件实现了自动同步，我转念一想，干脆搞个GitHub Aciton自动发布到博客好了，免得我自己再手动输一行命令去发布<del>多累啊</del></p><p>我使用的架构是这样的，由于先前我们Obsidian使用用来备份的仓库和我们的GitHub Page仓库不是同一个，而且我们也是直接把文章的源文件放到了main分支中，因此我决定将Hexo相关配置放到ObsidanNote仓库的Hexo分支，然后让GitHub Action去调用就行了。</p><p>首先我们需要搞一个Token</p><p>因为我们需要在 <strong>Hexo 项目仓库</strong> 执行 <strong>Github Actions</strong> 向 <strong>username.github.io 仓库</strong>推送代码，由于 Github 权限限制，我们需要在 GitHub 账户中创建一个具有足够权限的<strong>个人访问令牌（Personal Access Token，简称 PAT）</strong>。这个令牌需要有足够的权限来修改仓库。</p><p>点击右上角头像 -&gt; 打开 <strong>Settings</strong> -&gt; 左边栏滚到最后找到 <strong>Develop Setting</strong> 打开，如图</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409110537234.png" alt="image.png"></p><p>找到 <strong>Personal Access Token</strong> 点击 <strong>Tokens（classic）</strong> -&gt; 选择 <strong>Generate new token (classic)</strong> ，如图</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409110538977.png" alt="image.png"></p><p>然后随便新建一个好了，只要有读写仓库的权限就行。</p><p>将生成的 <strong>PAT</strong> 添加到你的博客源代码仓库的 <strong>Secrets</strong>，也就是我们部署GitHub Action的仓库，名字填入 <strong>PERSONAL_TOKEN</strong> ，后面会用到这个变量名。</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202409110540172.png" alt="image.png"></p><p>然后在我们存放Hexo配置的分支里面创建一个 .github/workflows 文件夹（如果尚未存在），然后新建一个yaml文件用于定义Github Action工作流。以下是我的yaml文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">run-name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><span class="hljs-attr">on:</span><br>    <span class="hljs-attr">push:</span><br>        <span class="hljs-attr">branches:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>    <span class="hljs-attr">deploy:</span><br>        <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>        <span class="hljs-attr">steps:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">hexo</span> <span class="hljs-string">branch</span> <span class="hljs-string">(Hexo</span> <span class="hljs-string">environment)</span><br>              <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>              <span class="hljs-attr">with:</span><br>                  <span class="hljs-attr">ref:</span> <span class="hljs-string">hexo</span><br>                  <span class="hljs-attr">path:</span> <span class="hljs-string">blog</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">articles</span> <span class="hljs-string">from</span> <span class="hljs-string">main</span> <span class="hljs-string">branch</span> <span class="hljs-string">(Blog</span> <span class="hljs-string">folder)</span><br>              <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>              <span class="hljs-attr">with:</span><br>                  <span class="hljs-attr">ref:</span> <span class="hljs-string">main</span><br>                  <span class="hljs-attr">path:</span> <span class="hljs-string">main-temp</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">if</span> <span class="hljs-string">Blog</span> <span class="hljs-string">folder</span> <span class="hljs-string">exists</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">ls</span> <span class="hljs-string">main-temp/Blog</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Move</span> <span class="hljs-string">articles</span> <span class="hljs-string">to</span> <span class="hljs-string">_posts</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">mv</span> <span class="hljs-string">main-temp/Blog/*</span> <span class="hljs-string">blog/source/_posts/</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span><br>              <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>              <span class="hljs-attr">with:</span><br>                  <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;16&#x27;</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">dependencies</span><br>              <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v3</span><br>              <span class="hljs-attr">with:</span><br>                  <span class="hljs-attr">path:</span> <span class="hljs-string">blog/node_modules</span><br>                  <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>                  <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">                      $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="hljs-string"></span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>              <span class="hljs-attr">working-directory:</span> <span class="hljs-string">./blog</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">CLI</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">-g</span> <span class="hljs-string">hexo-cli</span><br>              <span class="hljs-attr">working-directory:</span> <span class="hljs-string">./blog</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">static</span> <span class="hljs-string">pages</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br>              <span class="hljs-attr">working-directory:</span> <span class="hljs-string">./blog</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">List</span> <span class="hljs-string">generated</span> <span class="hljs-string">files</span><br>              <span class="hljs-attr">run:</span> <span class="hljs-string">ls</span> <span class="hljs-string">-R</span> <span class="hljs-string">./blog/public</span><br><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>              <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>              <span class="hljs-attr">with:</span><br>                  <span class="hljs-attr">personal_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.PERSONAL_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>                  <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./blog/public</span><br>                  <span class="hljs-attr">external_repository:</span> <span class="hljs-string">&lt;your</span> <span class="hljs-string">repo&gt;</span><br>                  <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>这里我的配置比较特殊，因为我对笔记文件进行了分类，然后只有Blog目录下的文件会进行发布，因此我们只需要看Blog目录是否发生改变。这个可以根据自己的需要进行修改。</p><p>然后我们将这些文件提交至GitHub上，触发特定条件就可以触发GitHub Action工作流实现自动部署</p>]]></content>
    
    
    
    <tags>
      
      <tag>#github</tag>
      
      <tag>#hexo</tag>
      
      <tag>#GitHubPages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++前向声明</title>
    <link href="/2024/09/06/C++%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E/"/>
    <url>/2024/09/06/C++%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>#前向声明 #Cpp</p><p><strong>前向声明（Forward Declaration）</strong> 是一种告诉编译器某个类型（如类、结构体或函数）存在的方式，而不提供该类型的完整定义。在前向声明中，我们只需要声明该类型的名称，但并不需要包含具体的定义细节。这对于减少编译依赖、提高编译速度有很大帮助。</p><h2 id="什么时候使用前向声明？"><a href="#什么时候使用前向声明？" class="headerlink" title="什么时候使用前向声明？"></a>什么时候使用前向声明？</h2><ol><li><strong>只声明指针或引用</strong>：如果你只需要在某个类或函数中使用指向某类型的指针或引用，而不需要访问其内部成员时，可以使用前向声明。</li><li><strong>减少编译依赖</strong>：前向声明能够减少不必要的头文件包含，使得代码模块之间的依赖关系更加简洁，从而减少编译时间和复杂度。</li></ol><p>举个例子，假设我们有一个 <code>Person</code> 结构体，他在这个<code>person.h</code>文件中有完整的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PERSON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PERSON_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>那比方说我们有一个类，需要使用到这个<code>Person</code>结构体。我们先不使用这个前向声明：</p><p><code>company.h</code>（不使用前向声明，直接包含 <code>person.h</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMPANY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMPANY_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span>  <span class="hljs-comment">// 直接包含 Person 的定义</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Company</span> &#123;<br>    std::string name;<br>    Person* employee;  <span class="hljs-comment">// 指向 Person 结构体的指针</span><br><br>    <span class="hljs-built_in">Company</span>(<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">employee</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hireEmployee</span><span class="hljs-params">(Person* employee)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printEmployeeInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>而这个<code>company.cpp</code>就应该是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;company.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Company::hireEmployee</span><span class="hljs-params">(Person* employee)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;employee = employee;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Company::printEmployeeInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (employee) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; employee-&gt;name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; employee-&gt;age &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No employee hired.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那如果我们使用了前向声明，那么这个<code>company.h</code>和<code>company.cpp</code>就应该是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMPANY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMPANY_H</span><br><br><span class="hljs-comment">// 前向声明 Person 结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Company</span> &#123;<br>    std::string name;<br>    Person* employee;  <span class="hljs-comment">// 指向 Person 结构体的指针</span><br><br>    <span class="hljs-built_in">Company</span>(<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">employee</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hireEmployee</span><span class="hljs-params">(Person* employee)</span></span>;  <span class="hljs-comment">// 使用指向 Person 的指针</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printEmployeeInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;company.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span>  <span class="hljs-comment">// 包含 Person 的完整定义</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Company::hireEmployee</span><span class="hljs-params">(Person* employee)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;employee = employee;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Company::printEmployeeInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (employee) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; employee-&gt;name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; employee-&gt;age &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No employee hired.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，虽然看上去没什么变化，但是他能够避免了直接包含 <code>person.h</code>，使得 <code>company.h</code> 更加简洁。不使用前向声明意味着 <code>company.h</code> 依赖于 <code>person.h</code>，如果 <code>person.h</code> 中有任何变化，所有包含 <code>company.h</code> 的文件都需要重新编译，这会增加编译时间和复杂度。同时前向声明也可以用来打破循环依赖，分解依赖关系。</p><p>C++项目的编写中其实有一个原则，就是最小化头文件依赖。即尽可能减少头文件中包含的其他头文件，以减少编译依赖，避免不必要的重编译。.h文件都应该尽量的让这个.c或者.cpp文件去包含而不是在头文件中直接包含。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#前向声明</tag>
      
      <tag>#Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx踩坑记录——location 路径匹配和 proxy_pass 转发行为的差异</title>
    <link href="/2024/09/06/Nginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94location%20%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E5%92%8C%20proxy_pass%20%E8%BD%AC%E5%8F%91%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <url>/2024/09/06/Nginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94location%20%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E5%92%8C%20proxy_pass%20%E8%BD%AC%E5%8F%91%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<p>#Nginx</p><p>文章的开始我们先来看几种写法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /b/ &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017/;<br>&#125;<br><span class="hljs-section">location</span> /b/ &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017;<br>&#125;<br><span class="hljs-section">location</span> /b &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017;<br>&#125;<br><span class="hljs-section">location</span> /b &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017/;<br>&#125;<br></code></pre></td></tr></table></figure><p>请你告诉我，这几种写法有什么区别</p><h2 id="location-b-和-location-b"><a href="#location-b-和-location-b" class="headerlink" title="location /b/ 和 location /b"></a><code>location /b/</code> 和 <code>location /b</code></h2><p>这两个东西看起来很像，但是其实区别有点大。</p><p>我们先来看<code>location /b/</code>。这个配置匹配的是以<code>/b/</code>开头的路径。例如，<code>/b/something</code> 或 <code>/b/subdir/file</code> 等等。重要的是，这种匹配要求路径紧跟在<code>/b/</code>后面，后面必须有<code>/</code>，而且<strong>不包括</strong><code>/b</code>。</p><p>而<code>location /b</code>这个配置匹配的是以<code>/b</code>开头的路径，既可以匹配<code>/b</code>本身，也可以匹配以<code>/b</code>开头的其他路径。例如，<code>/b</code>, <code>/b/something</code>, <code>/b/subdir/file</code> 都会被匹配。</p><h2 id="proxy-pass路径末尾有无"><a href="#proxy-pass路径末尾有无" class="headerlink" title="proxy_pass路径末尾有无/"></a>proxy_pass路径末尾有无/</h2><p>这两个是不一样的。</p><p>如果你在 <code>proxy_pass</code> 后面使用的是 <code>http://localhost:2017</code>，即没有带“/”，那么Nginx 会将客户端请求的 URI 直接转发到目标服务器，保持原始 URI 不变。例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /test/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:2017;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，由于 <code>proxy_pass</code> 没有加斜杠，Nginx 不会去掉匹配的 <code>/test/</code> 前缀部分，而是直接将原始请求完整地转发给目标服务器。所以，假设客户端请求 <code>example.com/test/abc</code>，那么 Nginx 会将请求转发为 <code>http://localhost:2017/test/abc</code>。</p><p>如果你在 <code>proxy_pass</code> 后面加上了斜杠 <code>http://localhost:2017/</code>，在 <code>proxy_pass</code> 后面加上斜杠时，Nginx 会去掉客户端请求的 URI 中和<strong>匹配位置</strong>相关的部分，并替换为目标服务器的根路径。这里的<strong>前缀部分</strong>是指在 Nginx 配置中与 <code>location</code> 指令匹配的那部分 URL。例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /test/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:2017/;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，客户端请求的 URI <code>/test/abc</code> 中，<code>/test/</code> 是匹配的前缀部分，而 Nginx 会将这一部分去掉，并把剩余的 <code>/abc</code> 转发给目标服务器。这时，Nginx 会将请求转发为 <code>http://localhost:2017/abc</code>，即<strong>去掉了匹配的前缀 <code>/test/</code>，并将剩余的部分加到目标服务器的根路径后</strong>。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /b/ &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017/;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>客户端请求</strong>: <code>http://example.com/b/abc</code></li><li><strong>Nginx 匹配的部分</strong>: <code>/b/</code></li><li><strong>剩余部分</strong>: <code>abc</code></li><li><strong>实际被转发的请求</strong>: <code>http://localhost:2017/abc</code></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /b/ &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>客户端请求</strong>: <code>http://example.com/b/abc</code></li><li><strong>Nginx 匹配的部分</strong>: <code>/b/</code></li><li><strong>剩余部分</strong>: <code>abc</code></li><li><strong>实际被转发的请求</strong>: <code>http://localhost:2017/b/abc</code></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /b &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>客户端请求</strong>: <code>http://example.com/b/abc</code></li><li><strong>Nginx 匹配的部分</strong>: <code>/b</code></li><li><strong>剩余部分</strong>: <code>/abc</code></li><li><strong>实际被转发的请求</strong>: <code>http://localhost:2017/b/abc</code></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /b &#123;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:2017/;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>客户端请求</strong>: <code>http://example.com/b/abc</code></li><li><strong>Nginx 匹配的部分</strong>: <code>/b</code></li><li><strong>剩余部分</strong>: <code>/abc</code></li><li><strong>实际被转发的请求</strong>: <code>http://localhost:2017/abc</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>#Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编译中变量重复定义问题</title>
    <link href="/2024/09/04/C++%E7%BC%96%E8%AF%91%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/04/C++%E7%BC%96%E8%AF%91%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#重复定义 #Cpp #extern关键字</p><p>C++编译过程中出现变量重复定义问题非常常见，通常表现为以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[build] CMakeFiles\NewPlayer.<span class="hljs-built_in">dir</span>/objects.a(imagehandler.cpp.obj):C:/Users/ZeroHzzzz/Desktop/QT_new/src/NewPlayer/imagehandler.h:197: multiple definition of `speedlineLeft<span class="hljs-string">&#x27;</span><br><span class="hljs-string">[build] CMakeFiles\NewPlayer.dir/objects.a(datahandler.cpp.obj):C:/Users/ZeroHzzzz/Desktop/QT_new/src/NewPlayer/imagehandler.h:197: first defined here</span><br></code></pre></td></tr></table></figure><p>出现这种报错通常分为以下几种情况：</p><h3 id="全局变量重复定义"><a href="#全局变量重复定义" class="headerlink" title="全局变量重复定义"></a>全局变量重复定义</h3><p>在多个源文件中定义了相同的全局变量，而没有使用<code>extern</code>关键字声明。这会导致链接器在合并目标文件时发现多个相同的符号定义。</p><h3 id="头文件中的直接定义变量"><a href="#头文件中的直接定义变量" class="headerlink" title="头文件中的直接定义变量"></a>头文件中的直接定义变量</h3><p>在C或C++中，<strong>不要直接在头文件（.h 文件）中定义全局变量</strong>，因为这样做会导致在多个文件中包含同一个头文件时出现多次定义的问题（即“重复定义”错误）</p><p>在头文件中直接定义了变量或函数，这些头文件被多个源文件包含。每次包含都会生成该变量或函数的一个定义，最终在链接时产生冲突。我们通常的做法是在头文件中声明一个变量但是不去定义他，然后再cpp文件中定义变量。</p><p>错误案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// myheader.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYHEADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYHEADER_H</span><br><br><span class="hljs-type">int</span> myVar;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYHEADER_H</span></span><br><br><span class="hljs-comment">// mysource.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> myVar = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 定义变量</span><br></code></pre></td></tr></table></figure><p>正确做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// myheader.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYHEADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYHEADER_H</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> myVar;  <span class="hljs-comment">// 仅声明，不定义</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYHEADER_H</span></span><br><br><span class="hljs-comment">// mysource.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-type">int</span> myVar = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 定义变量</span><br><br><span class="hljs-comment">// othersource.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVar</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;myVar: &quot;</span> &lt;&lt; myVar &lt;&lt; std::endl;  <span class="hljs-comment">// 使用变量</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>在头文件中定义了非静态的局部变量，如果这个头文件被多个源文件包含，也会导致重复定义问题。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="使用extern声明全局变量"><a href="#使用extern声明全局变量" class="headerlink" title="使用extern声明全局变量"></a>使用<code>extern</code>声明全局变量</h3><p>如果需要在多个文件中使用相同的全局变量，可以在一个源文件中定义变量，在其他源文件中使用<code>extern</code>关键字来声明。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 变量声明在header.h中</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;<br><br><span class="hljs-comment">// 变量定义在main.cpp中</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="头文件中使用inline或static关键字"><a href="#头文件中使用inline或static关键字" class="headerlink" title="头文件中使用inline或static关键字"></a>头文件中使用<code>inline</code>或<code>static</code>关键字</h3><p>如果头文件中有函数定义，可以使用<code>inline</code>关键字来避免重复定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// header.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 函数实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于需要在头文件中定义的局部变量，可以使用<code>static</code>关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// header.h</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> localVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="使用包含保护"><a href="#使用包含保护" class="headerlink" title="使用包含保护"></a>使用包含保护</h3><p>确保头文件有包含保护，防止同一个头文件被多次包含。可以通过<code>#ifndef</code>，<code>#define</code>，<code>#endif</code>来实现</p><p>[[C++编译中头文件重复包含问题]]</p><p>“包含保护”只是防止头文件被多次包含到<strong>同一个</strong>源文件中，它无法防止多个源文件中出现同样的变量定义</p><p>假设你在头文件中定义了一个全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// myheader.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYHEADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYHEADER_H</span><br><br><span class="hljs-type">int</span> myVar = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 在头文件中定义变量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYHEADER_H</span></span><br></code></pre></td></tr></table></figure><p>然后有两个源文件<code>a.cpp</code>和<code>b.cpp</code>都包含了这个头文件，当你编译时，<code>a.cpp</code>和<code>b.cpp</code>都会各自包含并定义<code>myVar</code>，这意味着编译器会看到两个不同的文件中都有一个全局变量<code>myVar</code>的定义，从而导致<strong>重复定义</strong>错误。正确的做法是<strong>在头文件中声明变量</strong>，而<strong>在某个源文件中定义变量</strong>。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>将全局变量放入命名空间内，可以减少不同文件中相同变量名的冲突：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// header.h</span><br><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-type">int</span> MyNamespace::globalVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#Cpp</tag>
      
      <tag>#重复定义</tag>
      
      <tag>#extern关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编译中头文件重复包含问题</title>
    <link href="/2024/09/01/C++%E7%BC%96%E8%AF%91%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/01/C++%E7%BC%96%E8%AF%91%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#Cpp #编译 #头文件保护</p><p>在C++开发过程中，重定义错误是一个常见的问题。如果存在一个头文件被多个文件引用，而头文件没有防重复包含保护的情况，就会引发重定义的问题，表现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[build] C:/Users/ZeroHzzzz/Desktop/QT/Player/image.h:106:7: error: redefinition of <span class="hljs-string">&#x27;class ImageHandler&#x27;</span><br>[build] class ImageHandler &#123; [build] ^~~~~~~~~~~~<br>[build] In file included from C:/Users/ZeroHzzzz/Desktop/QT/Player/datareader.h:3:0,<br>[build] from C:\Users\ZeroHzzzz\Desktop\QT\Player\mainwindow.h:4, [build] from C:\Users\ZeroHzzzz\Desktop\QT\Player\mainwindow.cpp:1:<br>[build] C:/Users/ZeroHzzzz/Desktop/QT/Player/image.h:106:7: note: previous definition of <span class="hljs-string">&#x27;class ImageHandler&#x27;</span><br>[build] class ImageHandler &#123;<br>[build] ^~~~~~~~~~~~<br>[build] In file included from C:/Users/ZeroHzzzz/Desktop/QT/Player/datareader.h:14:0,<br>[build] from C:\Users\ZeroHzzzz\Desktop\QT\Player\datareader.cpp:1:<br></code></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用预处理指令-ifndef、-define-和-endif"><a href="#使用预处理指令-ifndef、-define-和-endif" class="headerlink" title="使用预处理指令 #ifndef、#define 和 #endif"></a>使用预处理指令 <code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code></h3><p>在<code>image.h</code>头文件的开头和结尾添加如下的预处理指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// image.h 文件的开头</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> IMAGE_H    <span class="hljs-comment">// 检查是否定义了IMAGE_H宏</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_H    <span class="hljs-comment">// 定义IMAGE_H宏</span></span><br><br><span class="hljs-comment">// 类定义和其他代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageHandler</span> &#123;<br>    <span class="hljs-comment">// 类的成员和方法</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// IMAGE_H  // 结束条件编译</span></span><br></code></pre></td></tr></table></figure><p><code>#ifndef IMAGE_H</code>：检查是否已经定义了<code>IMAGE_H</code>宏，如果没有定义，则继续执行下面的代码。<br><code>#define IMAGE_H</code>：定义<code>IMAGE_H</code>宏，用于标记该头文件已经被包含。这确保了即使<code>image.h</code>被多次包含，<code>ImageHandler</code>类也只会被定义一次。<br><code>#endif</code>：结束条件编译</p><p><code>#ifndef</code>的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p><h3 id="使用-pragma-once"><a href="#使用-pragma-once" class="headerlink" title="使用 #pragma once"></a>使用 <code>#pragma once</code></h3><p>在<code>image.h</code>文件的开头添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-comment">// 类定义和其他代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageHandler</span> &#123;<br>    <span class="hljs-comment">// 类的成员和方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>#pragma once</code>是一种编译器指令，指示编译器只包含一次该头文件。它的效果与使用<code>#ifndef</code>/<code>#define</code>保护符相同，但写法更简洁。这种方法更易于维护，但需要注意的是，<code>#pragma once</code>不是所有编译器都支持的标准，因此在一些特定的编译环境中可能需要退回到传统的防护符号方法。</p><p><code>#pragma once</code>由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指<strong>物理</strong>上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。</p><p>但是：</p><p><strong>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</strong></p><p>其好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。</p><p>对应的缺点就是如果某个头文件有多份拷贝，这个方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。</p><p>因此，对于可移植性方面而言，我更倾向于使用<code>#ifndef</code>的方法</p><h2 id="检查包含关系"><a href="#检查包含关系" class="headerlink" title="检查包含关系"></a>检查包含关系</h2><p>头文件的包含关系也需要注意。循环包含会导致难以定位的问题，影响程序的可维护性。</p><h3 id="使用编译器的预处理选项查看包含树"><a href="#使用编译器的预处理选项查看包含树" class="headerlink" title="使用编译器的预处理选项查看包含树"></a>使用编译器的预处理选项查看包含树</h3><p>许多编译器提供了查看包含文件树的选项，可以帮助你理解头文件的包含关系。</p><p>例如<code>gcc</code>或<code>g++</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -H main.cpp -o main<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">. main.cpp<br>.. image.h<br>... other_header.h<br>.. another_header.h<br></code></pre></td></tr></table></figure><h3 id="使用-CMake-的include-what-you-use工具"><a href="#使用-CMake-的include-what-you-use工具" class="headerlink" title="使用 [[CMake]] 的include-what-you-use工具"></a>使用 [[CMake]] 的<code>include-what-you-use</code>工具</h3><p><code>include-what-you-use</code>（IWYU）是一个专门分析C/C++代码的工具，可以帮助检测和优化头文件的包含情况。IWYU可以生成详细的报告，指出哪些头文件是多余的，哪些头文件是缺失的。</p><p><strong>使用方法</strong>：</p><ol><li>安装<code>include-what-you-use</code>工具。</li><li>在CMake项目中，将<code>CMAKE_CXX_INCLUDE_WHAT_YOU_USE</code>设置为<code>iwyu</code>的路径。</li></ol><p>在CMakeLists.txt中添加：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_CXX_INCLUDE_WHAT_YOU_USE <span class="hljs-string">&quot;include-what-you-use&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后，运行CMake和构建系统，会自动生成包含分析的报告。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Cpp</tag>
      
      <tag>#编译</tag>
      
      <tag>#头文件保护</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境中利用MinGW+CMake从源码编译OpenCV</title>
    <link href="/2024/08/28/Windows%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%A9%E7%94%A8MinGW+CMake%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OpenCV/"/>
    <url>/2024/08/28/Windows%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%A9%E7%94%A8MinGW+CMake%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OpenCV/</url>
    
    <content type="html"><![CDATA[<p>#OpenCV #CMake配置 #MinGW</p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ul><li>检查 <code>MinGW</code> 的安装版本是否为 <code>posix</code> 线程标准，目前 <code>OpenCV</code> 只支持 <code>posix</code> 标准，不支持 <code>win32</code> 标准</li><li>安装Windows版本的 <code>Cmake</code>，官网链接为<a href="https://cmake.org/download/" title="https://cmake.org/download/">https://cmake.org/download/</a></li><li>编译之前记得使用<code>gcc -v</code>查看自己的编译器版本，别到时候出现一些不必要的<code>error</code> <del>（我不说是谁）</del></li></ul><h2 id="下载OpenCV源码"><a href="#下载OpenCV源码" class="headerlink" title="下载OpenCV源码"></a>下载OpenCV源码</h2><p><a href="https://opencv.org/releases/">Releases - OpenCV</a></p><h2 id="生成makefile"><a href="#生成makefile" class="headerlink" title="生成makefile"></a>生成makefile</h2><p>选择解压后的opencv源码路径与编译二进制文件的路径，一般就选择源码路径下的build文件夹（Cmake会提醒创建，也可以自己提前创建），点击<code>Configure</code><br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408290036458.png" alt="image.png"></p><p>选择MinGW Makefiles，如果对应的GNU编译器（包括gcc、g++、gfortran）已经在当前的环境变量PATH中，则可以选择默认的编译器，如下图所示；如果未添加进环境变量，可以选择<code>Specify native compilers</code>手动选择（不推荐，建议添加环境变量）</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408290036926.png" alt="image.png|700"></p><p>等待Configure完成后，出现需要更新的红色的配置值，可以根据自己的需要进行适当调整。常用的调整项目有：</p><p><strong>CMAKE_INSTALL_PREFIX</strong>：修改默认安装路径，默认安装路径为<code>build/install</code><br><strong>BUILD_opencv_world</strong>：将所有编译后的库文件整合为一个<br><strong>OPENCV_GENERATE_PKGCONFIG</strong>：生成一个pkg-config的路径使得pkgconfig能够自动传递库路径给g++进行编译<br><strong>CMAKE_BUILD_TYPE</strong>：填入Release会编译发行版本的opencv包，从而去除debug信息和符号表，这可以提高性能；填入Debug则会编译debug版本的opencv（这是给需要深度开发opencv修改源码的人用的），而一般我们不需要深入opencv的源代码进行debug。<br><strong>OPENCV_EXTRA_MODULES_PATH</strong>：contrib包中的附加模组的路径<br><strong>WITH_QT</strong>：字面意思<br><strong>WITH_OPENGL</strong>：利用硬件加速来提高图像和视频处理的性能<br><strong>ENABLE_PRECOMPILED_HEADERS</strong>：启用预编译头，加快编译速度<br><strong>QT5_DIR</strong>：填入QT路径<br>再次configure。如果无报错之后选择generate生成makefile</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在build文件夹中打开cmd或者终端或者其他类shell工具，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mingw32-make<br></code></pre></td></tr></table></figure><p>可以传入<code>-jx</code>使用多线程编译以加快编译速度，其中x为线程数。</p><p>编译完成后，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mingw32-make install<br></code></pre></td></tr></table></figure><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408290045293.png" alt="image.png"></p><p>成功安装动态库到对应路径(若没有修改则是默认路径)。</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>刚刚我们得到的文件是很多的，但是我们只需要留下build文件夹中的install目录即可，其他都是可以删掉的。</p><p>因此我最终的文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs tree">opencv-4.10.0/<br>├─etc<br>│  ├─haarcascades<br>│  ├─lbpcascades<br>│  └─licenses<br>├─include<br>│  └─opencv2<br>│      ├─calib3d<br>│      ├─core<br>│      │  ├─cuda<br>│      │  │  └─detail<br>│      │  ├─detail<br>│      │  ├─hal<br>│      │  ├─opencl<br>│      │  │  └─runtime<br>│      │  │      └─autogenerated<br>│      │  ├─parallel<br>│      │  │  └─backend<br>│      │  └─utils<br>│      ├─dnn<br>│      │  └─utils<br>│      ├─features2d<br>│      │  └─hal<br>│      ├─flann<br>│      ├─gapi<br>│      │  ├─cpu<br>│      │  ├─fluid<br>│      │  ├─gpu<br>│      │  ├─infer<br>│      │  ├─oak<br>│      │  ├─ocl<br>│      │  ├─own<br>│      │  ├─plaidml<br>│      │  ├─python<br>│      │  ├─render<br>│      │  ├─s11n<br>│      │  ├─streaming<br>│      │  │  ├─gstreamer<br>│      │  │  └─onevpl<br>│      │  └─util<br>│      ├─highgui<br>│      ├─imgcodecs<br>│      │  └─legacy<br>│      ├─imgproc<br>│      │  ├─detail<br>│      │  └─hal<br>│      ├─ml<br>│      ├─objdetect<br>│      ├─photo<br>│      │  └─legacy<br>│      ├─stitching<br>│      │  └─detail<br>│      ├─video<br>│      │  ├─detail<br>│      │  └─legacy<br>│      └─videoio<br>│          └─legacy<br>└─x64<br>    └─mingw<br>        ├─bin<br>        └─lib<br>            └─pkgconfig<br></code></pre></td></tr></table></figure><p>我们添加环境变量的时候只需要添加<code>x64/mingw/bin</code>就行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#OpenCV</tag>
      
      <tag>#CMake配置</tag>
      
      <tag>#MinGW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用qq邮箱群发邮件</title>
    <link href="/2024/08/21/%E4%BD%BF%E7%94%A8qq%E9%82%AE%E7%AE%B1%E7%BE%A4%E5%8F%91%E9%82%AE%E4%BB%B6/"/>
    <url>/2024/08/21/%E4%BD%BF%E7%94%A8qq%E9%82%AE%E7%AE%B1%E7%BE%A4%E5%8F%91%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>#SMTP</p><p>我们通过qq邮箱的[[SMTP]]服务来实现邮件的发送</p><h2 id="From-和-To-Header-格式规范"><a href="#From-和-To-Header-格式规范" class="headerlink" title="From 和 To Header 格式规范"></a>From 和 To Header 格式规范</h2><p>我们在使用qq邮箱发送邮件的时候出现了以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SMTPDataError: (550, b<span class="hljs-string">&#x27;The &quot;From&quot; header is missing or invalid. Please follow RFC5322, RFC2047, RFC822 standard protocol. https://service.mail.qq.com/detail/124/995.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这是因为其From合法性检查</p><h3 id="From合法性检查"><a href="#From合法性检查" class="headerlink" title="From合法性检查"></a>From合法性检查</h3><p><strong>一、根据RFC5322协议，邮件标头中需要包含’From’信息。</strong></p><p><strong>二、根据RFC2047, RFC822协议，邮件标头中的’From’形式为：</strong></p><ol><li><p>邮箱地址形式：prefix@domain, 如 ‘abc@qq.com’。</p></li><li><p>昵称+空格+&lt;邮箱地址&gt;形式：nickname <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x70;&#114;&#101;&#102;&#105;&#x78;&#x40;&#100;&#111;&#109;&#x61;&#105;&#x6e;">&#x70;&#114;&#101;&#102;&#105;&#x78;&#x40;&#100;&#111;&#109;&#x61;&#105;&#x6e;</a>，其中，nickname为ASCII字符集中字符组合或编码文本:</p></li></ol><p>（1）如果昵称全为ASCII字符，如’ABC’，邮箱地址为 ‘abc@qq.com’，则标头中的’From’为’ABC <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x61;&#x62;&#x63;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x61;&#x62;&#x63;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a>‘。注意’ABC’和’<a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x61;&#x62;&#x63;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x61;&#x62;&#x63;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a>‘之间用空格隔开；</p><p>（2）如果昵称包含非ASCII字符，如中文，则请使用base64对昵称进行编码。nickname最终的形式为：”=?” charset “?” encoding “?” encoded-text “?=”。其中，charset为字符集；encoding为编码方式，’B’代表base64；encoded-text为编码后的文本。例如，昵称为’QQ邮箱昵称示例’，邮箱地址为 ‘abc@qq.com’，则对昵称进行base64编码，字符集使用UTF-8，则nickname为 ‘=?UTF-8?B?UVHpgq7nrrHmmLXnp7DnpLrkvos=?=’，最终邮件标头中的’From’为’”=?utf-8?B?UVHpgq7nrrHmmLXnp7DnpLrkvos=?=” <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#97;&#x62;&#99;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#97;&#x62;&#99;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;</a>‘。注意编码文本和邮件地址间用空格隔开。</p><h2 id="发送邮箱服务器端口"><a href="#发送邮箱服务器端口" class="headerlink" title="发送邮箱服务器端口"></a>发送邮箱服务器端口</h2><p>发送邮件服务器要用465端口，否则如下的报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SMTPServerDisconnected: Connection unexpectedly closed<br></code></pre></td></tr></table></figure><h2 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h2><p>login的密码不是邮箱登录密码，而是授权码，需要在QQ邮箱设置-账号里获取。否则会出现以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SSLError: [SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1002)<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最终我们的代码如下（无附件）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><br>sender = <span class="hljs-string">&#x27;&#x27;</span><br>receivers = [<span class="hljs-string">&#x27;&#x27;</span>]<br>auth_code = <span class="hljs-string">&quot;&quot;</span><br>fails = []<br><br>Sendernickname = <span class="hljs-string">&quot;=?UTF-8?B?5rWZ5rGf5bel5Lia5aSn5a2m57K+5byY572R57uc?=&quot;</span><br>text = <span class="hljs-string">&quot;你好！&quot;</span><br>message = MIMEText(text, <span class="hljs-string">&#x27;plain&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>message[<span class="hljs-string">&#x27;From&#x27;</span>] = Header(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;Sendernickname&#125;</span>&lt;<span class="hljs-subst">&#123;sender&#125;</span>&gt;&quot;</span>)<br>subject = <span class="hljs-string">&#x27;报名成功通知&#x27;</span><br>message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(subject, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Begin to send message...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;共 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(receivers)&#125;</span> 名参赛者&#x27;</span>)<br><br><span class="hljs-keyword">for</span> receiver <span class="hljs-keyword">in</span> tqdm(receivers):<br>    message[<span class="hljs-string">&#x27;To&#x27;</span>] = Header(<span class="hljs-string">f&quot;Receiver&lt;<span class="hljs-subst">&#123;receiver&#125;</span>&gt;&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        server = smtplib.SMTP_SSL(<span class="hljs-string">&#x27;smtp.qq.com&#x27;</span>, <span class="hljs-number">465</span>)<br>        server.login(sender, auth_code)<br>        server.sendmail(sender, receivers, message.as_string())<br>        server.close()<br>       <br>    <span class="hljs-keyword">except</span> smtplib.SMTPException <span class="hljs-keyword">as</span> e:<br>        fails.append(receiver)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Error: 无法发送邮件，失败邮箱为：<span class="hljs-subst">&#123;receiver&#125;</span> ，失败原因为： <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;End to send message...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;发送失败 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(fails)&#125;</span> 封, 为 <span class="hljs-subst">&#123;fails&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果需要附件，可尝试以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">import</span> email.utils<br><span class="hljs-keyword">from</span> email.mime.application <span class="hljs-keyword">import</span> MIMEApplication<br><span class="hljs-keyword">from</span> email.mime.multipart <span class="hljs-keyword">import</span> MIMEMultipart<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">filename</span>):<br><br>    sender = <span class="hljs-string">&#x27;xxxxx@qq.com&#x27;</span>  <span class="hljs-comment"># 发送邮箱</span><br>    receivers = [<span class="hljs-string">&#x27;xx@xx.com&#x27;</span>]  <span class="hljs-comment"># 接收邮箱</span><br>    auth_code = <span class="hljs-string">&quot;auth code&quot;</span>  <span class="hljs-comment"># 授权码</span><br><br>    message = MIMEMultipart()<br>    message[<span class="hljs-string">&#x27;From&#x27;</span>] = email.utils.formataddr((<span class="hljs-string">&#x27;发送者&#x27;</span>, sender))  <span class="hljs-comment"># 发送者</span><br>    message[<span class="hljs-string">&#x27;To&#x27;</span>] = email.utils.formataddr((<span class="hljs-string">&#x27;收件人&#x27;</span>, receivers[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># 接收者</span><br><br>    message[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    content = MIMEText(filename)<br>    message.attach(content)<br><br>    <span class="hljs-comment"># 附件</span><br>    excel = MIMEApplication(<span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>).read())  <span class="hljs-comment"># 打开Excel,读取Excel文件</span><br>    excel[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span>  <span class="hljs-comment"># 设置内容类型</span><br>    excel.add_header(<span class="hljs-string">&#x27;Content-Disposition&#x27;</span>, <span class="hljs-string">&#x27;attachment&#x27;</span>, filename=filename)<br>    message.attach(excel)<br><br>    <span class="hljs-keyword">try</span>:<br>        server = smtplib.SMTP_SSL(<span class="hljs-string">&#x27;smtp.qq.com&#x27;</span>, <span class="hljs-number">465</span>)<br>        server.login(sender, auth_code)<br>        server.sendmail(sender, receivers, message.as_string())<br>        server.set_debuglevel(<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;邮件发送成功&quot;</span>)<br>        server.close()<br>    <span class="hljs-keyword">except</span> smtplib.SMTPException:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: 无法发送邮件&quot;</span>)<br></code></pre></td></tr></table></figure><p>项目地址：<a href="https://github.com/ZeroHzzzz/Email-Autosender?tab=readme-ov-file">ZeroHzzzz/Email-Autosender (github.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>#SMTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>steam家庭共享游戏消失问题</title>
    <link href="/2024/08/20/steam%E5%AE%B6%E5%BA%AD%E5%85%B1%E4%BA%AB%E6%B8%B8%E6%88%8F%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/20/steam%E5%AE%B6%E5%BA%AD%E5%85%B1%E4%BA%AB%E6%B8%B8%E6%88%8F%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#steam #黑神话悟空</p><p>最近买了黑神话悟空，但是我的两个儿子并没有在库中发现这个游戏，可是我们在商店页面发现这款游戏是支持家庭共享的，因此我们进行了求医问药。</p><p>最终的解决方法为：</p><p><strong>拥有游戏本体玩家，把游戏设置为私密在解开</strong></p><p>亲测有效。</p><p>剩下的几个方法没有尝试过，我们也没办法复现这个问题，因此不能确定其正确性，这这里一并贴出：</p><ul><li>自己在共有的游戏库更改游戏偏好选项（需要多人同时购买同一款游戏，才会出现偏好选项）</li><li>切换家庭库版本或更新steam。</li></ul><p>PS：游戏下好不能同时游玩，出现锁库现象的，可以试试让第一个登录的玩家，使用离线模式，后面人在使用在线模式(省事的话可以都采用离线模式)</p>]]></content>
    
    
    
    <tags>
      
      <tag>#steam</tag>
      
      <tag>#黑神话悟空</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx代理转发请求方法改变问题</title>
    <link href="/2024/08/19/Nginx%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%94%B9%E5%8F%98%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/19/Nginx%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%94%B9%E5%8F%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#Nginx重定向 #HTTP状态码</p><p>nginx的机制是所有转发默认是get，所以会导致post请求经过nginx转发后会被转化为get请求。</p><p>首先我们来了解一下几个[[HTTP#HTTP 状态码|http状态码]]的区别</p><h3 id="301-Moved-Permanently（永久重定向）"><a href="#301-Moved-Permanently（永久重定向）" class="headerlink" title="301 Moved Permanently（永久重定向）"></a>301 Moved Permanently（永久重定向）</h3><ul><li><strong>含义</strong>：表示请求的资源已被永久移动到新的 URL 上，客户端应使用新的 URL 进行访问。</li><li><strong>特点</strong>：浏览器或搜索引擎通常会缓存 301 重定向，后续访问时会自动使用新的 URL。</li><li><strong>请求方法</strong>：请求方法（如 GET 或 POST）可能会被更改为 GET。</li></ul><h3 id="302-Found（临时重定向）"><a href="#302-Found（临时重定向）" class="headerlink" title="302 Found（临时重定向）"></a>302 Found（临时重定向）</h3><ul><li><strong>含义</strong>：表示请求的资源临时被移动到新的 URL 上，但将来可能会返回到原来的 URL。</li><li><strong>特点</strong>：浏览器不会缓存 302 重定向，每次访问时都会重新请求原 URL。</li><li><strong>请求方法</strong>：请求方法可能会被更改为 GET，尤其是在表单提交时。</li></ul><h3 id="307-Temporary-Redirect（临时重定向）"><a href="#307-Temporary-Redirect（临时重定向）" class="headerlink" title="307 Temporary Redirect（临时重定向）"></a>307 Temporary Redirect（临时重定向）</h3><ul><li><strong>含义</strong>：与 302 类似，表示请求的资源临时被移动，但它严格要求客户端使用原始的请求方法进行重定向。</li><li><strong>特点</strong>：浏览器不会缓存 307 重定向，且保证在重定向时不会更改请求方法（例如，POST 仍然会使用 POST）。</li><li><strong>请求方法</strong>：请求方法不会改变，客户端会以原始请求方法进行重定向。</li></ul><h3 id="308-Permanent-Redirect（永久重定向）"><a href="#308-Permanent-Redirect（永久重定向）" class="headerlink" title="308 Permanent Redirect（永久重定向）"></a>308 Permanent Redirect（永久重定向）</h3><ul><li><strong>含义</strong>：与 301 类似，表示请求的资源已被永久移动到新的 URL。</li><li><strong>特点</strong>：浏览器或搜索引擎会缓存 308 重定向。</li><li><strong>请求方法</strong>：与 307 类似，308 要求请求方法不变，客户端会使用原始请求方法进行重定向。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>301</strong> 和 <strong>308</strong> 都表示永久重定向，但 301 可能会更改请求方法，而 308 则不会。</li><li><strong>302</strong> 和 <strong>307</strong> 都表示临时重定向，但 302 可能会更改请求方法，而 307 则不会。</li></ul><p>因此我们可以通过原样转发解决这个问题。也就是通过保留请求方法的重定向方式转发。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> test.<span class="hljs-number">123</span>.com;<br><span class="hljs-section">location</span> /test/api &#123;<br><span class="hljs-attribute">return</span> <span class="hljs-number">307</span> http://192.168.1.133:8088/api;<br><span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而当我们要根据请求类型来过滤按照请求类型转发到指定的地址时可以用以下方式来实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> test123 &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.133:8888</span> max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30s</span>;<br><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span> test.<span class="hljs-number">123</span>.com;<br><span class="hljs-section">location</span> /api/bbb &#123;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = POST) &#123;<br><span class="hljs-attribute">return</span> <span class="hljs-number">307</span> http://192.168.1.133:8088/aaa/bbb;<br>&#125;<br><span class="hljs-attribute">proxy_pass</span> http://test123;<br><span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，当我们使用get请求<code>http://test.123.com/api/bbb</code>这个地址时请求不会被转发，而当我们使用post请求<code>http://test.123.com/api/bbb</code>这个地址时请求会被转发到<code>http://192.168.1.133:8088/aaa/bbb</code>这个地址</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Nginx重定向</tag>
      
      <tag>#HTTP状态码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OMP Error 15问题解决</title>
    <link href="/2024/08/15/OMP%20Error%2015%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/08/15/OMP%20Error%2015%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>#OpenMP多线程</p><p>OMP 是 “OpenMP” 的缩写，全称为 “Open Multi-Processing”。它是一种用于多线程并行编程的 API，主要用于 C、C++ 和 Fortran 语言。OpenMP 提供了一组编译指令、函数和环境变量，使开发者能够更容易地在多核处理器上编写并行代码。通过在代码中插入 OpenMP 指令，开发者可以控制如何在多个线程之间分配工作负载，从而加速计算任务。OpenMP 常用于科学计算、工程模拟等需要高性能计算的领域。</p><p>目前遇到以下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs log">OMP: Error \#15: Initializing libomp140.x86_64.dll, but found libiomp5md.dll already initialized.<br>OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, but that may cause crashes or silently produce incorrect results. For more information, please see http://openmp.llvm.org/<br></code></pre></td></tr></table></figure><p>以及：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs log">OMP: Error \#15: Initializing libomp140.x86_64.dll, but found libomp140.x86_64.dll already initialized.<br>OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, but that may cause crashes or silently produce incorrect results. For more information, please see http://openmp.llvm.org/<br></code></pre></td></tr></table></figure><p>目前解决方法为：<br>在代码中加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;KMP_DUPLICATE_LIB_OK&quot;</span>]=<span class="hljs-string">&quot;TRUE&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#OpenMP多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-magic导入报错问题</title>
    <link href="/2024/08/15/python-magic%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/15/python-magic%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#Langchain #libmagic<br>在使用Langchain中的DirectLoader加载PDF文件时，我们遇到了以下问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Import Error:<br>failed to find libmagic. Check your installation<br><br>File <span class="hljs-string">&quot;C:\Users\ZeroHzzzz\Desktop\Jarvis\Docbot\create_index.py&quot;</span>, line 12, <span class="hljs-keyword">in</span> &lt;module&gt; document = loader.load() ImportError: failed to find libmagic. Check your installation<br></code></pre></td></tr></table></figure><p>通过查询，我们发现这个问题源于程序在调用<code>magic</code>模块时出现了<code>ImportError</code>，其原因是缺少<code>libmagic</code>共享库。<code>magic</code>库主要用于识别文件类型，它通过读取文件的“魔术数字”（Magic Number）来推断文件的格式。魔术数字是文件开头的一些字节，可以标识文件类型，例如图片、压缩文件、可执行文件等。Langchain可能正是利用这个库来判断文件类型。</p><p>要解决这个问题，可以安装以下库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pylibmagic<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#Langchain</tag>
      
      <tag>#libmagic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch fbgemm.dll依赖问题</title>
    <link href="/2024/08/15/Pytorch%20fbgemm.dll%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/15/Pytorch%20fbgemm.dll%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#PyTorch #DLL #fbegmm</p><p>今天在安装pytorch的时候出现了以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[WinError 126] 找不到指定的模块。 Error loading <span class="hljs-string">&quot;c:\Users\ZeroHzzzz\miniconda3\envs\test\lib\site-packages\torch\lib\fbgemm.dll&quot;</span> or one of its dependencies.<br><br>File <span class="hljs-string">&quot;C:\Users\ZeroHzzzz\Desktop\Jarvis\Docbot\model.py&quot;</span>, line 1, <span class="hljs-keyword">in</span> &lt;module&gt; from transformers import AutoModelForSequenceClassification, AutoTokenizer, AutoModel File <span class="hljs-string">&quot;C:\Users\ZeroHzzzz\Desktop\Jarvis\Docbot\create_index.py&quot;</span>, line 3, <span class="hljs-keyword">in</span> &lt;module&gt; from model import EmbeddingModel OSError: [WinError 126] 找不到指定的模块。 Error loading <span class="hljs-string">&quot;c:\Users\ZeroHzzzz\miniconda3\envs\test\lib\site-packages\torch\lib\fbgemm.dll&quot;</span> or one of its dependencies.<br></code></pre></td></tr></table></figure><p>但是我们到指定路径下检查后，发现这个<code>dll</code>实际上是存在的，那么根据报错信息，就是这个<code>dll</code>缺少了某个依赖。因此我们借助<a href="https://github.com/lucasg/Dependencies/releases/tag/v1.11.1">依赖分析工具</a>来解决这个问题。</p><p>启动后，打开<code>fbegmm.dll</code><br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408260016559.png" alt="image.png"></p><p>我们发现，<code>libomp140</code>这个依赖是缺失的，那么我们就去下载这个<code>dll</code></p><p><a href="https://www.dllme.com/dll/files/libomp140_x86_64/037e19ea9ef9df624ddd817c6801014e/download">libomp140.x86_64.dll : Free .DLL download. (dllme.com)</a></p><p>将下载的<code>libomp140.dll</code>放入Pytorch的<code>lib</code>目录下。因为我们看到类似的<code>asmjit.dll</code>也在该目录下，因此将新的依赖文件放在同一目录下可以确保Pytorch能够找到并正确加载。</p><p>至此，问题得到了解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#PyTorch</tag>
      
      <tag>#DLL</tag>
      
      <tag>#fbegmm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CV-PIL-Read-Photos</title>
    <link href="/2024/08/05/CV-PIL-Read-Photos/"/>
    <url>/2024/08/05/CV-PIL-Read-Photos/</url>
    
    <content type="html"><![CDATA[<p>#OpenCV #pillow #python</p><p>Python 中，常用的图像处理库包括 OpenCV 和 PIL（Python Imaging Library）。但是两者读取图片有些区别，因而产生一些坑点。</p><p>首先我们来看一个代码，使用 OpenCV 和 PIL 读取图像，并将其转换为 PyTorch 的 Tensor 格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-comment"># 图像路径</span><br>path = <span class="hljs-string">&#x27;./archive/imagesTr/CHNCXR_0640_1.png&#x27;</span><br><br><span class="hljs-comment"># 定义数据转换</span><br>data_transforms = &#123;<br>    <span class="hljs-string">&quot;train&quot;</span>: transforms.Compose([<br>        transforms.ToTensor()<br>    ]),<br>    <span class="hljs-string">&quot;test&quot;</span>: transforms.Compose([<br>        transforms.ToTensor()<br>    ])<br>&#125;<br><br><span class="hljs-comment"># 使用 OpenCV 读取图像</span><br>img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)<br><span class="hljs-built_in">print</span>(img.shape)<br>img = data_transforms[<span class="hljs-string">&quot;test&quot;</span>](img)<br><span class="hljs-built_in">print</span>(img.shape)<br><br><span class="hljs-comment"># 使用 PIL 读取图像</span><br>label = Image.<span class="hljs-built_in">open</span>(path).convert(<span class="hljs-string">&quot;L&quot;</span>)<br>label = data_transforms[<span class="hljs-string">&quot;test&quot;</span>](label)<br><span class="hljs-built_in">print</span>(label.shape)<br></code></pre></td></tr></table></figure><p>上面这个代码干了一下几件事：</p><p><strong>OpenCV 读取图像</strong><br>在上述代码中，<code>cv2.imread()</code> 用于读取图像。我们指定了 <code>cv2.IMREAD_GRAYSCALE</code> 参数，这意味着图像将被读取为灰度图像。读取的图像将以 NumPy 数组的形式返回，数组的形状可以通过 <code>img.shape</code> 获取。</p><p><strong>PIL 读取图像</strong><br>使用 <code>Image.open()</code> 函数可以通过 PIL 读取图像。为了与 OpenCV 的灰度读取保持一致，我们使用 <code>convert(&quot;L&quot;)</code> 将图像转换为灰度模式。PIL 读取的图像以 PIL Image 对象的形式返回。</p><p><strong>转换为 PyTorch Tensor</strong><br>无论是使用 OpenCV 还是 PIL 读取图像，我们最终都希望将图像转换为 PyTorch 的 Tensor 格式，以便输入到神经网络中。为此，我们使用了 torchvision 提供的 <code>transforms.ToTensor()</code> 转换。</p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><h3 id="OpenCV-和-PIL-读取图像的格式差异"><a href="#OpenCV-和-PIL-读取图像的格式差异" class="headerlink" title="OpenCV 和 PIL 读取图像的格式差异"></a>OpenCV 和 PIL 读取图像的格式差异</h3><p>一个显而易见的差异是 OpenCV 和 PIL 在读取图像时使用的默认格式不同。OpenCV 默认读取图像为 BGR 格式，而 PIL 默认使用 RGB 格式。这在处理彩色图像时尤为重要，因为如果不注意这一点，可能会导致颜色通道的错误匹配。虽然在本示例中，我们读取的是灰度图像，因此这一点并不会引发问题，但在彩色图像处理中需要格外小心。</p><h3 id="数据类型和范围的差异"><a href="#数据类型和范围的差异" class="headerlink" title="数据类型和范围的差异"></a>数据类型和范围的差异</h3><p>OpenCV 读取的图像是以 NumPy 数组的形式存在，数据类型通常为 <code>uint8</code>，值范围是 [0, 255]。而使用 <code>transforms.ToTensor()</code> 进行转换时，NumPy 数组会被转换为一个浮点数 Tensor，值的范围是 [0, 1]。</p><p>相比之下，PIL 读取图像后使用 <code>transforms.ToTensor()</code> 转换时，PIL Image 对象中的每个像素值同样会被归一化到 [0, 1] 范围内。</p><p>这种差异在处理和显示图像时可能会产生问题。例如，如果你在使用 OpenCV 读取图像并进行某些操作后，再用 PIL 显示图像，可能会看到意想不到的结果，因为数值范围的差异可能导致图像亮度和对比度异常。</p><h3 id="数据形状的差异"><a href="#数据形状的差异" class="headerlink" title="数据形状的差异"></a>数据形状的差异</h3><p>当使用 OpenCV 读取灰度图像时，返回的 NumPy 数组是一个二维数组，形状为 <code>(height, width)</code>。而使用 PIL 读取灰度图像并进行 Tensor 转换后，返回的是一个三维 Tensor，形状为 <code>(1, height, width)</code>，即多了一个颜色通道维度。这是因为 PyTorch 中的 Tensor 通常期望有一个明确的通道维度，无论图像是彩色还是灰度。</p><p>这意味着在使用 OpenCV 读取灰度图像并转换为 Tensor 时，我们可能需要手动添加一个通道维度，以使其与 PIL 的输出保持一致。可以使用以下代码进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = img[..., <span class="hljs-literal">None</span>]  <span class="hljs-comment"># 增加一个维度</span><br>img = data_transforms[<span class="hljs-string">&quot;test&quot;</span>](img)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#OpenCV</tag>
      
      <tag>#pillow</tag>
      
      <tag>#python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加图片方式记录</title>
    <link href="/2024/08/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#hexo</p><h2 id="Update-2024-05-02"><a href="#Update-2024-05-02" class="headerlink" title="Update 2024.05.02:"></a>Update 2024.05.02:</h2><p>最近期中考完也是化悲愤为力量把一些陈年老bug修了<br>之前提到的图片引用问题得到了解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-marked --save<br></code></pre></td></tr></table></figure><p>此处的save参数是为了npm的局部安装，因为我们大概率在其他地方不用安装这玩意<br>安装了这东西之后，我们在_config..yml中将下面几个东西修改一下。如果没有就加上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>    <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>然后就可以通过正常的markdown语法在资源文件夹中引用图片了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">！[<span class="hljs-string">Description</span>](<span class="hljs-link">path</span>) //注意这里的path是相对于资源文件夹的path<br></code></pre></td></tr></table></figure><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写文章的时候我们常常会使用图片来传达一些只可意会不可言传的含义….因此需要图片</p><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<br>路径：source/images/image.jpg<br><code>![](/images/image.jpg)</code></p><p>这样图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p><p>在根目录的_config.yml中：</p><p><code>post_asset_folder: true</code><br>但是据我惨痛的经历显示，下面这种写法是错误的:<br><code>![photo](passage_name/Photo.png)</code><br>因此我翻阅了hexo的<a href="https://hexo.io/zh-cn/docs/">文档</a>，里面是这么写的</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281843451.png" alt="1.png"></p><p>但是不知道为啥这个艾斯比东西就是没有用….</p><p>因此我还是只能采用官方推荐的这种写法：<br><code>&#123;% asset_img example.jpg failed_description %&#125;</code></p><p>事后经过一翻谷歌搜索发现用md直接导入图片导致失败的原因可能是因为只是将图片放入文件夹，hexo生成静态界面时并没有处理该图片，所以运行后就找不到图片了….<br>给我整无语了。但是我发现他文件路径是这样的:<br><code>https://zerohzzzz.github.io/[passage_name]/1.png</code><br>而用<code>&#123;% %&#125;</code>方式导入图片，图片的路径是这样的：<br><code>https://zerohzzzz.github.io/2023/10/27/[passage_name]/1.png</code></p><p>但是这个问题似乎在插件的新版本中得到了解决，有兴趣可以看看<a href="https://github.com/boboidream/hexo-easy-images">hexo-easy-images</a>，但我认为有<code>&#123;% %&#125;</code>方式就已经足够了</p><h2 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h2><p><a href="http://codecook.site/2020/12/05/hexo+typora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">hexo+typora的图片路径问题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>#hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu LTS 22.04 libssl 1.1问题记录</title>
    <link href="/2024/08/05/Ubuntu%20LTS%2022.04%20libssl%201.1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/05/Ubuntu%20LTS%2022.04%20libssl%201.1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu #libssl</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="hljs-attribute">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="hljs-attribute">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="hljs-attribute">下列信息可能会对解决问题有所帮助：</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">下列软件包有未满足的依赖关系：</span><br><span class="hljs-attribute"> erlang-crypto</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">依赖: libssl1.1 (&gt;= 1.1.1) 但无法安装它</span><br><span class="hljs-attribute">E</span><span class="hljs-punctuation">:</span> <span class="hljs-string">无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br><br>这几天尝试在ubuntu服务器上安装RabbitMQ的时候出现了以上问题，对此.....<br></code></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>经过查询资料可知，ubuntu LTS22.04 软件源中，并不包含libssl</p><p>因此，只能手动下载安装。<a href="http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/">http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.<span class="hljs-number">1</span>-udeb_1.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>ubuntu2.<span class="hljs-number">1</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.<span class="hljs-number">23</span>_amd64.udeb<br><br><span class="hljs-attribute">sudo</span> dpkg -i libssl1.<span class="hljs-number">1</span>-udeb_1.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>ubuntu2.<span class="hljs-number">1</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.<span class="hljs-number">23</span>_amd64.udeb<br></code></pre></td></tr></table></figure><p>问题就解决了</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Ubuntu</tag>
      
      <tag>#libssl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu上使用Todesk</title>
    <link href="/2024/08/05/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Todesk/"/>
    <url>/2024/08/05/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Todesk/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu #Todesk</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参照：<a href="https://www.todesk.com/linux.html">https://www.todesk.com/linux.html</a><br>官方文档上说：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> apt-<span class="hljs-meta">get</span> install ./todesk-<span class="hljs-built_in">v4</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-amd64.deb<br></code></pre></td></tr></table></figure><p>但是我试了没用（），由于我要用的是远程的ubuntu服务器，因此只能老老实实下载deb包然后通过scp传到服务器上。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动命令为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">todesk</span><br></code></pre></td></tr></table></figure><p>但是你都作为服务端了，你要gui界面你有看不到，因此只需要保持todeskd.service运行就行了。</p><p>但是我们显然看不到服务端的设备代码和临时密码，秉持着linux数据皆文件的原则，我们找到了他的配置文件，位于：/opt/todesk/config/config.ini</p><p>查看config.ini</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/todesk/config<br><span class="hljs-built_in">cat</span> config.ini<br></code></pre></td></tr></table></figure><p>可以看到：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[configinfo]</span><br><span class="hljs-attr">passupdate</span>                     = <span class="hljs-number">3</span><br><span class="hljs-attr">screen_img</span>                     =<br><span class="hljs-attr">clientid</span>                       = ********(这里只是我人为的加密)<br><span class="hljs-attr">privatedata</span>                    = ea51f22264b6913deb2b29e925788531500fd14c303ac881eb8bf2104632d95c969ecc074f67273fd5eda82971dc56e5ca9cc57467ae6c4b83<br><span class="hljs-attr">updatepasstime</span>                 = <span class="hljs-number">20240220</span><br><br></code></pre></td></tr></table></figure><p>此时并没有tempauthpassex 字段。我们通过我们windows端的todesk的配置文件可以看到:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ConfigInfo]</span><br><span class="hljs-attr">passUpdate</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">PrivateScreenLockScreen</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">autoLockScreen</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">downloadtimes</span>=<span class="hljs-number">202309040</span><br><span class="hljs-attr">clientId</span>=********<br><span class="hljs-attr">PrivateData</span>=<span class="hljs-number">98</span>f13012367f8fa56c7b71bce229e7f6fd1d8275b1340122e53293861dc6256651992beeaac16e61a4b5fad7ba2d0d04f7fd75003e78d12651<br><span class="hljs-attr">PluginExpiresDays</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Resolution</span>=<span class="hljs-number">2560</span>x1600<br><span class="hljs-attr">tempAuthPassEx</span>=f2c33773c4e07102cd9b30f1e762842b78a13df40e45bb730cd938953cc078a9d174a5b6ee1ad50b13ebb65a4de17f7e917a40969a966d0f<br><span class="hljs-attr">updatePassTime</span>=<span class="hljs-number">20230904</span><br><span class="hljs-attr">isOpenTempPass</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">language</span>=<span class="hljs-number">936</span><br><span class="hljs-attr">isAdmissionControl</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">WeakPasswordTip</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Version</span>=<span class="hljs-number">4.7</span>.<span class="hljs-number">0.4</span><br><span class="hljs-attr">isUpdate</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">PresetDialogUpdateDate</span>=<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-<span class="hljs-number">20</span><br><span class="hljs-attr">PresetDialogShowCount</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">NewToken</span>=<br><span class="hljs-attr">Token</span>=cb3c958a5d8d8f79e7d3561495b25987<br><span class="hljs-attr">LoginType</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">user</span>=<br><span class="hljs-attr">LoginPhone</span>=<span class="hljs-number">15918991630</span><br><span class="hljs-attr">LoginEmail</span>=<br><span class="hljs-attr">AreaCode</span>=<span class="hljs-number">86</span><br><span class="hljs-attr">UpdateFrequencyPromptBubble</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">UpdateTempPassDefault</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">LastPushTimeEx</span>=<span class="hljs-number">20240220</span><br><span class="hljs-attr">ShowToolbarGuide</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">IsFirstTimeConnect</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">MouseLeaveTip</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">autoLogin</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">AuthMode</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">minsizelock</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">loginlock</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">passex</span>=<span class="hljs-number">8534</span>b3464a478963712d4a727bc9f34ddbe1b59cc1611fa58ec36c741823b03fa7a59cc821dab0cb617c26a737a6179c<br><span class="hljs-attr">RoundBallXPos</span>=<span class="hljs-number">167</span><br><span class="hljs-attr">RoundBallYPos</span>=<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>对比我们ui界面中的临时密码和设备码，可以确定，clientId就是设备代码，而tempAuthPassEx是通过加密后的临时密码</p><p>那么我们就可以通过我们现在已知的临时密码来获取他的加密，并且添加到服务端的配置文件中，这样一来，服务端的密码就已知了，就可以进行连接了。连接之前记得重启todeskd.service和查看其状态来确定其工作是否正常</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Ubuntu</tag>
      
      <tag>#Todesk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu掉盘问题记录</title>
    <link href="/2024/08/05/Ubuntu%E6%8E%89%E7%9B%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/05/Ubuntu%E6%8E%89%E7%9B%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu</p><p>最近属实是有点太压抑了，于是斥巨资买下了HOGWARTS，然后在下载的时候发现游戏盘掉了，表现为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> &quot;xxx&quot;, an operation <span class="hljs-keyword">is</span> pending<br></code></pre></td></tr></table></figure><p>找了一下，原因是上一次拔硬盘的时候没有安全退出</p><p>【解决方法】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> fdisk -l<br></code></pre></td></tr></table></figure><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281844254.png" alt="image.png"></p><p>最后的设备/dev/sda1就是出问题的磁盘，于是我们需要修复挂载错误的相应分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ntfsfix /dev/sda1<br></code></pre></td></tr></table></figure><p>然后再次插入硬盘就可以正常使用了，后续有空了可能会对挂载失败问题进行更深入的探究</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu通过网络唤醒</title>
    <link href="/2024/08/05/Ubuntu%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92/"/>
    <url>/2024/08/05/Ubuntu%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu #WakeonLan</p><p>最近因为自己搭建了一个vps而欣喜若狂而导致日崩。由于某些…的需求，我需要能够再不用的时候将服务器关机。因此我开始折腾远程开机。</p><p>我的思路是通过电脑主板自带的Wake on Lan 功能，目前来说大部分主板都有（我的主板是x99 QD4）。最大的问题是在于配置为S5(shutdown)状态下时网卡需要在关机后处于激活状态，而这里需要系统在启动后将对应的网卡状态设置为对应状态。（因为Ubuntu20.04后网络唤醒重启之后网卡状态设置就会失效。。。不知道为啥）</p><p>过程很简单，即通过发送一组特殊格式的网络封包（Magic Packet）给具有某个MAC地址的电脑，让该电脑从睡眠模式甚至是关机模式苏醒，即从ACPI的Sx(S3，S4，S5)模式返回S0运行模式。</p><p>根据以上的思路，我们就开始着手准备了。</p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>我们可以通过ethtool工具来查看并修改网卡状态，因此首先安装ethtool工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install ethtool<br></code></pre></td></tr></table></figure><p>通过ifconfig查看网络信息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>以我的为例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enp6s0</span>: flags=<span class="hljs-number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="hljs-number">1500</span><br>        <span class="hljs-attribute">inet</span> <span class="hljs-number">192.168.0.200</span>  netmask <span class="hljs-number">255.255.255.0</span>  broadcast <span class="hljs-number">192.168.0.255</span><br>        <span class="hljs-attribute">inet6</span> fe80::b7e2:<span class="hljs-number">6743</span>:aa3:<span class="hljs-number">5</span>e49  prefixlen <span class="hljs-number">64</span>  scopeid <span class="hljs-number">0</span>x20&lt;link&gt;<br>        <span class="hljs-attribute">ether</span> <span class="hljs-number">0</span>a:e0:af:b3:<span class="hljs-number">23</span>:bf  txqueuelen <span class="hljs-number">1000</span>  (以太网)<br>        <span class="hljs-attribute">RX</span> packets <span class="hljs-number">10466</span>  bytes <span class="hljs-number">6877996</span> (<span class="hljs-number">6</span>.<span class="hljs-number">8</span> MB)<br>        <span class="hljs-attribute">RX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">3</span>  overruns <span class="hljs-number">0</span>  frame <span class="hljs-number">0</span><br>        <span class="hljs-attribute">TX</span> packets <span class="hljs-number">8851</span>  bytes <span class="hljs-number">860614</span> (<span class="hljs-number">860</span>.<span class="hljs-number">6</span> KB)<br>        <span class="hljs-attribute">TX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">0</span> overruns <span class="hljs-number">0</span>  carrier <span class="hljs-number">0</span>  collisions <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个就是我的有线网卡信息。可以看出，ether就是mac地址，网卡名为enp6s0。接下来通过ethtool查看网卡状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ethtool enp6s0<br></code></pre></td></tr></table></figure><p>可以看到：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Supports</span> Wake-<span class="hljs-literal">on</span>: pumbg<br>Wake-<span class="hljs-literal">on</span>: d<br></code></pre></td></tr></table></figure><p>这里附上Wake-on各种状态的参数含义：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">OptionDescription<br><span class="hljs-keyword">p</span>Wake <span class="hljs-keyword">on</span> PHY activity<br><span class="hljs-keyword">u</span>Wake <span class="hljs-keyword">on</span> unicast <span class="hljs-keyword">messages</span><br><span class="hljs-keyword">m</span>Wake <span class="hljs-keyword">on</span> multicast <span class="hljs-keyword">messages</span><br><span class="hljs-keyword">b</span>Wake <span class="hljs-keyword">on</span> broadcast <span class="hljs-keyword">messages</span><br>gWake <span class="hljs-keyword">on</span> MagicPacket <span class="hljs-keyword">messages</span><br></code></pre></td></tr></table></figure><p>更新网卡状态。由于我们要使用的是MagicPacket信息，因此：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ethtool --change enp6s0 wol g<br><span class="hljs-built_in">sudo</span> ethtool enp6s0<br></code></pre></td></tr></table></figure><p>此时看到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Wake</span>-<span class="hljs-literal">on</span>: g<br></code></pre></td></tr></table></figure><p>说明状态修改成功。</p><p>由于每次开机后都要重新设置网卡的状态才能在下一次关机后再次使用网络唤醒，所以我们可以通过systemd添加一个系统服务在每次开机后修改网卡状态。<br>首先确定ethtool路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> ethtool<br></code></pre></td></tr></table></figure><p>可见:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>sbin/ethtool<br></code></pre></td></tr></table></figure><p>这个因机器而异，因此下面的内容需要根据实际情况修改：</p><p>创建一个 /etc/systemd/system/wol.service 文件，在这里写下启动执行一次的服务信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Enable Wake <span class="hljs-literal">On</span> Lan<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-literal">on</span>eshot<br><span class="hljs-attr">ExecStart</span> = /usr/sbin/ethtool --change enp6s0 wol g<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=basic.target<br></code></pre></td></tr></table></figure><p>之后只需要enable该服务就可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> wol.service<br></code></pre></td></tr></table></figure><p>检查一下对应的状态:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status wol</span><br></code></pre></td></tr></table></figure><p>可以看到：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">○ wakeonlan.service - <span class="hljs-built_in">Enable</span> Wake On<span class="hljs-built_in"> Lan</span><br><span class="hljs-built_in"></span>     Loaded: loaded (/etc/systemd/system/wol.service; enabled; vendor preset: enabled)<br>     Active: inactive (dead) since Tue 2024-02-20 23:32:35 +08; 28min ago<br>   Main PID: 948 (<span class="hljs-attribute">code</span>=exited, <span class="hljs-attribute">status</span>=0/SUCCESS)<br>        CPU: 2ms<br><br>Feb 20 23:32:34<span class="hljs-built_in"> Server </span>systemd[1]: Starting <span class="hljs-built_in">Enable</span> Wake On Lan<span class="hljs-built_in">..</span>.<br>Feb 20 23:32:35<span class="hljs-built_in"> Server </span>systemd[1]: wol.service: Deactivated successfully.<br>Feb 20 23:32:35<span class="hljs-built_in"> Server </span>systemd[1]: Finished <span class="hljs-built_in">Enable</span> Wake On Lan.<br></code></pre></td></tr></table></figure><p>说明服务正常运行。</p><h2 id="远程启动"><a href="#远程启动" class="headerlink" title="远程启动"></a>远程启动</h2><h3 id="Ubuntu-amp-amp-Mac"><a href="#Ubuntu-amp-amp-Mac" class="headerlink" title="Ubuntu &amp;&amp; Mac"></a>Ubuntu &amp;&amp; Mac</h3><p>以Ubuntu和Mac为例，在命令行中执行wakeonlan xx:xx:xx:xx:xx:xx （输入Ubuntu机器对应的mac地址）就可以唤醒机器了</p><p>但是前提是安装了wakeonlan</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>这里我偷懒了，不想自己写一个脚本出来，因此我就用一些现成的工具了。此处我选择的是<a href="https://www.depicus.com/wake-on-lan/wake-on-lan-gui">WakeOnLanGui</a></p><p>界面如下：</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281844763.png" alt="image.png"></p><p>根据实际情况填写MAC地址、被控端域名\ip、子网掩码和端口号（任一）就行了</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Ubuntu</tag>
      
      <tag>#WakeonLan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Voicemeeter使用记录</title>
    <link href="/2024/08/05/Voicemeeter%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/05/Voicemeeter%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>#Voicemeeter</p><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><ul><li>硬件输入：就是现实的电脑上的麦克风、你头戴耳麦的麦克风等硬件录音设备。【硬件输入→（发出）→声音信号】（请注意这里的声音指的是电路中的声音信号，而不是你实际听到的声音。下同。）</li><li><p>硬件输出：就是现实的扬声器喇叭、你头戴耳麦的耳机等硬件发声设备。【声音信号→（被接收）→硬件输出】</p></li><li><p>虚拟输入：就是虚拟录音设备，专门监听系统中各种软件发出的声音信号。【声音信号→（被接收）→虚拟输入】</p></li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281845604.png" alt="virtual_input.jpg"></p><ul><li>虚拟输出：就是虚拟发声设备，有一个虚拟的扬声器，负责向别的设备发出声音信号。【虚拟输出→（发出）→声音信号】</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281845439.png" alt="virtual_output.jpg"></p><ul><li>通道：用于接收和转发声音信号的中间人。</li></ul><h2 id="设置电脑的输入输出设备"><a href="#设置电脑的输入输出设备" class="headerlink" title="设置电脑的输入输出设备"></a>设置电脑的输入输出设备</h2><p>自行百度，这里不再赘述</p><h1 id="二、软件界面"><a href="#二、软件界面" class="headerlink" title="二、软件界面"></a>二、软件界面</h1><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281846233.png" alt="软件界面.jpg"></p><p>看下图硬件输入通道1下面框出来的按钮：A1、A2、A3、B1、B2 都是输出通道，你点亮了哪个，声音信号就会被接入到哪一个输出通道。</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281846495.png" alt="硬件通道输入.jpg"></p><p>比如图中，点亮了A1和B1，那么硬件输入通道1的声音信号就会被发送到A1、B1两个输出通道中去。</p><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>这里只讲解软件同时输出到多个蓝牙设备的使用方法：</p><ul><li>打开Voicemeeter</li><li>配置输出设备</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281847030.png" alt="1.jpg"></p><ul><li>在虚拟输入栏中选择输出设备</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281847879.png" alt="1.png"></p><ul><li>调节音量</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281847699.png" alt="3.png"></p><ul><li>run！</li></ul><h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1><p>如果想了解更多关于voicemeeter相关的知识，可到：<br><a href="http://vb-audio.cn/post/36.html">http://vb-audio.cn/post/36.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>#Voicemeeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode中c编译器配置（mingw64）</title>
    <link href="/2024/08/05/Vscode%E4%B8%ADc%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE%EF%BC%88mingw64%EF%BC%89/"/>
    <url>/2024/08/05/Vscode%E4%B8%ADc%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE%EF%BC%88mingw64%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>#VSCode #Cpp</p><h2 id="To-Start"><a href="#To-Start" class="headerlink" title="To Start"></a>To Start</h2><ul><li>安装Vscode</li><li>请前往<a href="https://code.visualstudio.com/" title="Vscode 官网">https://code.visualstudio.com/</a>下载你所需要的Vscode版本</li></ul><p>下载完了之后，你就可以开始配置C++的运行环境了</p><h2 id="Install-the-extension"><a href="#Install-the-extension" class="headerlink" title="Install the extension"></a>Install the extension</h2><ul><li>打开Vscode</li><li>选择拓展选项卡或者使用快捷键<code>Ctrl+Shift+X</code></li><li>搜索C++</li><li>安装</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281840906.png" alt="1.png"></p><h2 id="Set-up-for-your-C-environment"><a href="#Set-up-for-your-C-environment" class="headerlink" title="Set up for your C++ environment"></a>Set up for your C++ environment</h2><h3 id="下载Mingw64文件"><a href="#下载Mingw64文件" class="headerlink" title="下载Mingw64文件"></a>下载Mingw64文件</h3><ul><li>打开浏览器</li><li>前往<a href="https://github.com/niXman/mingw-builds-binaries/releases">Releases · niXman/mingw-builds-binaries (github.com)</a>下载MingW64文件</li><li>选择下列图片中标出的版本</li><li>解压，获得其中的Mingw64文件夹并放在你想放的位置</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281840477.png" alt="2.png"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li>直接<code>win + S</code>快捷键搜索环境变量，进入该选项卡</li><li>点击环境变量</li><li>在用户变量和系统变量中找到Path，进入编辑</li><li>新建，并将刚才下载的Mingw64中的bin文件夹的路径填入</li><li>完成！</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281840746.png" alt="3.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281840815.png" alt="4.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281841431.png" alt="5.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281841073.png" alt="6.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281841329.png" alt="7.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281841588.png" alt="8.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281841694.png" alt="9.png"></p><p>点击确定，完成！</p><h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><ul><li>直接<code>win + R</code>，输入cmd并运行，打开终端</li><li>输入<code>gcc -v</code>，如果出现下列画面就说明配置成功了</li><li>完成！</li></ul><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281842231.png" alt="10.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281842027.png" alt="11.png"></p><h2 id="Create-and-Run-a-C-file"><a href="#Create-and-Run-a-C-file" class="headerlink" title="Create and Run a C++ file"></a>Create and Run a C++ file</h2><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281842342.png" alt="12.png"></p><p>create a new file called <code>helloworld.cpp</code></p><p>复制，粘贴！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281843039.png" alt="13.png"></p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281843501.png" alt="14.png"></p><p>仅在第一次运行 helloworld.cpp 时提示您选择编译器。该编译器将成为tasks.json 文件中设置的“默认”编译器</p><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281843703.png" alt="15.png"></p><p>拿下！</p><p><strong>好好好，现在你就可以尽情的Coding了，可能还有一些其他的零碎配置</strong></p><p><strong>有空我再更新（</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>#Cpp</tag>
      
      <tag>#VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode多文件编译配置</title>
    <link href="/2024/08/05/Vscode%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/08/05/Vscode%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>#VSCode #Cpp #编译</p><h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><p>默认VSCode 只能编译单个文件，若多个文件一起编译，经常会报 undefined reference 找不到引用的错误，比如下面的问题：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-string">&quot;C:\Program Files\mingw64\bin\g++.exe&quot;</span> -fdiagnostics-color=always -g <span class="hljs-name">C</span>:\Users\ZeroHzzzz\Desktop\dd\dd.cpp -o <span class="hljs-name">C</span>:\Users\ZeroHzzzz\Desktop\dd\dd.exe<br><span class="hljs-name">C</span>:\Users\ZEROHZ~<span class="hljs-number">1</span>\AppData\Local\Temp\ccYQ5ExK.<span class="hljs-name">o</span>: In function `main<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">C:/Users/ZeroHzzzz/Desktop/dd/dd.cpp:6: undefined reference to `maxn(int, int)&#x27;</span><br>collect2.<span class="hljs-name">exe</span>: <span class="hljs-name">error</span>: ld returned <span class="hljs-number">1</span> exit status<br></code></pre></td></tr></table></figure><p>解决方法如下：</p><ul><li>配置一下<code>.vscode</code>文件夹下的 <code>tasks.json</code> 就好了。</li><li>tasks.json的话，就把界面点到代码的界面，然后菜单栏<code>&quot;Terminal&quot;</code> - <code>&quot;Configure Tasks...&quot;</code> 生成默认的<code>tasks.json</code></li></ul><p>找到 tasks.json中的 args 选项，这个主要是用来配置待编译的文件信息的，<code>$&#123;file&#125;</code>替换成 <code>$&#123;workspaceFolder&#125;</code>, 结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>再次运行程序，就可以多文件正常编译了</p><h2 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h2><p>但是如果我们还有其它的二级目录，那就还需要修改<code>tasks.json</code>文件。</p><p>【举例】main函数所在<code>test.cpp</code>在一级目录下，其它<code>cpp</code>文件在 <code>others</code>目录下，这个时候就需要把<code>tasks.json</code>改成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\others\\*.cpp&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//修改项</span><br>    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#Cpp</tag>
      
      <tag>#编译</tag>
      
      <tag>#VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode自动格式化插件</title>
    <link href="/2024/08/05/Vscode%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%92%E4%BB%B6/"/>
    <url>/2024/08/05/Vscode%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>#VSCode #Prettier</p><h2 id="Previous"><a href="#Previous" class="headerlink" title="Previous"></a>Previous</h2><p>事情的起因是我在某一天打开 vscode 后发现了 tab 变成了两个空格而导致我这个极度代码洁癖的人感觉很难受<br><del>由于懒</del>…由于习惯了编写 go 语言代码保存时候的自动格式化，这让最近因为 c++的<del>goushi</del>作业而焦头烂额的我开始思考能不能在其他语言编写的时候能不能也搞个</p><p>由于我平时使用的是 Vscode，因此我就直接使用了 prettier 插件。以下是我配置的一些记录：</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>安装 prettier 插件</li><li>配置<ul><li>可以通过 setting.json 进行配置， 这里就不多说了</li><li>也可以通过在 setting 中直接搜索 prettier 来实现</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 保存自动格式化</span><br><span class="hljs-attr">&quot;prettier.useTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;prettier.tabWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// Tab 宽度</span><br><span class="hljs-attr">&quot;C_Cpp.clang_format_style&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123; BasedOnStyle: Chromium, IndentWidth: 4&#125;&quot;</span> <span class="hljs-comment">// c++/c 大括号不换行</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>#VSCode</tag>
      
      <tag>#Prettier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo搭建博客（GitHub）</title>
    <link href="/2024/08/05/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88GitHub%EF%BC%89/"/>
    <url>/2024/08/05/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88GitHub%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>#hexo</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>GitHub账号</li><li>安装git</li><li>安装node</li></ul><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ul><li>创建仓库，并将仓库命名为 username.github.io<br>注意这里的username（）</li></ul><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul><li>安装hexo<br><code>npm install -g hexo-cli</code></li><li>check<br><code>hexo -v</code></li><li>创建hexo项目并初始化</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hexo init [hexo-<span class="hljs-keyword">blog(你新建的本地博客文件夹的名字，如果不输入默认为当前文件夹)]</span><br><span class="hljs-keyword"></span>cd hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo默认主题为landscape，可以前往hexo官网寻找你心仪的主题<br><a href="https://hexo.io/themes/">Themes</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">[github</span>地址] [存放路径]<br><span class="hljs-comment"># 例如</span><br><span class="hljs-comment"># git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></code></pre></td></tr></table></figure><p>在根目录的 _config.yml 文件中找到theme字段并将它改成你主题的名字<br><code>theme: next</code></p><p>本地启动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span><br>hexo s<br></code></pre></td></tr></table></figure><p><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408281852233.png" alt="1.png"></p><h2 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h2><p>根据themes提供的文档修改参数</p><h2 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h2><p>新建文章<br><code>hexo new post 测试文章</code><br>然后就开始写吧</p><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><ul><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果<br><code>hexo s</code></li></ul><h2 id="Deloy"><a href="#Deloy" class="headerlink" title="Deloy"></a>Deloy</h2><ul><li>安装hexo-deployer-git<br><code>npm install hexo-deployer-git --save</code></li><li>修改根目录下的 _config.yml，配置 GitHub 相关信息,token获取方式自行百度</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY   <span class="hljs-meta"># 应该可写可不写</span><br></code></pre></td></tr></table></figure><ul><li>发布</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span> -d<br></code></pre></td></tr></table></figure><h2 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h2><h3 id="使用Fluid主题的一些文章属性设置"><a href="#使用Fluid主题的一些文章属性设置" class="headerlink" title="使用Fluid主题的一些文章属性设置"></a>使用Fluid主题的一些文章属性设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs title">---<br>title: Hexo Fluid主题使用笔记<br><br>tags:<br>  - Hexo<br>  [Hexo, Fluid]  # 推荐使用这种方法<br><br>categories:<br>  - Hexo<br>  - Fluid # 注意以上这两个标题不是并列关系，而是包含关系<br>  - Hexo<br>    - Fluid  # 注意以上这两个标题是并列关系<br>  - [Hexo, Fluid]  # 并列关系<br><br>excerpt: 这是摘要 # 摘要还可以在正文通过 &lt;!-- more --&gt; 进行分割<br><br>hide: true # 隐藏文章，隐藏后依然可以通过文章链接访问<br><br>sticky: 100 # 数值越大排序越靠前<br><br>index_img: /img/example.jpg # 文章在首页的封面图，支持外链<br><br>banner_img: /img/post_banner.jpg # 文章详情页顶部大图，支持外链<br><br>toc: true # 生成文章目录，不填为true<br>---<br><br></code></pre></td></tr></table></figure><h3 id="一些有意思的东西"><a href="#一些有意思的东西" class="headerlink" title="一些有意思的东西"></a>一些有意思的东西</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs hexo">// 便签<br><br>&#123;% note success %&#125;<br>文字 或者 `markdown` 均可<br>&#123;% endnote %&#125;<br>或者使用 HTML 形式：<br>&lt;p class=&quot;note note-primary&quot;&gt;标签&lt;/p&gt;<br><br><br>//行内标签<br><br>&#123;% label primary @text %&#125;<br>或者<br>&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt;<br><br><br>//复选框<br><br>&#123;% cb text, checked?, incline? %&#125;<br><br>text：显示的文字<br>checked：默认是否已勾选，默认 false<br>incline: 是否内联（可以理解为后面的文字是否换行），默认 false<br><br><br>//按钮<br><br>&#123;% btn url, text, title %&#125;<br><br>或者：<br><br>&lt;a class=&quot;btn&quot; href=&quot;url&quot; title=&quot;title&quot;&gt;text&lt;/a&gt;<br><br>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）<br></code></pre></td></tr></table></figure><h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2>]]></content>
    
    
    
    <tags>
      
      <tag>#hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给GitHub Pages配置CNAME</title>
    <link href="/2024/07/29/%E7%BB%99GitHub%20Pages%E9%85%8D%E7%BD%AECNAME/"/>
    <url>/2024/07/29/%E7%BB%99GitHub%20Pages%E9%85%8D%E7%BD%AECNAME/</url>
    
    <content type="html"><![CDATA[<p>#CNAME #GitHubPages</p><h2 id="什么是-DNS-CNAME-记录"><a href="#什么是-DNS-CNAME-记录" class="headerlink" title="什么是 DNS CNAME 记录"></a>什么是 DNS CNAME 记录</h2><p>一个”冠名” （CNAME）记录从一个别名域指向一个”冠名” 域。当一个[[域名|域]]或子域是另一个域的别名时，CNAME记录被用来代替 [[A记录]] 。 所有CNAME记录都必须指向一个域名，而不是指向一个IP地址。 CNAME记录允许你把一个域名（别名）指向另一个域名（规范名）。这样，当用户访问别名时，实际上会被重定向到规范名。</p><p>例如，假设 blog.example.com 的 CNAME 记录的值为“example.com”（没有“blog”）。这意味着当 DNS 服务器点击 blog.example.com 的 DNS 记录时，它实际上会触发另一个对 example.com 的 DNS 查找，并通过其 A 记录返回 example.com 的 IP 地址。在这种情况下，我们会说 example.com 是 blog.example.com 的规范名称（或真实名称）。</p><p>这样也就带来了一个优势。通过CNAME记录，你可以简化域名的管理。如果你的主域名的IP地址更改了，只需更新主域名的A记录，而不需要逐个更新每个子域名的记录</p><p>人们常常误以为CNAME记录必须解析为它指向的域名所在的网站。也就是说，他们认为如果 <code>blog.example.com</code> 的CNAME记录指向 <code>example.com</code>，访问 <code>blog.example.com</code> 时看到的内容一定和 <code>example.com</code> 一样。但是，CNAME记录实际上只是将客户端（即用户的浏览器）指向与根域名相同的IP地址。换句话说，CNAME记录让 <code>blog.example.com</code> 和 <code>example.com</code> 指向同一个IP地址。当客户端连接到这个IP地址时，Web服务器会根据客户端请求的URL来决定返回什么内容。例如，当用户访问 <code>blog.example.com</code> 时，尽管这个域名通过CNAME记录指向 <code>example.com</code> 的IP地址，Web服务器会识别出请求的URL是 <code>blog.example.com</code>，然后返回博客页面而不是<code>example.com</code> 的主页。</p><p>也就是说，CNAME记录并不改变用户访问的URL，而是将用户导向同一个IP地址。之后，具体返回什么内容由Web服务器根据请求的URL来决定。CNAME记录实现的是域名之间的指向关系，而实际内容的返回取决于Web服务器对请求的处理。</p><div class="table-container"><table><thead><tr><th>blog.example.com</th><th>record type:</th><th>value:</th><th>TTL</th></tr></thead><tbody><tr><td>@</td><td>CNAME</td><td>is an alias of example.com</td><td>32600</td></tr></tbody></table></div><p>注意，MX 和 NS 记录不能指向 CNAME 记录，它们必须指向 A 记录（对于 IPv4）或 AAAA 记录。MX 记录是邮件交换记录，将电子邮件指向一个邮件服务器。NS 记录是“名称服务器”记录，表明哪个 DNS 服务器是该域的权威。</p><h2 id="给GitHub-Pages配置CNAME记录"><a href="#给GitHub-Pages配置CNAME记录" class="headerlink" title="给GitHub Pages配置CNAME记录"></a>给GitHub Pages配置CNAME记录</h2><p>我们这里主要讲述如何配置子域名。官方的文档<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-subdomain">在这</a><br>其实不用很麻烦</p><p>首先需要建立一个名为CNAME的文件。文件中的内容也只需要一行，也就是自定义域名的空子域名，例如<code>blog.zerohzzzz.top</code>（请注意不是<code>https://blog.zerohzzzz.top</code>）。注意，在 <em>CNAME</em> 文件中只允许有<strong>一个域名</strong>。这个文件以后放在你博客中的sources文件夹中，以后<code>deloy</code>的时候会一起提交上去并出现在储存分支的根目录</p><p>进入你的<code>github.io</code>储存库，并进入设置（<code>setting</code>），在侧边栏中的<code>Code and automation</code>中选择<code>Pages</code></p><p>在<code>Custom domain</code>条目下，输入你的域名，然后选择保存，注意这个域名和你<em>CNAME</em>文件中的域名要保持一致。</p><p>最后去你的DNS提供商（你域名在哪买就去哪，或者可以选择托管到cloudfare，但是国内的话速度堪忧）新增一个CNAME记录，将你的二级域名指向你的GitHub Pages，如<code>&lt;user&gt;.github.io</code>至此工作就全部完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>#GitHubPages</tag>
      
      <tag>#CNAME</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu-22-04-LTS安装Steam</title>
    <link href="/2024/07/26/Ubuntu-22-04-LTS%E5%AE%89%E8%A3%85Steam/"/>
    <url>/2024/07/26/Ubuntu-22-04-LTS%E5%AE%89%E8%A3%85Steam/</url>
    
    <content type="html"><![CDATA[<p>#steam #Ubuntu</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久很久以前，有个人有点受不了用windows这种系统了，由于Have no money（）….经过了一段时间的观望，他开始转向Linux的怀抱。然而又因为某些智力因素于是他决定先从Ubuntu开始……</p><p>众所周知，安装系统后第一件事就是下载steam。原本来说，Linux系统的一大痛点就是不能玩游戏，但是随着 Steam Play 功能的推出，一切都开始有所转机</p><p>于是他尝试了很多种方法来实现自己的愿望。<br>我们将介绍每一种方法</p><h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>系统环境：Ubuntu 22.04.4 LTS<br>桌面环境：Gnome 42.9<br>窗口系统：×11</p><p>硬件环境自不必多说，应该没有问题（毕竟是i9+4080</p><h3 id="Ubuntu-Software"><a href="#Ubuntu-Software" class="headerlink" title="Ubuntu Software"></a>Ubuntu Software</h3><p>这是一种抽象的方法因为Ubuntu Software是基于snap的<br>这里我为了不污染我的系统于是我就不试了<br>而且也确实没啥好讲的</p><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><p>在我的观念中，能用apt装了没问题的软件就不用其他的装，因此这个方法是我的首选</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt intall steam<br></code></pre></td></tr></table></figure><p>也是顺利的装上了<br><img src="https://cloud.intro-iu.top:738/d/ThreeBody/ZeroHzzzzPic/202408210020685.png" alt="Steam"></p><p>但是这个方法不知道是不是我打开的方式有问题，每次我开双屏（<del>当然不得不提一下我的27寸大屏啦</del>）都会发现有一个屏幕显示异常，表现为一动不动但是另一个屏幕正常。看了网上的各种解决方法也还暂时不知道所以然。。。因此我果断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt purge steam<br></code></pre></td></tr></table></figure><p>然后开始尝试另一种方法</p><h3 id="Flatpak"><a href="#Flatpak" class="headerlink" title="Flatpak"></a>Flatpak</h3><p>这个方法是我最终使用方法，也是我比较喜欢的一种方式（虽然被学长说有点臃肿），毕竟他把runtime包在一起的缘故，应用程序可能随便都占1GB以上，除此之外还有沙盒权限问题</p><h4 id="安装flatpak"><a href="#安装flatpak" class="headerlink" title="安装flatpak"></a>安装flatpak</h4><p>这个方法首先要我们安装<a href="https://flatpak.org/setup/Ubuntu">flatpak</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install flatpak<br></code></pre></td></tr></table></figure><p>当然也可以添加Flatpak PPA来安装（针对于旧版本Ubuntu）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> add-apt-repository ppa:flatpak/stable<br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install flatpak<br></code></pre></td></tr></table></figure><p>（可选）安装flatpak插件，这样可以通过可视化界面安装flatpak软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gnome-software-plugin-flatpak<br></code></pre></td></tr></table></figure><p>添加Flathub 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo<br></code></pre></td></tr></table></figure><p>然后restart</p><h3 id="安装steam"><a href="#安装steam" class="headerlink" title="安装steam"></a>安装steam</h3><p>直接通过flatpak安装<a href="https://flathub.org/apps/com.valvesoftware.Steam">steam</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flatpak install flathub com.valvesoftware.Steam<br></code></pre></td></tr></table></figure><p>这样就顺利的装上了，记得启用Steam Play就行了，这样安装游戏的时候就能正常使用了（当然是大部分，据我所知大表哥就不行555~）</p><h3 id="Flatseal"><a href="#Flatseal" class="headerlink" title="Flatseal"></a>Flatseal</h3><p>这个玩意是用来管理Flatpak权限的，可装可不装，但是装上明显会更方便。因为记不住……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install Flatseal<br></code></pre></td></tr></table></figure><h2 id="Additions"><a href="#Additions" class="headerlink" title="Additions"></a>Additions</h2><p>由于我系统盘空间不足的缘故，我想把游戏安装到外置硬盘。因此我尝试添加存储空间。<br>但我发现，添加存储空间的时候无法直接添加指定的驱动器，只能通过~/media/这个软链接来添加。置此备忘</p>]]></content>
    
    
    
    <tags>
      
      <tag>#Ubuntu</tag>
      
      <tag>#steam</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
