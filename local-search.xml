<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记录Ubuntu 22.04 LTS 磁盘无法正常访问问题的解决</title>
    <link href="/2024/05/10/Ubuntu-disk-inaccessible/"/>
    <url>/2024/05/10/Ubuntu-disk-inaccessible/</url>
    
    <content type="html"><![CDATA[<p>最近属实是有点太压抑了，于是斥巨资买下了HOGWARTS，然后在下载的时候发现游戏盘掉了，表现为：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> &quot;xxx&quot;, an operation <span class="hljs-keyword">is</span> pending <br></code></pre></td></tr></table></figure> 找了一下，原因是上一次拔硬盘的时候没有安全退出</p><p>【解决方法】 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> fdisk -l <br></code></pre></td></tr></table></figure> <img src="image.png" />最后的设备/dev/sda1就是出问题的磁盘，于是我们需要修复挂载错误的相应分区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ntfsfix /dev/sda1<br></code></pre></td></tr></table></figure>然后再次插入硬盘就可以正常使用了，后续有空了可能会对挂载失败问题进行更深入的探究</p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代数系统</title>
    <link href="/2024/05/08/Algebraic-system/"/>
    <url>/2024/05/08/Algebraic-system/</url>
    
    <content type="html"><![CDATA[<h1 id="代数运算">代数运算</h1><h2 id="定义">定义</h2><p>设 <span class="math inline">\(A\)</span> 是个非空集合，<spanclass="math inline">\(A \to A\)</span> 的一个映射 <spanclass="math inline">\(f: A \to A\)</span> 称为 <spanclass="math inline">\(A\)</span> 上的一个一元代数运算，如果是 <spanclass="math inline">\(A \times A\)</span> 到 <spanclass="math inline">\(A\)</span> 的一个映射 <spanclass="math inline">\(f: A \times A \to A\)</span> 称为 <spanclass="math inline">\(A\)</span>上的一个二元代数运算。<del>其实说人话就是看运算所需要的代数个数为多少那就是几元运算...</del></p><h2 id="运算的封闭性">运算的封闭性</h2><p>设 <span class="math inline">\(\ast\)</span> 是 <spanclass="math inline">\(A\)</span> 上的二元运算，如果对于任意的 <spanclass="math inline">\(x, y \in A\)</span>，均有 <spanclass="math inline">\(x \ast y \in A\)</span>，那么称 <spanclass="math inline">\(\ast\)</span> 对 <spanclass="math inline">\(A\)</span> 是封闭的。</p><h2 id="运算律">运算律</h2><ul><li>交换律：如果对任意的 <span class="math inline">\(x, y \inA\)</span>，均有 <span class="math inline">\(x \ast y = y \astx\)</span>，那么称 <span class="math inline">\(\ast\)</span> 在 <spanclass="math inline">\(A\)</span> 上是可交换的，或者说 <spanclass="math inline">\(\ast\)</span> 在 <spanclass="math inline">\(A\)</span> 上满足交换律。</li><li>结合律：如果对任意的 <span class="math inline">\(x, y, z \inA\)</span>，均有 <span class="math inline">\((x \ast y) \ast z = x \ast(y \ast z)\)</span>，那么称 <span class="math inline">\(\ast\)</span> 在<span class="math inline">\(A\)</span> 上是可结合的，或者说 <spanclass="math inline">\(\ast\)</span> 在 <spanclass="math inline">\(A\)</span> 上满足结合律。</li><li>幂等律：如果对任意的 <span class="math inline">\(x \inA\)</span>，均有 <span class="math inline">\(x \ast x =x\)</span>，那么称 <span class="math inline">\(\ast\)</span> 在 <spanclass="math inline">\(A\)</span> 上是幂等的，或者说 <spanclass="math inline">\(\ast\)</span> 在 <spanclass="math inline">\(A\)</span> 上满足幂等律。</li><li>分配律：设 <span class="math inline">\(+\)</span> 和 <spanclass="math inline">\(\ast\)</span> 是 <spanclass="math inline">\(A\)</span> 上的两个二元运算，如对任意的 <spanclass="math inline">\(x,y,z \in A\)</span> 均有： <spanclass="math display">\[x \ast (y + z) = (x \ast y) + (x \ast z)\]</span> <span class="math display">\[(y + z) \ast x = (y \ast x) + (z \ast x)\]</span></li><li>吸收律：设 <span class="math inline">\(+\)</span> 和 <spanclass="math inline">\(\ast\)</span> 是 <spanclass="math inline">\(A\)</span> 上的两个二元运算，如果对于任意的 <spanclass="math inline">\(x,y \in A\)</span>，均有 <spanclass="math inline">\(x \ast (x + y) = x\)</span>，同时有 <spanclass="math inline">\(x + (x \ast y) = x\)</span>，称 <spanclass="math inline">\(+\)</span> 和 <spanclass="math inline">\(\ast\)</span> 满足吸收律。</li></ul><h2 id="等幂元">等幂元</h2><p>设代数系统 <span class="math inline">\(\langle A, \ast\rangle\)</span>，如果存在 <span class="math inline">\(a \inA\)</span>，使得 <span class="math inline">\(a \ast a = a\)</span>，则称<span class="math inline">\(a\)</span> 为 <spanclass="math inline">\(\langle A, \ast \rangle\)</span>的等幂元。如果是可结合的，那么 <span class="math inline">\(a^n =a\)</span>，<span class="math inline">\(n\)</span> 为正整数。</p><p>看运算表对角线：运算表对角线上的运算结果与元素相同则为等幂元。</p><h2 id="单位元幺元">单位元（幺元）</h2><h3 id="定义-1">定义</h3><p>若 <span class="math inline">\(a \ast e = a\)</span>，<spanclass="math inline">\(e\)</span> 称为右单位元；若 <spanclass="math inline">\(e \ast a = a\)</span>，<spanclass="math inline">\(e\)</span> 称为左单位元，若 <spanclass="math inline">\(a \ast e = e \ast a = a\)</span>，则 <spanclass="math inline">\(e\)</span>称为单位元。若该演算左右的元素能互换，左、右单位元相同，可称为双边单位元。</p><p>如果某列与首列相同，则该列所对应的元素即为<strong>右单位元</strong>。如果某行与首行相同，则该行所对应的元素即为<strong>左单位元</strong>。</p><table><thead><tr class="header"><th>代数系统</th><th>幺元</th></tr></thead><tbody><tr class="odd"><td>$ (, ) $</td><td>1</td></tr><tr class="even"><td>$ (, +) $</td><td>0</td></tr><tr class="odd"><td>$ ((A), ) $</td><td>A</td></tr></tbody></table><h3 id="性质">性质</h3><p>不存在两个以上的单位元。若有两个单位元 <spanclass="math inline">\(e\)</span> 和 <spanclass="math inline">\(f\)</span> 的话，则 <span class="math inline">\(e\ast f\)</span> 必同时等于 <span class="math inline">\(e\)</span> 和<spanclass="math inline">\(f\)</span>，因此有单位元运算表则不可能有两行元素完全相同，不可能有两列元素完全相同，即运算表中任两列或任两行均不相同。</p><h2 id="零元">零元</h2><h3 id="定义-2">定义</h3><p>设 <span class="math inline">\(\langle A, \ast \rangle\)</span>是一个代数系统，其中 <span class="math inline">\(\ast\)</span> 是集合<span class="math inline">\(A\)</span> 上的一个二元运算。</p><ul><li>若存在元素 <span class="math inline">\(\theta_l \inA\)</span>，对所有 <span class="math inline">\(x \in A\)</span> 都有<span class="math inline">\(\theta_l \ast x = \theta_l\)</span>，则称<span class="math inline">\(\theta_l\)</span> 为 <spanclass="math inline">\(A\)</span> 中关于运算 <spanclass="math inline">\(\ast\)</span> 的<strong>左零元</strong>（leftzero）。</li><li>若存在元素 <span class="math inline">\(\theta_r \inA\)</span>，对所有 <span class="math inline">\(x \in A\)</span> 都有<span class="math inline">\(x \ast \theta_r = \theta_r\)</span>，则称<span class="math inline">\(\theta_r\)</span> 为 <spanclass="math inline">\(A\)</span> 中关于运算 <spanclass="math inline">\(\ast\)</span> 的<strong>右零元</strong>（rightzero）。</li><li>若存在元素 <span class="math inline">\(\theta \in A\)</span>，对所有<span class="math inline">\(x \in A\)</span> 都有 <spanclass="math inline">\(\theta \ast x = x \ast \theta = x\)</span>，则称<span class="math inline">\(\theta\)</span> 为 <spanclass="math inline">\(A\)</span> 中关于运算 <spanclass="math inline">\(\ast\)</span> 的<strong>零元</strong>（zeroelement）。</li></ul><h3 id="性质-1">性质</h3><p>若 <span class="math inline">\(A\)</span> 中存在关于运算 <spanclass="math inline">\(\ast\)</span> 的左零元 <spanclass="math inline">\(\theta_l\)</span> 与右零元 <spanclass="math inline">\(\theta_r\)</span>，则 <spanclass="math inline">\(\theta_l = \theta_r\)</span>，且 <spanclass="math inline">\(A\)</span> 中零元唯一。</p><p>运算表中就看哪一行 就行了。</p><h2 id="逆元">逆元</h2><h3 id="定义-3">定义</h3><p>设存在单位元素 <span class="math inline">\(e\)</span> 的代数系统<span class="math inline">\(\langle S, \cdot \rangle\)</span>，其中<span class="math inline">\(\cdot\)</span> 是二元运算：</p><ul><li>如果对 <span class="math inline">\(S\)</span> 内的元素 <spanclass="math inline">\(a\)</span> 存在 <spanclass="math inline">\(b\)</span>，使得 <span class="math inline">\(a\cdot b = e\)</span>，则称 <span class="math inline">\(b\)</span> 为<span class="math inline">\(a\)</span> 对运算 <spanclass="math inline">\(\cdot\)</span>的<strong>左逆元素</strong>，亦称<strong>左逆元</strong>。</li><li>如果对 <span class="math inline">\(S\)</span> 内的元素 <spanclass="math inline">\(a\)</span> 存在 <spanclass="math inline">\(b\)</span>，使得 <span class="math inline">\(b\cdot a = e\)</span>，则称 <span class="math inline">\(b\)</span> 为<span class="math inline">\(a\)</span> 对运算 <spanclass="math inline">\(\cdot\)</span>的<strong>右逆元素</strong>，亦称<strong>右逆元</strong>。</li></ul><h3 id="性质-2">性质</h3><ul><li>一个元素可以没有左逆元和右逆元。</li><li>一个元素可以只有左逆元。</li><li>一个元素可以只有右逆元。</li><li>一个元素可以既有左逆元，又有右逆元。</li></ul><h1 id="代数系统">代数系统</h1><h1 id="半群">半群</h1><p>半群是一个二元运算的代数系统。设代数系统 <spanclass="math inline">\(\langle S, \cdot \rangle\)</span>，其中 <spanclass="math inline">\(\cdot\)</span> 是二元运算，如果 <spanclass="math inline">\(\cdot\)</span> 在 <spanclass="math inline">\(S\)</span>上满足<strong>封闭律</strong>和<strong>结合律</strong>，则称 <spanclass="math inline">\(\langle S, \cdot \rangle\)</span> 为半群。</p><h1 id="子半群">子半群</h1><p>如果 <span class="math inline">\(B\)</span> 是 <spanclass="math inline">\(S\)</span> 的子集，且 <spanclass="math inline">\(\langle S, \cdot \rangle\)</span> 为半群，而 <spanclass="math inline">\(\langle B, \cdot \rangle\)</span> 也是半群，那么称<span class="math inline">\(\langle B, \cdot \rangle\)</span> 是 <spanclass="math inline">\(\langle S, \cdot \rangle\)</span> 的子半群。</p><h1 id="独异点">独异点</h1><p>含有单位元的半群叫做独异点，也叫做奇异点。</p><h1 id="子独异点">子独异点</h1><p>同样是子集且为独异点。</p><h1 id="可交换半群">可交换半群</h1><p>设 <span class="math inline">\(\langle S, \cdot \rangle\)</span>为半群，如果 <span class="math inline">\(\cdot\)</span> 是可交换的，则称<span class="math inline">\(\langle S, \cdot \rangle\)</span>为可交换半群。</p><h1 id="循环半群">循环半群</h1><p><span class="math inline">\(\langle S, \cdot \rangle\)</span>为半群，<span class="math inline">\(g \in S\)</span>，若对于任意的 <spanclass="math inline">\(x \in S\)</span>， 存在一个自然数 <spanclass="math inline">\(n\)</span> 使得 <span class="math inline">\(x =g^n\)</span>，则称 <span class="math inline">\(\langle S, \cdot\rangle\)</span> 为循环半群，并称 <span class="math inline">\(g\)</span>为 <span class="math inline">\(\langle S, \cdot \rangle\)</span>的生成元。</p><h1 id="群">群</h1><h2 id="定义-4">定义</h2><p>设 <span class="math inline">\(\langle S, \cdot \rangle\)</span>为代数系统，如果：</p><ul><li>运算 <span class="math inline">\(\cdot\)</span> 对 <spanclass="math inline">\(S\)</span> 是封闭的。</li><li>运算是可结合的。</li><li><span class="math inline">\(\langle S, \cdot \rangle\)</span>中有单位元。</li><li><strong><span class="math inline">\(S\)</span>中的每个元素都存在逆元</strong>。</li></ul><p>则称 <span class="math inline">\(\langle S, \cdot \rangle\)</span>是一个群。</p><p>其实就是在独异点的基础上加上每个元素都有逆元。</p><h2 id="性质-3">性质</h2><p>设 <span class="math inline">\(S\)</span> 是一个群：</p><ul><li>单位元唯一。</li><li>逆元唯一。</li><li>对于所有 <span class="math inline">\(a, b \in S\)</span>，有 <spanclass="math inline">\((ab)^{-1} = b^{-1}a^{-1}\)</span>。</li><li>对于所有 <span class="math inline">\(a \in S\)</span>，有 <spanclass="math inline">\((a^{-1})^{-1} = a\)</span>。</li><li>对于所有 <span class="math inline">\(a, b, c \in S\)</span>，若<span class="math inline">\(ab = ac\)</span> 则 <spanclass="math inline">\(b = c\)</span>。</li><li>对于所有 <span class="math inline">\(a, b, c \in S\)</span>，若<span class="math inline">\(ba = ca\)</span> 则 <spanclass="math inline">\(b = c\)</span>。</li></ul><h1 id="子群">子群</h1><p><span class="math inline">\(\langle S, \cdot \rangle\)</span>有两个平凡子群，就是 <span class="math inline">\(\langle \{e\}, \cdot\rangle\)</span> 和 <span class="math inline">\(\langle S, \cdot\rangle\)</span> 本身。</p><h2 id="子群判定定理">子群判定定理</h2><p>若 <span class="math inline">\(S\)</span> 是群 <spanclass="math inline">\(G\)</span> 的一个子集，则 <spanclass="math inline">\(S\)</span> 是群 <spanclass="math inline">\(G\)</span> 的子群当且仅当：</p><ul><li>对于任意的 <span class="math inline">\(a, b \in S\)</span>，有 <spanclass="math inline">\(ab \in S\)</span>。</li><li>对于任意的 <span class="math inline">\(a \in S\)</span>，有 <spanclass="math inline">\(a^{-1} \in S\)</span>。</li></ul><h1 id="特殊的群">特殊的群</h1><h2 id="交换群">交换群</h2><p>若 <span class="math inline">\(\langle G, \cdot \rangle\)</span>是群且满足 <span class="math inline">\(\forall a, b \in G, ab =ba\)</span>，则称 <span class="math inline">\(\langle G, \cdot\rangle\)</span> 为交换群（Abelian 群）。</p><h2 id="循环群">循环群</h2><p>任何一个循环群必定是交换群。元素 <spanclass="math inline">\(g\)</span> 就是群的生成元。如果群 <spanclass="math inline">\(G\)</span> 中的每个元素都可以表示为某个元素 <spanclass="math inline">\(g\)</span> 的幂，则称 <spanclass="math inline">\(G\)</span> 为循环群，记作 <spanclass="math inline">\(\langle g \rangle\)</span>。</p><h1 id="环">环</h1><h2 id="定义-5">定义</h2><p>设 <span class="math inline">\(\langle R, +, \cdot \rangle\)</span>是一个代数系统，其中 <span class="math inline">\(+\)</span> 和 <spanclass="math inline">\(\cdot\)</span> 是 <spanclass="math inline">\(R\)</span>上的两个二元运算。如果满足以下条件：</p><ol type="1"><li><span class="math inline">\(\langle R, + \rangle\)</span>是交换群。</li><li>乘法 <span class="math inline">\(\cdot\)</span> 对 <spanclass="math inline">\(R\)</span> 是封闭的。</li><li>乘法 <span class="math inline">\(\cdot\)</span>满足结合律，即对于任意 <span class="math inline">\(a, b, c \inR\)</span>，有 <span class="math inline">\((a \cdot b) \cdot c = a \cdot(b \cdot c)\)</span>。</li><li>乘法对加法分配，即对于任意 <span class="math inline">\(a, b, c \inR\)</span>，有： <span class="math display">\[a \cdot (b + c) = (a \cdot b) + (a \cdot c)\]</span> <span class="math display">\[(a + b) \cdot c = (a \cdot c) + (b \cdot c)\]</span></li></ol><p>则称 <span class="math inline">\(\langle R, +, \cdot \rangle\)</span>为一个环。</p><h2 id="单位元环">单位元环</h2><p>若环 <span class="math inline">\(\langle R, +, \cdot \rangle\)</span>中存在单位元 <span class="math inline">\(1\)</span>，使得对任意 <spanclass="math inline">\(a \in R\)</span>，有 <span class="math inline">\(a\cdot 1 = 1 \cdot a = a\)</span>，则称该环为单位元环。</p><h2 id="交换环">交换环</h2><p>若环 <span class="math inline">\(\langle R, +, \cdot \rangle\)</span>满足乘法交换律，即对于任意 <span class="math inline">\(a, b \inR\)</span>，有 <span class="math inline">\(a \cdot b = b \cdota\)</span>，则称该环为交换环。</p><h2 id="零环">零环</h2><p>若环 <span class="math inline">\(\langle R, +, \cdot \rangle\)</span>满足 <span class="math inline">\(a \cdot b = 0\)</span> 对于任意 <spanclass="math inline">\(a, b \in R\)</span>，则称该环为零环。</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合与关系</title>
    <link href="/2024/05/07/Sets-and-Relationships/"/>
    <url>/2024/05/07/Sets-and-Relationships/</url>
    
    <content type="html"><![CDATA[<h1 id="集合的概念与表示">集合的概念与表示</h1><h2 id="集合表示方法">集合表示方法</h2><ul><li>列举法：<span class="math inline">\(A = \{1, 2, 3, 4\}\)</span></li><li>描述法：<span class="math inline">\(B = \{x \mid x \inA\}\)</span></li></ul><h2 id="包含关系">包含关系</h2><p>设 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 是两个集合：</p><ul><li>如果 <span class="math inline">\(A\)</span> 中的每一个元素都是 <spanclass="math inline">\(B\)</span> 的元素，则称 <spanclass="math inline">\(A\)</span> 是 <spanclass="math inline">\(B\)</span> 的子集，记作 <spanclass="math inline">\(A \subseteq B\)</span>。</li><li>如果 <span class="math inline">\(A\)</span> 是 <spanclass="math inline">\(B\)</span> 的子集，并且 <spanclass="math inline">\(A \neq B\)</span>，则称 <spanclass="math inline">\(A\)</span> 是 <spanclass="math inline">\(B\)</span> 的真子集，记作 <spanclass="math inline">\(A \subset B\)</span>。</li></ul><h3 id="例子">例子</h3><ul><li><span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{1, 2, 3, 4\}\)</span>，则 <spanclass="math inline">\(A \subset B\)</span>。</li><li><span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{1, 2, 3\}\)</span>，则 <spanclass="math inline">\(A \subseteq B\)</span>。</li></ul><h2 id="幂集">幂集</h2><p><span class="math inline">\(A\)</span>的全体子集构成的集合（包括空集）叫做 <spanclass="math inline">\(A\)</span> 的幂集，记为 <spanclass="math inline">\(\mathcal{P}(A)\)</span> 或者 <spanclass="math inline">\(2^A\)</span>。</p><p>设 <span class="math inline">\(A = \{a, b, c\}\)</span>，则 <spanclass="math inline">\(A\)</span> 的幂集为 <spanclass="math inline">\(\mathcal{P}(A) = \{\varnothing, \{a\}, \{b\},\{c\}, \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\}\}\)</span>。</p><h1 id="集合的运算">集合的运算</h1><h2 id="交运算">交运算</h2><p><span class="math display">\[ A \cap B = \{ x \mid x \in A \wedge x\in B \} \]</span></p><h3 id="例子-1">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3, 4\}\)</span>，则 <spanclass="math inline">\(A \cap B = \{2, 3\}\)</span>。</p><h2 id="并运算">并运算</h2><p><span class="math display">\[ A \cup B = \{ x \mid x \in A \vee x \inB \} \]</span></p><h3 id="例子-2">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3, 4\}\)</span>，则 <spanclass="math inline">\(A \cup B = \{1, 2, 3, 4\}\)</span>。</p><h2 id="相对补">相对补</h2><p><span class="math display">\[ A - B = \{ x \mid x \in A \wedge x\notin B \} \]</span></p><h3 id="例子-3">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3, 4\}\)</span>，则 <spanclass="math inline">\(A - B = \{1\}\)</span>。</p><h2 id="绝对补">绝对补</h2><p>当相对补中的 <span class="math inline">\(A\)</span> 为全集 <spanclass="math inline">\(E\)</span> 的时候，记为 <spanclass="math inline">\(\sim B\)</span>。</p><p><span class="math display">\[ \sim B = \{ x \mid x \in E \wedge x\notin B \} \]</span></p><h3 id="例子-4">例子</h3><p>若 <span class="math inline">\(E = \{1, 2, 3, 4\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3\}\)</span>，则 <spanclass="math inline">\(\sim B = \{1, 4\}\)</span>。</p><h2 id="对称差">对称差</h2><p><span class="math display">\[ A \oplus B = \{ x \mid (x \in A \wedgex \notin B) \vee (x \notin A \wedge x \in B) \} \]</span></p><h3 id="例子-5">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3, 4\}\)</span>，则 <spanclass="math inline">\(A \oplus B = \{1, 4\}\)</span>。</p><h1 id="包含排斥原理">包含排斥原理</h1><p><span class="math display">\[ | A \cup B | = |A| + |B| - |A \cap B|\]</span> <span class="math display">\[ | A \cap B | = |A| + |B| - |A\cup B| \]</span> <span class="math display">\[ | A \cup B \cup C | =|A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \capC| \]</span> <span class="math display">\[ |A_1 \cup A_2 \cup \ldots\cup A_n| = \sum |A_i| - \sum |A_i \cap A_j| + \sum |A_i \cap A_j \capA_k| - \ldots + (-1)^{n+1} |A_1 \cap A_2 \cap \ldots \cap A_n|\]</span></p><h3 id="例子-6">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span> 和 <spanclass="math inline">\(B = \{2, 3, 4\}\)</span>，则 <spanclass="math display">\[ |A \cup B| = 3 + 3 - 2 = 4 \]</span></p><h1 id="序偶">序偶</h1><p><span class="math inline">\(\langle a, b \rangle\)</span>有序的数字组合表示为序偶。</p><h3 id="例子-7">例子</h3><p>若 <span class="math inline">\(a = 1\)</span> 和 <spanclass="math inline">\(b = 2\)</span>，则 <spanclass="math inline">\(\langle a, b \rangle = \langle 1, 2\rangle\)</span>。</p><h1 id="笛卡尔积">笛卡尔积</h1><h2 id="定义">定义</h2><p><span class="math display">\[ A \times B = \{ \langle x, y \rangle\mid x \in A \wedge y \in B \} \]</span></p><h3 id="例子-8">例子</h3><p>若 <span class="math inline">\(A = \{1, 2\}\)</span> 和 <spanclass="math inline">\(B = \{a, b\}\)</span>，则 <spanclass="math display">\[ A \times B = \{ \langle 1, a \rangle, \langle 1,b \rangle, \langle 2, a \rangle, \langle 2, b \rangle \} \]</span></p><h2 id="运算性质">运算性质</h2><ul><li><span class="math inline">\(A \times \varnothing =\varnothing\)</span>，<span class="math inline">\(\varnothing \times A =\varnothing\)</span></li><li>不满足交换律和结合律</li><li>并和交运算满足分配律</li></ul><h1 id="关系及其表示">关系及其表示</h1><h2 id="关系的定义">关系的定义</h2><p>集合 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 的笛卡尔积 <spanclass="math inline">\(A \times B\)</span> 的任意子集称为 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的关系。常用符号 <spanclass="math inline">\(R\)</span> 表示。</p><h3 id="例子-9">例子</h3><p>若 <span class="math inline">\(A = \{1, 2\}\)</span> 和 <spanclass="math inline">\(B = \{a, b\}\)</span>，则 <spanclass="math inline">\(R = \{\langle 1, a \rangle, \langle 2, b\rangle\}\)</span> 是 <span class="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的一个关系。</p><h2 id="关系的表示方法">关系的表示方法</h2><ul><li><p>列表法：直接列出关系中的元素。例如，<span class="math inline">\(R= \{\langle 1, a \rangle, \langle 2, b \rangle\}\)</span>。</p></li><li><p>图示法：使用图表表示元素之间的关系。</p></li><li><p>矩阵法：用一个矩阵表示关系。例如，若 <spanclass="math inline">\(A = \{1, 2\}\)</span> 和 <spanclass="math inline">\(B = \{a, b\}\)</span>，关系 <spanclass="math inline">\(R\)</span> 可以表示为：</p><p>[</p><span class="math display">\[\begin{pmatrix}1 &amp; 0 \\0 &amp; 1\end{pmatrix}\]</span><p>] 其中 1 表示存在关系，0 表示不存在关系。</p></li></ul><h2 id="关系的性质">关系的性质</h2><ul><li>自反性：对所有 <span class="math inline">\(x \in A\)</span>，有<span class="math inline">\(\langle x, x \rangle \in R\)</span>。</li><li>对称性：对所有 <span class="math inline">\(x, y \in A\)</span>，如果<span class="math inline">\(\langle x, y \rangle \in R\)</span>，则<span class="math inline">\(\langle y, x \rangle \in R\)</span>。</li><li>传递性：对所有 <span class="math inline">\(x, y, z \inA\)</span>，如果 <span class="math inline">\(\langle x, y \rangle \inR\)</span> 和 <span class="math inline">\(\langle y, z \rangle \inR\)</span>，则 <span class="math inline">\(\langle x, z \rangle \inR\)</span>。</li></ul><h1 id="特殊的关系">特殊的关系</h1><h2 id="等价关系">等价关系</h2><p>如果关系 <span class="math inline">\(R\)</span>满足自反性、对称性和传递性，则称 <span class="math inline">\(R\)</span>是一个等价关系。</p><h3 id="例子-10">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，定义关系<span class="math inline">\(R\)</span> 为 <span class="math inline">\(R= \{\langle 1, 1 \rangle, \langle 2, 2 \rangle, \langle 3, 3 \rangle,\langle 1, 2 \rangle, \langle 2, 1 \rangle\}\)</span>，则 <spanclass="math inline">\(R\)</span> 是一个等价关系。</p><h2 id="偏序关系">偏序关系</h2><p>如果关系 <span class="math inline">\(R\)</span>满足自反性、反对称性（即 <span class="math inline">\(\langle x, y\rangle \in R\)</span> 和 <span class="math inline">\(\langle y, x\rangle \in R\)</span> 时有 <span class="math inline">\(x =y\)</span>），以及传递性，则称 <span class="math inline">\(R\)</span>是一个偏序关系。</p><h3 id="例子-11">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，定义关系<span class="math inline">\(R\)</span> 为 <span class="math inline">\(R= \{\langle 1, 1 \rangle, \langle 2, 2 \rangle, \langle 3, 3 \rangle,\langle 1, 2 \rangle, \langle 2, 3 \rangle\}\)</span>，则 <spanclass="math inline">\(R\)</span> 是一个偏序关系。</p><h2 id="全序关系">全序关系</h2><p>如果关系 <span class="math inline">\(R\)</span>是偏序关系，并且对所有 <span class="math inline">\(x, y \inA\)</span>，总有 <span class="math inline">\(\langle x, y \rangle \inR\)</span> 或 <span class="math inline">\(\langle y, x \rangle \inR\)</span>，则称 <span class="math inline">\(R\)</span>是一个全序关系。</p><h3 id="例子-12">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，定义关系<span class="math inline">\(R\)</span> 为 <span class="math inline">\(R= \{\langle 1, 1 \rangle, \langle 2, 2 \rangle, \langle 3, 3 \rangle,\langle 1, 2 \rangle, \langle 2, 1 \rangle, \langle 1, 3 \rangle,\langle 3, 1 \rangle, \langle 2, 3 \rangle, \langle 3, 2\rangle\}\)</span>，则 <span class="math inline">\(R\)</span>是一个全序关系。</p><h2 id="函数映射">函数（映射）</h2><h3 id="定义-1">定义</h3><p>若集合 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 之间的关系 <spanclass="math inline">\(R\)</span> 满足以下条件：</p><ol type="1"><li>对每个 <span class="math inline">\(a \in A\)</span>，存在唯一的<span class="math inline">\(b \in B\)</span> 使得 <spanclass="math inline">\(\langle a, b \rangle \in R\)</span>。</li></ol><p>则称 <span class="math inline">\(R\)</span> 是从 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的函数或映射，记作 <spanclass="math inline">\(f: A \to B\)</span>。</p><h3 id="函数的表示">函数的表示</h3><ul><li>图示法：用箭头或图示表示 <span class="math inline">\(A\)</span>中每个元素对应 <span class="math inline">\(B\)</span>中的唯一元素。</li><li>列表法：列出函数的值对。例如，<span class="math inline">\(f =\{\langle 1, a \rangle, \langle 2, b \rangle\}\)</span>。</li></ul><h3 id="例子-13">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，<spanclass="math inline">\(B = \{a, b, c\}\)</span>，定义函数 <spanclass="math inline">\(f: A \to B\)</span> 为 <spanclass="math inline">\(f(1) = a, f(2) = b, f(3) = c\)</span>。</p><h3 id="函数的性质">函数的性质</h3><ul><li>单射（注入）：如果对所有 <span class="math inline">\(x, y \inA\)</span>，<span class="math inline">\(f(x) = f(y)\)</span> 蕴含 <spanclass="math inline">\(x = y\)</span>，则称 <spanclass="math inline">\(f\)</span> 是单射。</li><li>满射（映射）：如果对每个 <span class="math inline">\(b \inB\)</span>，存在 <span class="math inline">\(a \in A\)</span> 使得 <spanclass="math inline">\(f(a) = b\)</span>，则称 <spanclass="math inline">\(f\)</span> 是满射。</li><li>双射（双射映射）：如果 <span class="math inline">\(f\)</span>既是单射又是满射，则称 <span class="math inline">\(f\)</span>是双射。</li></ul><h2 id="关系的矩阵表示">关系的矩阵表示</h2><p>关系 <span class="math inline">\(R\)</span> 可以表示为一个矩阵 <spanclass="math inline">\(M\)</span>，其中 <spanclass="math inline">\(M_{ij} = 1\)</span> 表示 <spanclass="math inline">\(\langle a_i, b_j \rangle \in R\)</span>，<spanclass="math inline">\(M_{ij} = 0\)</span> 表示 <spanclass="math inline">\(\langle a_i, b_j \rangle \notin R\)</span>。</p><h3 id="例子-14">例子</h3><p>若 <span class="math inline">\(A = \{1, 2\}\)</span> 和 <spanclass="math inline">\(B = \{a, b\}\)</span>，关系 <spanclass="math inline">\(R = \{\langle 1, a \rangle, \langle 2, b\rangle\}\)</span> 可以表示为矩阵：</p>[<span class="math display">\[\begin{pmatrix}1 &amp; 0 \\0 &amp; 1\end{pmatrix}\]</span><p>]</p><h2 id="关系的图示表示">关系的图示表示</h2><p>关系 <span class="math inline">\(R\)</span>也可以使用图表示，其中集合 <span class="math inline">\(A\)</span> 和<span class="math inline">\(B\)</span>的元素分别用点表示，关系用箭头连接。</p><h3 id="例子-15">例子</h3><p>若 <span class="math inline">\(A = \{1, 2\}\)</span> 和 <spanclass="math inline">\(B = \{a, b\}\)</span>，关系 <spanclass="math inline">\(R = \{\langle 1, a \rangle, \langle 2, b\rangle\}\)</span> 可以用如下图表示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>→ a<br><span class="hljs-symbol">2 </span>→ b<br></code></pre></td></tr></table></figure><h1 id="关系的运算">关系的运算</h1><h2 id="关系的合成">关系的合成</h2><p>设 <span class="math inline">\(R\)</span> 是 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的关系，<spanclass="math inline">\(S\)</span> 是 <spanclass="math inline">\(B\)</span> 到 <spanclass="math inline">\(C\)</span> 的关系，<spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的合成 <span class="math inline">\(S\circ R\)</span> 是 <span class="math inline">\(A\)</span> 到 <spanclass="math inline">\(C\)</span> 的关系，定义为：</p><p><span class="math display">\[ S \circ R = \{\langle a, c \rangle \mid\exists b \in B, \langle a, b \rangle \in R \text{ 且 } \langle b, c\rangle \in S\} \]</span></p><h3 id="例子-16">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, a \rangle, \langle 2,b \rangle\}\)</span> 和 <span class="math inline">\(S = \{\langle a, x\rangle, \langle b, y \rangle\}\)</span>，则 <spanclass="math inline">\(S \circ R = \{\langle 1, x \rangle, \langle 2, y\rangle\}\)</span>。</p><h2 id="关系的逆">关系的逆</h2><p>关系 <span class="math inline">\(R\)</span> 的逆 <spanclass="math inline">\(R^{-1}\)</span> 是将 <spanclass="math inline">\(R\)</span>中的所有有序对反转得到的关系，定义为：</p><p><span class="math display">\[ R^{-1} = \{\langle b, a \rangle \mid\langle a, b \rangle \in R\} \]</span></p><h3 id="例子-17">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, a \rangle, \langle 2,b \rangle\}\)</span>，则 <span class="math inline">\(R^{-1} = \{\langlea, 1 \rangle, \langle b, 2 \rangle\}\)</span>。</p><h2 id="关系的幂">关系的幂</h2><p>设 <span class="math inline">\(R\)</span> 是 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(A\)</span> 的关系，<spanclass="math inline">\(R\)</span> 的 <spanclass="math inline">\(n\)</span> 次幂 <spanclass="math inline">\(R^n\)</span> 是 <spanclass="math inline">\(R\)</span> 自身的 <spanclass="math inline">\(n\)</span> 次合成。</p><h3 id="例子-18">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, 2 \rangle, \langle 2,3 \rangle\}\)</span>，则 <span class="math inline">\(R^2 = R \circ R =\{\langle 1, 3 \rangle\}\)</span>。</p><h1 id="关系矩阵的运算">关系矩阵的运算</h1><h2 id="矩阵乘法">矩阵乘法</h2><p>关系的合成可以通过矩阵乘法来实现。设 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 分别为集合 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 之间的关系和集合 <spanclass="math inline">\(B\)</span> 和 <spanclass="math inline">\(C\)</span> 之间的关系，其对应的关系矩阵为 <spanclass="math inline">\(M_R\)</span> 和 <spanclass="math inline">\(M_S\)</span>，则 <span class="math inline">\(S\circ R\)</span> 的关系矩阵 <span class="math inline">\(M_{S \circR}\)</span> 为 <span class="math inline">\(M_R\)</span> 和 <spanclass="math inline">\(M_S\)</span> 的矩阵乘积。</p><h3 id="例子-19">例子</h3><p>若 <span class="math inline">\(M_R = \begin{pmatrix} 1 &amp; 0 \\ 0&amp; 1 \end{pmatrix}\)</span> 和 <span class="math inline">\(M_S =\begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\)</span>，则 <spanclass="math inline">\(M_{S \circ R} = M_R \times M_S = \begin{pmatrix} 0&amp; 1 \\ 1 &amp; 0 \end{pmatrix}\)</span>。</p><h2 id="矩阵的转置">矩阵的转置</h2><p>关系 <span class="math inline">\(R\)</span> 的逆 <spanclass="math inline">\(R^{-1}\)</span> 对应的关系矩阵是 <spanclass="math inline">\(R\)</span> 的关系矩阵的转置。设 <spanclass="math inline">\(M_R\)</span> 是关系 <spanclass="math inline">\(R\)</span> 的矩阵，则 <spanclass="math inline">\(M_{R^{-1}}\)</span> 是 <spanclass="math inline">\(M_R\)</span> 的转置。</p><h3 id="例子-20">例子</h3><p>若 <span class="math inline">\(M_R = \begin{pmatrix} 1 &amp; 0 \\ 0&amp; 1 \end{pmatrix}\)</span>，则 <spanclass="math inline">\(M_{R^{-1}} = M_R^T = \begin{pmatrix} 1 &amp; 0 \\0 &amp; 1 \end{pmatrix}\)</span>。</p><h1 id="关系的闭包">关系的闭包</h1><h2 id="自反闭包">自反闭包</h2><p>关系 <span class="math inline">\(R\)</span> 的自反闭包是包含 <spanclass="math inline">\(R\)</span> 的最小自反关系。记为 <spanclass="math inline">\(R \cup \Delta\)</span>，其中 <spanclass="math inline">\(\Delta = \{\langle x, x \rangle \mid x \inA\}\)</span>。</p><h3 id="例子-21">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, 2\rangle\}\)</span>，则 <span class="math inline">\(R\)</span>的自反闭包是 <span class="math inline">\(R \cup \{\langle 1, 1 \rangle,\langle 2, 2 \rangle\}\)</span>。</p><h2 id="对称闭包">对称闭包</h2><p>关系 <span class="math inline">\(R\)</span> 的对称闭包是包含 <spanclass="math inline">\(R\)</span> 的最小对称关系。记为 <spanclass="math inline">\(R \cup R^{-1}\)</span>，其中 <spanclass="math inline">\(R^{-1}\)</span> 是 <spanclass="math inline">\(R\)</span> 的逆。</p><h3 id="例子-22">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, 2\rangle\}\)</span>，则 <span class="math inline">\(R\)</span>的对称闭包是 <span class="math inline">\(R \cup \{\langle 2, 1\rangle\}\)</span>。</p><h2 id="传递闭包">传递闭包</h2><p>关系 <span class="math inline">\(R\)</span> 的传递闭包是包含 <spanclass="math inline">\(R\)</span> 的最小传递关系。记为 <spanclass="math inline">\(R^+\)</span>，可以通过不断将 <spanclass="math inline">\(R\)</span> 自身合成得到。</p><h3 id="例子-23">例子</h3><p>若 <span class="math inline">\(R = \{\langle 1, 2 \rangle, \langle 2,3 \rangle\}\)</span>，则 <span class="math inline">\(R\)</span>的传递闭包是 <span class="math inline">\(R \cup \{\langle 1, 3\rangle\}\)</span>。</p><h2 id="关系的闭包运算总结">关系的闭包运算总结</h2><p>为了得到关系 <span class="math inline">\(R\)</span>的自反、对称和传递闭包，可以使用以下步骤：</p><ol type="1"><li><strong>自反闭包</strong>：<span class="math inline">\(R \cup\Delta\)</span>，其中 <span class="math inline">\(\Delta = \{\langle x,x \rangle \mid x \in A\}\)</span>。</li><li><strong>对称闭包</strong>：<span class="math inline">\(R \cupR^{-1}\)</span>。</li><li><strong>传递闭包</strong>：不断将 <spanclass="math inline">\(R\)</span> 与自身合成，直到得到一个传递关系。</li></ol><h1 id="等价类与分解">等价类与分解</h1><h2 id="等价类">等价类</h2><p>设 <span class="math inline">\(R\)</span> 是集合 <spanclass="math inline">\(A\)</span> 上的等价关系。对任意 <spanclass="math inline">\(a \in A\)</span>，<spanclass="math inline">\(a\)</span> 的等价类是 <spanclass="math inline">\(A\)</span> 的一个子集，记为 <spanclass="math inline">\([a]\)</span>，定义为：</p><p><span class="math display">\[ [a] = \{ x \in A \mid \langle a, x\rangle \in R \} \]</span></p><h3 id="例子-24">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，<spanclass="math inline">\(R\)</span> 为等价关系 <spanclass="math inline">\(R = \{\langle 1, 1 \rangle, \langle 2, 2 \rangle,\langle 3, 3 \rangle, \langle 1, 2 \rangle, \langle 2, 1\rangle\}\)</span>，则 <span class="math inline">\(1\)</span> 的等价类为<span class="math inline">\([1] = \{1, 2\}\)</span>。</p><h2 id="集合的分解">集合的分解</h2><p>等价关系 <span class="math inline">\(R\)</span> 将集合 <spanclass="math inline">\(A\)</span>划分为若干个不相交的子集（等价类），这些子集的集合称为 <spanclass="math inline">\(A\)</span> 在 <spanclass="math inline">\(R\)</span> 下的分解。</p><h3 id="例子-25">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，<spanclass="math inline">\(R\)</span> 为等价关系 <spanclass="math inline">\(R = \{\langle 1, 1 \rangle, \langle 2, 2 \rangle,\langle 3, 3 \rangle, \langle 1, 2 \rangle, \langle 2, 1\rangle\}\)</span>，则 <span class="math inline">\(A\)</span> 在 <spanclass="math inline">\(R\)</span> 下的分解为 <spanclass="math inline">\(\{\{1, 2\}, \{3\}\}\)</span>。</p><h1 id="关系的运算性质">关系的运算性质</h1><h2 id="关系的合成的性质">关系的合成的性质</h2><ul><li>结合律：<span class="math inline">\((S \circ R) \circ T = S \circ (R\circ T)\)</span>。</li><li>单位元：集合 <span class="math inline">\(A\)</span> 上的恒等关系<span class="math inline">\(I_A = \{\langle x, x \rangle \mid x \inA\}\)</span> 是关系合成的单位元，即 <span class="math inline">\(R \circI_A = I_A \circ R = R\)</span> 对于任何 <spanclass="math inline">\(R\)</span>。</li></ul><h2 id="关系矩阵的性质">关系矩阵的性质</h2><ul><li>关系矩阵的合成对应矩阵乘法。</li><li>关系矩阵的逆对应矩阵的转置。</li></ul><h1 id="函数映射的特别类型">函数（映射）的特别类型</h1><h2 id="单射单一函数">单射（单一函数）</h2><p>若 <span class="math inline">\(f: A \to B\)</span>是一个函数，对任意的 <span class="math inline">\(x_1, x_2 \inA\)</span>，若 <span class="math inline">\(f(x_1) = f(x_2)\)</span>，则<span class="math inline">\(x_1 = x_2\)</span>，则称 <spanclass="math inline">\(f\)</span> 是单射。</p><h3 id="例子-26">例子</h3><p>若 <span class="math inline">\(f: \{1, 2\} \to \{a, b, c\}\)</span>定义为 <span class="math inline">\(f(1) = a, f(2) = b\)</span>，则 <spanclass="math inline">\(f\)</span> 是单射。</p><h2 id="满射映射">满射（映射）</h2><p>若 <span class="math inline">\(f: A \to B\)</span>是一个函数，对于任意的 <span class="math inline">\(y \inB\)</span>，存在 <span class="math inline">\(x \in A\)</span> 使得 <spanclass="math inline">\(f(x) = y\)</span>，则称 <spanclass="math inline">\(f\)</span> 是满射。</p><h3 id="例子-27">例子</h3><p>若 <span class="math inline">\(f: \{1, 2, 3\} \to \{a, b\}\)</span>定义为 <span class="math inline">\(f(1) = a, f(2) = b, f(3) =a\)</span>，则 <span class="math inline">\(f\)</span> 是满射。</p><h2 id="双射双射映射">双射（双射映射）</h2><p>若 <span class="math inline">\(f: A \to B\)</span> 是一个函数，且<span class="math inline">\(f\)</span> 既是单射又是满射，则称 <spanclass="math inline">\(f\)</span> 是双射。</p><h3 id="例子-28">例子</h3><p>若 <span class="math inline">\(f: \{1, 2\} \to \{a, b\}\)</span>定义为 <span class="math inline">\(f(1) = a, f(2) = b\)</span>，则 <spanclass="math inline">\(f\)</span> 是双射。</p><h2 id="反函数">反函数</h2><p>若 <span class="math inline">\(f: A \to B\)</span>是双射，则存在一个函数 <span class="math inline">\(g: B \toA\)</span>，使得对所有 <span class="math inline">\(x \in A\)</span> 和<span class="math inline">\(y \in B\)</span> 有 <spanclass="math inline">\(g(f(x)) = x\)</span> 和 <spanclass="math inline">\(f(g(y)) = y\)</span>，则 <spanclass="math inline">\(g\)</span> 称为 <spanclass="math inline">\(f\)</span> 的反函数，记作 <spanclass="math inline">\(f^{-1}\)</span>。</p><h3 id="例子-29">例子</h3><p>若 <span class="math inline">\(f: \{1, 2\} \to \{a, b\}\)</span>定义为 <span class="math inline">\(f(1) = a, f(2) = b\)</span>，则 <spanclass="math inline">\(f^{-1}: \{a, b\} \to \{1, 2\}\)</span> 定义为<span class="math inline">\(f^{-1}(a) = 1, f^{-1}(b) = 2\)</span>。</p><h1 id="特殊的关系-1">特殊的关系</h1><h2 id="序关系">序关系</h2><p>如果关系 <span class="math inline">\(R\)</span>满足自反性、反对称性、传递性，则称 <spanclass="math inline">\(R\)</span> 是一个偏序关系。如果 <spanclass="math inline">\(R\)</span> 还满足全序性，即对于任意的 <spanclass="math inline">\(x, y \in A\)</span>，总有 <spanclass="math inline">\(xRy\)</span> 或 <spanclass="math inline">\(yRx\)</span>，则 <spanclass="math inline">\(R\)</span> 是一个全序关系。</p><h3 id="例子-30">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，定义 <spanclass="math inline">\(R = \{\langle 1, 1 \rangle, \langle 2, 2 \rangle,\langle 3, 3 \rangle, \langle 1, 2 \rangle, \langle 1, 3 \rangle,\langle 2, 3 \rangle\}\)</span>，则 <spanclass="math inline">\(R\)</span> 是一个全序关系。</p><h2 id="等价关系-1">等价关系</h2><p>如果关系 <span class="math inline">\(R\)</span>满足自反性、对称性、传递性，则称 <span class="math inline">\(R\)</span>是一个等价关系。等价关系将集合划分为若干不相交的等价类。</p><h3 id="例子-31">例子</h3><p>若 <span class="math inline">\(A = \{1, 2, 3\}\)</span>，定义 <spanclass="math inline">\(R = \{\langle 1, 1 \rangle, \langle 2, 2 \rangle,\langle 3, 3 \rangle, \langle 1, 2 \rangle, \langle 2, 1\rangle\}\)</span>，则 <span class="math inline">\(R\)</span>是一个等价关系，并将 <span class="math inline">\(A\)</span> 划分为等价类<span class="math inline">\(\{\{1, 2\}, \{3\}\}\)</span>。</p><h2 id="函数的关系表示">函数的关系表示</h2><p>函数可以看作一种特殊的关系，其中每个输入与唯一的输出相关联。函数<span class="math inline">\(f: A \to B\)</span> 作为关系的表示可以写成<span class="math inline">\(R_f = \{\langle x, f(x) \rangle \mid x \inA\}\)</span>。</p><h3 id="例子-32">例子</h3><p>若 <span class="math inline">\(f: \{1, 2\} \to \{a, b\}\)</span>定义为 <span class="math inline">\(f(1) = a, f(2) = b\)</span>，则 <spanclass="math inline">\(R_f = \{\langle 1, a \rangle, \langle 2, b\rangle\}\)</span>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2024/05/02/git/"/>
    <url>/2024/05/02/git/</url>
    
    <content type="html"><![CDATA[<p>放一些git常用命令 <img src="image.png" alt="git基本流程" /><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git config <span class="hljs-comment">--global user.name &quot;&quot;</span><br>git config <span class="hljs-comment">--global user.email &quot;&quot;</span><br>git init<br>git status<br>git <span class="hljs-built_in">add</span> &lt;<span class="hljs-built_in">file</span>&gt;<br>git commit -m <span class="hljs-string">&quot;text&quot;</span><br>git clone &lt;repo&gt;<br>git reset HEAD &lt;<span class="hljs-built_in">file</span>&gt;<span class="hljs-comment"> // 将文件从暂存区移除，但保留在工作目录中</span><br>git reset HEAD<br>git reset <span class="hljs-comment">--hard HEAD^ // 回退到某次提交，会对工作目录产生影响</span><br>git reset <span class="hljs-comment">--soft HEAD^ // 回退到某次提交，不会对暂存区和工作目录产生影响</span><br>git reset <span class="hljs-comment">--mixed HEAD^ // 回退到某次提交，对暂存区产生影响，但是不影响工作目录</span><br>git checkout HEAD^   <span class="hljs-comment"> // 将 HEAD 指针移动到当前分支的上一个提交，并将工作目录中的文件状态更新为该提交时的状态。分支状态无影响</span><br>git checkout <span class="hljs-comment"> // 分支切换</span><br>git checkout <span class="hljs-comment">-- &lt;file&gt; //撤销对文件的修改，将其恢复到最后一次提交的状态，并将其从暂存区移除。</span><br>git branch &lt;name&gt;   <span class="hljs-comment"> // 新建</span><br>git branch -b &lt;name&gt;<span class="hljs-comment"> // 新建并切换</span><br>git branch -d &lt;name&gt;<span class="hljs-comment"> // 删除分支</span><br>git <span class="hljs-built_in">merge</span> &lt;name&gt;    <span class="hljs-comment"> // 将分支合并到当前分支</span><br>git tag &lt;<span class="hljs-keyword">text</span>&gt;      <span class="hljs-comment"> // 标签</span><br>git tag -<span class="hljs-keyword">a</span> &lt;<span class="hljs-keyword">text</span>&gt;   <span class="hljs-comment"> // 带注解的标签</span><br>git restore<span class="hljs-comment"> // 恢复或撤销文件的更改</span><br>git diff         <span class="hljs-comment"> // 查看工作区与暂存区之间的差异</span><br>git diff <span class="hljs-comment">--cached // 查看暂存区和最后一次提交的差异</span><br>git rm<span class="hljs-comment"> //将文件从暂存区和工作区删除</span><br>git <span class="hljs-built_in">log</span><span class="hljs-comment"> // 提交历史记录</span><br>git blame &lt;<span class="hljs-built_in">file</span>&gt;<span class="hljs-comment"> // 文件修改历史记录</span><br>git remote <span class="hljs-built_in">add</span> &lt;shortname&gt; &lt;repo&gt;<br>git fetch<span class="hljs-comment"> // 下载但需手动合并</span><br>git pull <span class="hljs-comment"> // 下载并合并</span><br>git push &lt;remote&gt; &lt;branch&gt;<span class="hljs-comment"> // branch名相同</span><br>git push &lt;remote&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;<br>git push -u<span class="hljs-comment"> // 提交并建立关联</span><br>git push -f<span class="hljs-comment"> // 强制提交，覆盖</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note - Ubuntu</title>
    <link href="/2024/05/02/Ubuntu/"/>
    <url>/2024/05/02/Ubuntu/</url>
    
    <content type="html"><![CDATA[<h1 id="更新系统时间">更新系统时间</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><h1 id="修改主机名">修改主机名</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hostname<br>vim /etc/hosts<br></code></pre></td></tr></table></figure><h1 id="修改root密码">修改root密码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd<br></code></pre></td></tr></table></figure><h1 id="修改静态-ip">修改静态 IP</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmtui <span class="hljs-comment">#注意设置DNS</span><br></code></pre></td></tr></table></figure><h1 id="挂载-ntfs-硬盘">挂载 NTFS 硬盘</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -t ntfs-3g /dev/sda3 /mnt/pssd<br></code></pre></td></tr></table></figure><h1 id="开机自动挂载-ntfs-硬盘">开机自动挂载 NTFS 硬盘</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/fstab<br>/dev/sda3 /mnt ntfs-3g defaults 0 0<br></code></pre></td></tr></table></figure><h1 id="系统监控软件">系统监控软件</h1><h2 id="s-tui"><a href="https://github.com/amanusk/s-tui">s-tui</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install python3-pip python3-dev -y<br>pip3 install s-tui<br></code></pre></td></tr></table></figure><h1 id="更新显卡驱动">更新显卡驱动</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ubuntu-drivers devices<br><span class="hljs-built_in">sudo</span> apt install autoinstall  // 不推荐<br></code></pre></td></tr></table></figure><p>或者 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install [drivers-name]<br><span class="hljs-built_in">sudo</span> reboot<br></code></pre></td></tr></table></figure> 然后 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi<br></code></pre></td></tr></table></figure></p><h1 id="多显示器">多显示器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install xrandr<br></code></pre></td></tr></table></figure><h1 id="关闭屏幕边缘粘滞">关闭屏幕边缘粘滞</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gsettings list-recursively org.gnome.shell.overrides<br>gsettings <span class="hljs-built_in">set</span> org.gnome.shell.overrides edge-tiling <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="ubuntu-22.04-lts-安装cuda">Ubuntu 22.04 LTS 安装Cuda</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600<br>wget https://developer.download.nvidia.com/compute/cuda/12.2.0/local_installers/cuda-repo-ubuntu2204-12-2-local_12.2.0-535.54.03-1_amd64.deb<br><span class="hljs-built_in">sudo</span> dpkg -i cuda-repo-ubuntu2204-12-2-local_12.2.0-535.54.03-1_amd64.deb<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> /var/cuda-repo-ubuntu2204-12-2-<span class="hljs-built_in">local</span>/cuda-*-keyring.gpg /usr/share/keyrings/<br><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get -y install cuda<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note - 空间几何</title>
    <link href="/2024/05/02/Space-Geometry/"/>
    <url>/2024/05/02/Space-Geometry/</url>
    
    <content type="html"><![CDATA[<h1 id="向量">向量</h1><h2 id="数量积">数量积</h2><h3 id="定义">定义</h3><p>设 <span class="math inline">\(a, b\)</span> 是两个几何向量，称 <spanclass="math inline">\(\left\vert a\right\vert \left\vert b\right\vert\cos\theta\)</span> 为 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span>的<strong>数量积</strong>或<strong>内积</strong>，记作 <spanclass="math inline">\(a \cdot b\)</span>，即 <spanclass="math display">\[a \cdot b = \left\vert a\right\vert \left\vertb\right\vert \cos\theta\]</span></p><h3 id="性质">性质</h3><ul><li><span class="math inline">\(a \cdot b = b \cdota\)</span>（交换律）</li><li><span class="math inline">\((ka) \cdot b = k(a \cdotb)\)</span></li><li><span class="math inline">\((a + b) \cdot c = a \cdot c + b \cdotc\)</span>（分配律）</li><li><span class="math inline">\(a \cdot a \ge 0\)</span>。此外，<spanclass="math inline">\(a \cdot a = 0\)</span> 的充要条件是 <spanclass="math inline">\(a = 0\)</span>。</li></ul><h2 id="向量积">向量积</h2><h3 id="定义-1">定义</h3><p>若 <span class="math inline">\(a, b\)</span> 不平行，则 - <spanclass="math inline">\(\left\vert a \times b\right\vert = \left\verta\right\vert \left\vert b\right\vert \sin\theta\)</span> - <spanclass="math inline">\(a \times b \perp a, a \times b \perp b\)</span> -向量 <span class="math inline">\(a, b, a \times b\)</span>构成右手系</p><h3 id="性质-1">性质</h3><ul><li><span class="math inline">\(a \times b = -b \times a\)</span></li><li><span class="math inline">\((ka)\times b = k(a\times b) = a \times(kb)\)</span></li><li><span class="math inline">\((a + b) \times c = (a \times c) + (b\times c)\\a \times (b + c) = (a \times b) + (a \times c)\)</span></li></ul><h2 id="混合积">混合积</h2><h3 id="定义-2">定义</h3><p>已知三个向量 <span class="math inline">\(a, b\)</span> 和 <spanclass="math inline">\(c\)</span>。先作 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的向量积 <span class="math inline">\(a\times b\)</span>，把所得的向量与 <span class="math inline">\(c\)</span>再作数量积 <span class="math inline">\((a \times b) \cdotc\)</span>，这样得到的数量叫做三向量 <span class="math inline">\(a, b,c\)</span> 的<strong>混合积</strong>，记为 <spanclass="math inline">\(\left[abc\right]\)</span>。</p><p>向量的混合积有如下几何意义：<spanclass="math inline">\(\left[abc\right] = (a \times b) \cdot c\)</span>的绝对值表示以向量 <span class="math inline">\(a, b, c\)</span>为棱的平行六面体的体积。如果向量 <span class="math inline">\(a, b,c\)</span> 组成右手系，那么混合积的符号是正的；如果 <spanclass="math inline">\(a, b, c\)</span>组成左手系，那么混合积的符号是负的。</p><h3 id="性质-2">性质</h3><p><span class="math display">\[ \left[abc\right] = 0 \Leftrightarrowa,b,c\ 共面\]</span> <span class="math display">\[\left[abc\right] =\left[bca\right] = \left[cab\right] = -\left[bac\right] =-\left[cba\right] = -\left[acb\right]\]</span> 设 <spanclass="math inline">\(a = (a_x, a_y, a_z), b = (b_x, b_y, b_z), c =(c_x, c_y, c_z)\)</span>，则 <span class="math display">\[[abc] =\begin{vmatrix}a_x &amp; a_y &amp; a_z \\b_x &amp; b_y &amp; b_z \\c_x &amp; c_y &amp; c_z\end{vmatrix}\]</span> # 空间中的平面与直线</p><h2 id="平面">平面</h2><p>设平面 <span class="math inline">\(\pi\)</span> 通过点 <spanclass="math inline">\(M_0(x_0, y_0, z_0)\)</span> 并且垂直于非零向量<span class="math inline">\(n = (A, B, C)\)</span>，则平面 <spanclass="math inline">\(\pi\)</span> 的<strong>点法式方程</strong>为：<span class="math display">\[A(x - x_0) + B(y - y_0) + C(z - z_0) =0\]</span> 将其整理得 <span class="math display">\[Ax + By + Cz + D =0\]</span> 其中 <span class="math inline">\(D = -(Ax_0 + By_0 +Cz_0)\)</span>，称其为平面 <span class="math inline">\(\pi\)</span>的<strong>一般方程</strong></p><p>设 <span class="math inline">\(M_1(x_1, y_1, z_1), M_2(x_2, y_2,z_2), M_3(x_3, y_3, z_3)\)</span> 是空间中不在同一条直线上的三点，则称<span class="math display">\[\begin{vmatrix}x - x_1 &amp; y - y_1 &amp; z - z_1\\x_2 - x_1 &amp; y_2 - y_1 &amp; z_2 - z_1\\x_3 - x_1 &amp; y_3 - y_1 &amp; z_3 - z_1\end{vmatrix}= 0\]</span> 为平面 <span class="math inline">\(\pi\)</span>的<strong>三点式方程</strong>。</p><p>设平面 <span class="math inline">\(\pi\)</span> 与 <spanclass="math inline">\(x, y, z\)</span> 轴分别交于 <spanclass="math inline">\(P(a, 0, 0), Q(0, b, 0), R(0, 0, c)\)</span>，则称<span class="math display">\[\frac{x}{a} + \frac{y}{b} + \frac{z}{c} =1\]</span> 为平面 <span class="math inline">\(\pi\)</span>的<strong>截距式方程</strong>。</p><h2 id="直线">直线</h2><p>设直线 <span class="math inline">\(L\)</span> 过点 <spanclass="math inline">\(M_0(x_0, y_0,z_0)\)</span>，并且平行于已知非零向量 <span class="math inline">\(s =(m, n, p)\)</span>，则称 <span class="math display">\[\frac{x - x_0}{m}= \frac{y - y_0}{n} = \frac{z - z_0}{p}\]</span> 为直线 <spanclass="math inline">\(L\)</span> 的<strong>标准方程</strong>。</p><p>令其比值为 <span class="math inline">\(t\)</span>，则称 <spanclass="math display">\[\begin{cases}x = x_0 + mt \\y = y_0 + nt \\z = z_0 + pt\end{cases}\]</span> 为直线 <span class="math inline">\(L\)</span>的<strong>参数方程</strong>。</p><p>设平面 <span class="math inline">\(\pi_1, \pi_2\)</span> 为 <spanclass="math display">\[\pi_1 : A_1x + B_1y + C_1z + D_1 = 0\\\pi_2 : A_2x + B_2y + C_2z + D_2 = 0\]</span> 若 <spanclass="math inline">\(\pi_1, \pi_2\)</span> 的交线为直线 <spanclass="math inline">\(L\)</span>，则称 <spanclass="math display">\[\begin{cases}A_1x + B_1y + C_1z + D_1 = 0\\A_2x + B_2y + C_2z + D_2 = 0\end{cases}\]</span> 为直线 <span class="math inline">\(L\)</span>的<strong>一般方程</strong>。</p><p>设直线 <span class="math inline">\(L\)</span> 过点 <spanclass="math inline">\(M_0(x_0, y_0, z_0)\)</span> 和点 <spanclass="math inline">\(M_1(x_1, y_1, z_1)\)</span>，则称 <spanclass="math display">\[\frac{x - x_0}{x_1 - x_0} = \frac{y - y_0}{y_1 -y_0} = \frac{z - z_0}{z_1 - z_0}\]</span> 为直线 <spanclass="math inline">\(L\)</span> 的<strong>二点式方程</strong>。</p><h1 id="位置关系">位置关系</h1><h2 id="平面与平面">平面与平面</h2><p>设有两个平面 <span class="math display">\[\pi_1 : A_1x + B_1y + C_1z + D_1 = 0 \\\pi_2 : A_2x + B_2y + C_2z + D_2 = 0\]</span> 可将 <span class="math inline">\(\pi_1, \pi_2\)</span>的位置关系分为如下三种情形。</p><ol type="1"><li><span class="math inline">\(\pi_1, \pi_2\)</span> 重合。其充要条件是<span class="math display">\[\frac{A_1}{A_2} = \frac{B_1}{B_2} = \frac{C_1}{C_2} = \frac{D_1}{D_2}\]</span></li><li><span class="math inline">\(\pi_1, \pi_2\)</span>平行（不包括重合）。其充要条件是 <span class="math display">\[\frac{A_1}{A_2} = \frac{B_1}{B_2} = \frac{C_1}{C_2} \ne \frac{D_1}{D_2}\]</span></li><li><span class="math inline">\(\pi_1, \pi_2\)</span>交于一条直线。其充要条件是 <span class="math inline">\(n_1 = (A_1, B_1,C_1)\)</span> 与 <span class="math inline">\(n_2 = (A_2, B_2,C_2)\)</span> 不平行。</li></ol><p>当 <span class="math inline">\(\pi_1, \pi_2\)</span>是两个相交的平面时，称它们的法向量的夹角 <spanclass="math inline">\(\varphi\)</span> 为这两个平面的夹角，通常规定<span class="math display">\[0 \le \varphi \le \frac{\pi}{2}\]</span>平面 <span class="math inline">\(\pi_1\)</span> 与 <spanclass="math inline">\(\pi_2\)</span> 的夹角 <spanclass="math inline">\(\varphi\)</span> 可由公式 <spanclass="math display">\[\cos\varphi = \frac{\left\vert A_1A_2 + B_1B_2 + C_1C_2\right\vert}{\sqrt{A_1^2 + B_1^2 + C_1^2}\sqrt{A_2^2 + B_2^2 + C_2^2}}\]</span> 来确定。</p><p>显然，<span class="math inline">\(\pi_1\)</span> 与 <spanclass="math inline">\(\pi_2\)</span> 垂直的充要条件时它们的法向量 <spanclass="math inline">\(n_1\)</span> 与 <spanclass="math inline">\(n_2\)</span> 垂直，即 <spanclass="math display">\[A_1A_2 + B_1B_2 + C_1C_2 = 0\]</span></p><h2 id="直线与直线">直线与直线</h2><p>设有两条直线 <span class="math display">\[L_1 : \frac{x - x_1}{m_1} = \frac{y - y_1}{n_1} = \frac{z - z_1}{p_1}\\L_2 : \frac{x - x_2}{m_2} = \frac{y - y_2}{n_2} = \frac{z - z_2}{p_2}\]</span> <span class="math inline">\(M_1(x_1, y_1, z_1), M_2(x_2, y_2,z_2)\)</span> 分别是 <span class="math inline">\(L_1, L_2\)</span>上的定点。<span class="math inline">\(s_1=(m_1, n_1, p_1), s_2=(m_2,n_2, p_2)\)</span> 分别是 <span class="math inline">\(L_1, L_2\)</span>的方向向量。</p><p>可将 <span class="math inline">\(L_1, L_2\)</span>的位置关系分成如下四种情形 1. <span class="math inline">\(L_1,L_2\)</span> 重合。其充要条件是 <span class="math display">\[\frac{m_1}{m_2} = \frac{n_1}{n_2} = \frac{p_1}{p_2}\]</span> 且 <span class="math inline">\(M_1 \in L_2 \ (M_2 \inL_1)\)</span>，即 <span class="math display">\[\frac{x_1 - x_2}{m_2} = \frac{y_1 - y_2}{n_2} = \frac{z_1 - z_2}{p_2}\]</span> 2. <span class="math inline">\(L_1, L_2\)</span>平行（不包括重合）。其充要条件是 <span class="math display">\[\frac{m_1}{m_2} = \frac{n_1}{n_2} = \frac{p_1}{p_2}\]</span> 且 <span class="math inline">\(M_1 \notin L_2 \ (M_2 \notinL_1)\)</span>，即 <span class="math display">\[\frac{x_1 - x_2}{m_2} = \frac{y_1 - y_2}{n_2} = \frac{z_1 - z_2}{p_2}\]</span> 不成立。</p><ol start="3" type="1"><li><p><span class="math inline">\(L_1, L_2\)</span>交于一点。其充要条件是混合积 <spanclass="math inline">\(\left[s_1s_2\overrightarrow{M_1M_2}\right] =0\)</span> 且 <span class="math inline">\(s_1s_2\)</span>不平行。</p></li><li><p><span class="math inline">\(L_1, L_2\)</span>是异面直线。其充要条件是混合积 <spanclass="math inline">\(\left[s_1s_2\overrightarrow{M_1M_2}\right] \ne0\)</span>。</p></li></ol><p>我们规定 <span class="math inline">\(L_1, L_2\)</span> 的方向向量<span class="math inline">\(s_1, s_2\)</span> 的夹角 <spanclass="math inline">\(\varphi\)</span> 为这两条直线的夹角。通常规定<span class="math inline">\(0 \le \varphi \le\frac{\pi}{2}\)</span>。</p><p>直线 <span class="math inline">\(L_1, L_2\)</span> 的夹角 <spanclass="math inline">\(\varphi\)</span> 可由公式 <spanclass="math display">\[\cos\varphi = \frac{\left\vert s_1 \cdot s_2\right\vert}{\left\verts_1\right\vert \left\vert s_2 \right\vert}\]</span> 来确定。</p><p>显然，<span class="math inline">\(L_1\)</span> 与 <spanclass="math inline">\(L_2\)</span> 垂直的充要条件是 <spanclass="math inline">\(s_1\)</span> 与 <spanclass="math inline">\(s_2\)</span> 垂直，即 <spanclass="math display">\[s_1 \cdot s_2 = m_1m_2 + n_1n_2 + p_1p_2 = 0\]</span></p><h2 id="直线与平面">直线与平面</h2><p>设有一条直线 <span class="math display">\[L : \frac{x - x_0}{m} = \frac{y - y_0}{n} = \frac{z - z_0}{p}\]</span> 及一个平面 <span class="math display">\[\pi : Ax + By + Cz + D = 0\]</span> 可将 <span class="math inline">\(L, \pi\)</span>的位置关系分成如下三种情形。 1. <span class="math inline">\(L\)</span>在 <span class="math inline">\(\pi\)</span> 上。其充要条件是 <spanclass="math inline">\(s = (m, n, p)\)</span> 与 <spanclass="math inline">\(n = (A, B, C)\)</span> 垂直，且 <spanclass="math inline">\(M_0 \in \pi\)</span>，即 <spanclass="math display">\[\begin{cases}mA + nB + pC = 0\\Ax_0 + By_0 + Cz_0 + D = 0\end{cases}\]</span> 2. <span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(\pi\)</span> 平行（不包括 <spanclass="math inline">\(L\)</span> 在 <spanclass="math inline">\(\pi\)</span> 上的情形）。其充要条件是 <spanclass="math inline">\(s = (m, n, p)\)</span> 与 <spanclass="math inline">\(n = (A, B, C)\)</span> 垂直，且 <spanclass="math inline">\(M_0 \notin \pi\)</span>，即 <spanclass="math display">\[mA + nB + pC = 0\]</span> 且 <spanclass="math display">\[Ax_0 + By_0 + Cz_0 + D \ne 0\]</span> 3. <spanclass="math inline">\(L\)</span> 与 <spanclass="math inline">\(\pi\)</span> 交于一点。其充要条件是 <spanclass="math inline">\(s = (m, n, p)\)</span> 与 <spanclass="math inline">\(n = (A, B, C)\)</span> 不垂直，即 <spanclass="math display">\[mA + nB + pC \ne 0\]</span> 直线 <spanclass="math inline">\(L\)</span> 与其在平面 <spanclass="math inline">\(\pi\)</span> 上的投影直线 <spanclass="math inline">\(L_1\)</span> 的夹角 <spanclass="math inline">\(\varphi\)</span> 称为<strong>直线 <spanclass="math inline">\(L\)</span> 与平面 <spanclass="math inline">\(\pi\)</span> 的夹角</strong>，通常规定 <spanclass="math inline">\(0 \le \varphi \le \frac{\pi}{2}\)</span>。</p><p><span class="math inline">\(\varphi\)</span> 可由公式 <spanclass="math display">\[\sin\varphi = \frac{\left\vert s \cdot n \right\vert}{\left\vert s\right\vert \left\vert n \right\vert}\]</span> 确定。显然，<span class="math inline">\(L\)</span> 与 <spanclass="math inline">\(\pi\)</span> 垂直的充要条件是 <spanclass="math inline">\(n\)</span> 与 <spanclass="math inline">\(s\)</span> 平行，即 <span class="math display">\[\frac{A}{m} = \frac{B}{n} = \frac{C}{p}\]</span></p><h1 id="距离">距离</h1><h2 id="点到平面">点到平面</h2><p>设 <span class="math inline">\(M_0(x_0, y_0, z_0)\)</span> 是平面<span class="math inline">\(\pi : Ax + By + Cz + D = 0\)</span>外一点。在平面 <span class="math inline">\(\pi\)</span> 上任取一点 <spanclass="math inline">\(M_1(x_1, y_1, z_1)\)</span>，取平面 <spanclass="math inline">\(\pi\)</span> 的法向量 <spanclass="math inline">\(n = (A, B, C)\)</span>，则点 <spanclass="math inline">\(M_0\)</span> 到平面 <spanclass="math inline">\(\pi\)</span> 的距离 <spanclass="math inline">\(d\)</span> 为 <span class="math display">\[d =\frac{\left\vert n \cdot \overrightarrow{M_0M_1} \right\vert}{\left\vertn \right\vert} \]</span></p><h2 id="两平行平面">两平行平面</h2><p>可以转化为点到平面间的距离</p><h2 id="直线到其平行的平面">直线到其平行的平面</h2><p>可以转化为点到平面间的距离</p><h2 id="点到直线">点到直线</h2><p>设直线 <span class="math inline">\(L\)</span> 的标准方程为 <spanclass="math display">\[L : \frac{x - x_0}{m} = \frac{y - y_0}{n} = \frac{z - z_0}{p}\]</span> 即 <span class="math inline">\(L\)</span> 过点 <spanclass="math inline">\(M_0(x_0, y_0, z_0)\)</span>，并且方向向量为 <spanclass="math inline">\(s = (m, n, p)\)</span>。再设 <spanclass="math inline">\(M_1(x_1, y_1, z_1)\)</span> 是直线 <spanclass="math inline">\(L\)</span> 外一点，则点 <spanclass="math inline">\(M_1\)</span> 到直线 <spanclass="math inline">\(L\)</span> 的距离 <spanclass="math inline">\(d\)</span> 为 <span class="math display">\[d = \frac{\left\vert s \times\overrightarrow{M_0M_1}\right\vert}{\left\vert s\right\vert}\]</span></p><h2 id="两平行直线">两平行直线</h2><p>可以转化为点到直线间的距离</p><h2 id="两异面直线">两异面直线</h2><p>设由两条异面直线： <span class="math display">\[L_1 : \frac{x - x_1}{m_1} = \frac{y - y_1}{n_1} = \frac{z - z_1}{p_1}\\L_2 : \frac{x - x_2}{m_2} = \frac{y - y_2}{n_2} = \frac{z - z_2}{p_2}\]</span> 记 <span class="math inline">\(P_1(x_1, y_1, z_1), P_2(x_2,y_2, z_2)\)</span> 分别是 <span class="math inline">\(L_1, L_2\)</span>上的点。<span class="math inline">\(L_1, L_2\)</span> 的方向向量 <spanclass="math inline">\(s_1 = (m_1, n_1, p_1)\)</span>，<spanclass="math inline">\(s_2 = (m_2, n_2, p_2)\)</span> 分别与 <spanclass="math inline">\(L_1, L_2\)</span> 的公垂线垂直，所以 <spanclass="math inline">\(s_1 \times s_2\)</span> 是 <spanclass="math inline">\(L_1, L_2\)</span> 的公垂线的方向向量。</p><p><span class="math inline">\(\overrightarrow{P_1P_2}\)</span> 在 <spanclass="math inline">\(s_1 \times s_2\)</span> 上的投影的绝对值就是 <spanclass="math inline">\(L_1\)</span> 与 <spanclass="math inline">\(L_2\)</span> 之间的距离 <spanclass="math inline">\(d\)</span>，即 <span class="math display">\[d = \left\vert \overrightarrow{P_1P_2} \cdot \frac{s_1 \timess_2}{\left\vert s_1 \times s_2 \right\vert} \right\vert\]</span></p><h1 id="平面束">平面束</h1><p>称通过给定直线 <span class="math inline">\(L\)</span>的所有平面的全体为通过直线 <span class="math inline">\(L\)</span>的<strong>平面束</strong>。</p><p>设 <span class="math inline">\(L\)</span> 的一般方程为 <spanclass="math display">\[\begin{cases}A_1x + B_1y + C_1z + D_1 = 0\\A_2x + B_2y + C_2z + D_2 = 0\end{cases}\]</span> 其中系数 <span class="math inline">\(A_1, B_1, C_1\)</span> 与<span class="math inline">\(A_2, B_2, C_2\)</span> 不成比例。则称方程<span class="math display">\[A_1x + B_1y + C_1z + D_1 + \lambda(A_2x + B_2y + C_2z + D_2) = 0\]</span> 为通过直线 <span class="math inline">\(L\)</span>的<strong>平面束方程</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note - 矩阵</title>
    <link href="/2024/05/02/Martix/"/>
    <url>/2024/05/02/Martix/</url>
    
    <content type="html"><![CDATA[<h1 id="分块矩阵">分块矩阵</h1><h2 id="加法">加法</h2><p>设 <spanclass="math inline">\(A=\begin{pmatrix}A_{11}&amp;\cdots&amp;A_{1t}\\\vdots&amp;\ddots&amp;\vdots\\A_{s1}&amp;\cdots&amp;A_{st}\end{pmatrix}\)</span>，<span class="math inline">\(B =\begin{pmatrix}B_{11}&amp;\cdots&amp;B_{1t}\\\vdots&amp;\ddots&amp;\vdots\\B_{s1}&amp;\cdots&amp;B_{st}\end{pmatrix}\)</span>，则<span class="math display">\[A + B = \begin{pmatrix}A_{11} +B_{11}&amp;\cdots&amp;A_{1t}+B_{1t}\\\vdots&amp;\ddots&amp;\vdots\\A_{s1}+B_{s1}&amp;\cdots&amp;A_{st}+B_{st}\end{pmatrix}\]</span></p><h2 id="数乘">数乘</h2><p>设 <spanclass="math inline">\(A=\begin{pmatrix}A_{11}&amp;\cdots&amp;A_{1t}\\\vdots&amp;\ddots&amp;\vdots\\A_{s1}&amp;\cdots&amp;A_{st}\end{pmatrix}\)</span>，则<span class="math display">\[kA =\begin{pmatrix}kA_{11}&amp;\cdots&amp;kA_{1t}\\\vdots&amp;\ddots&amp;\vdots\\kA_{s1}&amp;\cdots&amp;kA_{st}\end{pmatrix}\]</span></p><h2 id="乘法">乘法</h2><p>设 <spanclass="math inline">\(A=\begin{pmatrix}A_{11}&amp;\cdots&amp;A_{1t}\\\vdots&amp;\ddots&amp;\vdots\\A_{s1}&amp;\cdots&amp;A_{st}\end{pmatrix}\)</span>，<spanclass="math inline">\(B =\begin{pmatrix}B_{11}&amp;\cdots&amp;B_{1r}\\\vdots&amp;\ddots&amp;\vdots\\B_{t1}&amp;\cdots&amp;B_{tr}\end{pmatrix}\)</span>，则<span class="math display">\[AB =\begin{pmatrix}C_{11}&amp;\cdots&amp;C_{1r}\\\vdots&amp;\ddots&amp;\vdots\\C_{s1}&amp;\cdots&amp;C_{sr}\end{pmatrix}\]</span>其中 <spanclass="math inline">\(C_{ij}=\sum_{k=1}^tA_{ik}B_{kj}\)</span></p><h2 id="幂">幂</h2><p>设 <span class="math inline">\(A = \begin{pmatrix}A_1 &amp; &amp; &amp; \\&amp; A_2 &amp; &amp; \\&amp; &amp; \ddots &amp;\\&amp; &amp; &amp; A_s\end{pmatrix}\)</span>，则 <span class="math display">\[ A^m =\begin{pmatrix}A_1^m &amp; &amp; &amp;\\&amp; A_2^m &amp; &amp;\\&amp; &amp; \ddots &amp;\\&amp; &amp; &amp; A_s^m\\\end{pmatrix}\]</span></p><h2 id="转置">转置</h2><p>设 <spanclass="math inline">\(A=\begin{pmatrix}A_{11}&amp;A_{12}&amp;\cdots&amp;A_{1t}\\A_{21}&amp;A_{22}&amp;\cdots&amp;A_{2t}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\A_{s1}&amp;A_{s2}&amp;\cdots&amp;A_{st}\end{pmatrix}\)</span>，则<span class="math display">\[A&#39; =\begin{pmatrix}A_{11}^\prime&amp;A_{21}^\prime&amp;\cdots&amp;A_{s1}^\prime\\A_{12}^\prime&amp;A_{22}^\prime&amp;\cdots&amp;A_{s2}^\prime\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\A_{1t}^\prime&amp;A_{2t}^\prime&amp;\cdots&amp;A_{st}^\prime\end{pmatrix}\]</span></p><h2 id="行列式">行列式</h2><p><span class="math display">\[\begin{vmatrix}A_{11} &amp;A_{12} &amp;\cdots &amp;A_{1s}\\0 &amp;A_{22} &amp;\cdots &amp;A_{2s}\\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\\0 &amp;0 &amp;\cdots &amp;A_{ss}\end{vmatrix} = \left\vert A_{11}\right\vert \left\vertA_{22}\right\vert\cdots\left\vert A_{ss}\right\vert\]</span></p><p><span class="math display">\[\begin{vmatrix}A_{11} &amp; 0 &amp; \cdots &amp; 0\\A_{21} &amp; A_{22} &amp; \cdots &amp; 0\\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\\A_{s1} &amp; A_{s2} &amp; \cdots &amp; A_{ss}\end{vmatrix} = \left\vert A_{11}\right\vert \left\vertA_{22}\right\vert\cdots\left\vert A_{ss}\right\vert\]</span></p><p><span class="math display">\[\begin{vmatrix}A_{1} &amp; &amp; &amp; \\&amp; A_{2} &amp; &amp; \\&amp; &amp; \ddots &amp; \\&amp; &amp; &amp; A_{s}\end{vmatrix} = \left\vert A_{1}\right\vert \left\vertA_{2}\right\vert\cdots\left\vert A_{s}\right\vert\]</span></p><h2 id="逆">逆</h2><p><span class="math display">\[ \begin{pmatrix}A_1 &amp; &amp; &amp;\\&amp; A_2 &amp; &amp;\\&amp; &amp; \ddots &amp;\\&amp; &amp; &amp;A_s\end{pmatrix}^{-1} =\begin{pmatrix}A_1^{-1} &amp; &amp; &amp;\\&amp; A_2^{-1} &amp; &amp;\\&amp; &amp; \ddots &amp;\\&amp; &amp; &amp;A_s^{-1}\end{pmatrix}\]</span></p><p><span class="math display">\[ \begin{pmatrix}&amp; &amp; &amp;A_1 \\&amp; &amp; A_2 &amp;\\&amp;\ddots &amp; &amp;\\A_s&amp; &amp; &amp;\end{pmatrix}^{-1} =\begin{pmatrix}&amp; &amp; &amp;A_s^{-1}\\&amp;&amp; A_{s-1}^{-1} &amp;\\&amp; \ddots &amp;&amp; \\A_1^{-1}&amp; &amp; &amp;\end{pmatrix}\]</span> # 降阶公式 设 <spanclass="math inline">\(A\)</span> 为 <span class="math inline">\(m\timesn\)</span> 矩阵，<span class="math inline">\(B\)</span> 是 <spanclass="math inline">\(n\times m\)</span> 矩阵，<spanclass="math inline">\(m&gt;n\)</span>，<spanclass="math inline">\(\lambda\)</span> 是任意数，则 <spanclass="math display">\[\left\vert\lambda E_m - AB\right\vert =\lambda^{m-n}\left\vert\lambda E_n - BA\right\vert\]</span></p><h1 id="矩阵的秩">矩阵的秩</h1><h2 id="定义">定义</h2><p>矩阵 <span class="math inline">\(A\)</span>的非零子式的最高阶数叫作矩阵 <span class="math inline">\(A\)</span>的秩。</p><h2 id="性质">性质</h2><p>设 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(m\times n\)</span> 矩阵，<spanclass="math inline">\(B\)</span> 为 <span class="math inline">\(n\timesp\)</span> 矩阵，则</p><ul><li><span class="math inline">\(0 \le R(A) \le \min\{m,n\}\)</span></li><li><span class="math inline">\(R(A&#39;) = R(A)\)</span></li><li><span class="math inline">\(R(kA) =\begin{cases}0&amp;k=0\\R(A)&amp;k\ne0\end{cases}\)</span></li><li><span class="math inline">\(R(A_1) \le R(A)\)</span>，其中 <spanclass="math inline">\(A_1\)</span> 为 <spanclass="math inline">\(A\)</span> 的任意一个子矩阵。</li><li><spanclass="math inline">\(R\begin{pmatrix}A&amp;0\\0&amp;B\end{pmatrix} =R(A) + R(B)\)</span></li><li><spanclass="math inline">\(R\begin{pmatrix}A&amp;C\\0&amp;B\end{pmatrix} \geR(A) + R(B)\)</span></li><li><span class="math inline">\(R(A \mid B) \le R(A) +R(B)\)</span></li><li><span class="math inline">\(R(A + B) \le R(A) + R(B)\)</span></li><li><span class="math inline">\(R(AB) \le \min\{R(A),R(B)\}\)</span></li><li><span class="math inline">\(R(AB) \ge R(A) + R(B) - n\)</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu 22.04 LTS 上安装Steam</title>
    <link href="/2024/05/02/Install-Steam-in-Ubuntu-22-04-LTS/"/>
    <url>/2024/05/02/Install-Steam-in-Ubuntu-22-04-LTS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>很久很久以前，有个人有点受不了用windows这种系统了，由于Have nomoney（）....经过了一段时间的观望，他开始转向Linux的怀抱。然而又因为某些智力因素于是他决定先从Ubuntu开始......</p><p>众所周知，安装系统后第一件事就是下载steam。原本来说，Linux系统的一大痛点就是不能玩游戏，但是随着Steam Play 功能的推出，一切都开始有所转机</p><p>于是他尝试了很多种方法来实现自己的愿望。 我们将介绍每一种方法</p><h1 id="正片开始">正片开始</h1><h2 id="环境">环境</h2><p>系统环境：Ubuntu 22.04.4 LTS 桌面环境：Gnome 42.9 窗口系统：×11</p><p>硬件环境自不必多说，应该没有问题（毕竟是i9+4080</p><h2 id="ubuntu-software">Ubuntu Software</h2><p>这是一种抽象的方法因为Ubuntu Software是基于snap的这里我为了不污染我的系统于是我就不试了 而且也确实没啥好讲的</p><h2 id="apt">APT</h2><p>在我的观念中，能用apt装了没问题的软件就不用其他的装，因此这个方法是我的首选<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt intall steam<br></code></pre></td></tr></table></figure></p><p>也是顺利的装上了 <img src="image.png" alt="Steam" /></p><p>但是这个方法不知道是不是我打开的方式有问题，每次我开双屏（<del>当然不得不提一下我的27寸大屏啦</del>）都会发现有一个屏幕显示异常，表现为一动不动但是另一个屏幕正常。看了网上的各种解决方法也还暂时不知道所以然。。。因此我果断<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt purge steam<br></code></pre></td></tr></table></figure> 然后开始尝试另一种方法</p><h2 id="flatpak">Flatpak</h2><p>这个方法是我最终使用方法，也是我比较喜欢的一种方式（虽然被学长说有点臃肿），毕竟他把runtime包在一起的缘故，应用程序可能随便都占1GB以上，除此之外还有沙盒权限问题</p><h3 id="安装flatpak">安装flatpak</h3><p>这个方法首先要我们安装<ahref="https://flatpak.org/setup/Ubuntu">flatpak</a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install flatpak<br></code></pre></td></tr></table></figure>当然也可以添加Flatpak PPA来安装（针对于旧版本Ubuntu） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> add-apt-repository ppa:flatpak/stable<br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install flatpak<br></code></pre></td></tr></table></figure>（可选）安装flatpak插件，这样可以通过可视化界面安装flatpak软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gnome-software-plugin-flatpak<br></code></pre></td></tr></table></figure> 添加Flathub 仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo<br></code></pre></td></tr></table></figure> 然后restart</p><h2 id="安装steam">安装steam</h2><p>直接通过flatpak安装<ahref="https://flathub.org/apps/com.valvesoftware.Steam">steam</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flatpak install flathub com.valvesoftware.Steam<br></code></pre></td></tr></table></figure></p><p>这样就顺利的装上了，记得启用SteamPlay就行了，这样安装游戏的时候就能正常使用了（当然是大部分，据我所知大表哥就不行555~）</p><h2 id="flatseal">Flatseal</h2><p>这个玩意是用来管理Flatpak权限的，可装可不装，但是装上明显会更方便。因为记不住......<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install Flatseal<br></code></pre></td></tr></table></figure></p><h1 id="additions">Additions</h1><p>由于我系统盘空间不足的缘故，我想把游戏安装到外置硬盘。因此我尝试添加存储空间。但我发现，添加存储空间的时候无法直接添加指定的驱动器，只能通过~/media/这个软链接来添加。置此备忘</p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vscode 自动格式化插件</title>
    <link href="/2024/03/17/Vscode-autoformatter/"/>
    <url>/2024/03/17/Vscode-autoformatter/</url>
    
    <content type="html"><![CDATA[<h1 id="previous">Previous</h1><p>事情的起因是我在某一天打开 vscode 后发现了 tab变成了两个空格而导致我这个极度代码洁癖的人感觉很难受<del>由于懒</del>...由于习惯了编写 go语言代码保存时候的自动格式化，这让最近因为c++的<del>goushi</del>作业而焦头烂额的我开始思考能不能在其他语言编写的时候能不能也搞个</p><p>由于我平时使用的是 Vscode，因此我就直接使用了 prettier插件。以下是我配置的一些记录：</p><h1 id="步骤">步骤</h1><ul><li>安装 prettier 插件</li><li>配置<ul><li>可以通过 setting.json 进行配置， 这里就不多说了</li><li>也可以通过在 setting 中直接搜索 prettier 来实现</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 保存自动格式化</span><br><span class="hljs-attr">&quot;prettier.useTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;prettier.tabWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// Tab 宽度</span><br><span class="hljs-attr">&quot;C_Cpp.clang_format_style&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123; BasedOnStyle: Chromium, IndentWidth: 4&#125;&quot;</span> <span class="hljs-comment">// c++/c 大括号不换行</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Something Useful</title>
    <link href="/2024/02/21/Something-Useful/"/>
    <url>/2024/02/21/Something-Useful/</url>
    
    <content type="html"><![CDATA[<h1 id="放一些有用的链接">放一些有用的链接</h1><p><a href="https://unbug.github.io/codelf/">变量取名</a></p><p><a href="https://www.deepl.com/zh/translator">DeeL翻译</a></p><p><ahref="http://latex.codecogs.com/eqneditor/editor.php">markdown查询</a></p><p><a href="https://muzing.top/posts/48740/">md公式整理</a></p><p><a href="https://csacademy.com/app/graph_editor/">图论工具</a></p><p><a href="https://greasyfork.org/zh-CN">脚本</a></p><p><a href="https://wallhaven.cc/">壁纸</a></p><p><a href="https://flathub.org">Flathub</a></p><p><a href="http://zeemo.ai">Zeemo 自动加字幕/翻译字幕</a></p><h1 id="一些常用命令">一些常用命令</h1><h2 id="conda">conda</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br>conda info --envs<br>conda create -n env_name python=...<br>conda activate env_name<br>conda deactivate<br>conda remove --name env_name --all  // 删除指定虚拟环境及其中所安装的包<br>conda remove --name env_name  package_name<br>conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> --name myenv &gt; myenv.yml<br>conda <span class="hljs-built_in">env</span> create -f  myenv.yml<br>conda list pkgname*  //*号用于模糊查找<br>conda install package_name<br>conda uninstall package_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu Wake on Lan</title>
    <link href="/2024/02/20/Ubuntu-Wake-on-Lan/"/>
    <url>/2024/02/20/Ubuntu-Wake-on-Lan/</url>
    
    <content type="html"><![CDATA[<p>最近因为自己搭建了一个vps而欣喜若狂而导致日崩。由于某些...的需求，我需要能够再不用的时候将服务器关机。因此我开始折腾远程开机。</p><p>我的思路是通过电脑主板自带的Wake on Lan功能，目前来说大部分主板都有（我的主板是x99QD4）。最大的问题是在于配置为S5(shutdown)状态下时网卡需要在关机后处于激活状态，而这里需要系统在启动后将对应的网卡状态设置为对应状态。（因为Ubuntu20.04后网络唤醒重启之后网卡状态设置就会失效。。。不知道为啥）</p><p>过程很简单，即通过发送一组特殊格式的网络封包（MagicPacket）给具有某个MAC地址的电脑，让该电脑从睡眠模式甚至是关机模式苏醒，即从ACPI的Sx(S3，S4，S5)模式返回S0运行模式。</p><p>根据以上的思路，我们就开始着手准备了。</p><h1 id="服务端配置">服务端配置</h1><p>我们可以通过ethtool工具来查看并修改网卡状态，因此首先安装ethtool工具：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install ethtool<br></code></pre></td></tr></table></figure> 通过ifconfig查看网络信息： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure></p><p>以我的为例： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enp6s0</span>: flags=<span class="hljs-number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="hljs-number">1500</span><br>        <span class="hljs-attribute">inet</span> <span class="hljs-number">192.168.0.200</span>  netmask <span class="hljs-number">255.255.255.0</span>  broadcast <span class="hljs-number">192.168.0.255</span><br>        <span class="hljs-attribute">inet6</span> fe80::b7e2:<span class="hljs-number">6743</span>:aa3:<span class="hljs-number">5</span>e49  prefixlen <span class="hljs-number">64</span>  scopeid <span class="hljs-number">0</span>x20&lt;link&gt;<br>        <span class="hljs-attribute">ether</span> <span class="hljs-number">0</span>a:e0:af:b3:<span class="hljs-number">23</span>:bf  txqueuelen <span class="hljs-number">1000</span>  (以太网)<br>        <span class="hljs-attribute">RX</span> packets <span class="hljs-number">10466</span>  bytes <span class="hljs-number">6877996</span> (<span class="hljs-number">6</span>.<span class="hljs-number">8</span> MB)<br>        <span class="hljs-attribute">RX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">3</span>  overruns <span class="hljs-number">0</span>  frame <span class="hljs-number">0</span><br>        <span class="hljs-attribute">TX</span> packets <span class="hljs-number">8851</span>  bytes <span class="hljs-number">860614</span> (<span class="hljs-number">860</span>.<span class="hljs-number">6</span> KB)<br>        <span class="hljs-attribute">TX</span> errors <span class="hljs-number">0</span>  dropped <span class="hljs-number">0</span> overruns <span class="hljs-number">0</span>  carrier <span class="hljs-number">0</span>  collisions <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p><p>这个就是我的有线网卡信息。可以看出，ether就是mac地址，网卡名为enp6s0。接下来通过ethtool查看网卡状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ethtool enp6s0<br></code></pre></td></tr></table></figure></p><p>可以看到： <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Supports</span> Wake-<span class="hljs-literal">on</span>: pumbg<br>Wake-<span class="hljs-literal">on</span>: d<br></code></pre></td></tr></table></figure></p><p>这里附上Wake-on各种状态的参数含义： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">OptionDescription<br><span class="hljs-keyword">p</span>Wake <span class="hljs-keyword">on</span> PHY activity<br><span class="hljs-keyword">u</span>Wake <span class="hljs-keyword">on</span> unicast <span class="hljs-keyword">messages</span><br><span class="hljs-keyword">m</span>Wake <span class="hljs-keyword">on</span> multicast <span class="hljs-keyword">messages</span><br><span class="hljs-keyword">b</span>Wake <span class="hljs-keyword">on</span> broadcast <span class="hljs-keyword">messages</span><br>gWake <span class="hljs-keyword">on</span> MagicPacket <span class="hljs-keyword">messages</span><br></code></pre></td></tr></table></figure></p><p>更新网卡状态。由于我们要使用的是MagicPacket信息，因此：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ethtool --change enp6s0 wol g<br><span class="hljs-built_in">sudo</span> ethtool enp6s0<br></code></pre></td></tr></table></figure></p><p>此时看到： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Wake</span>-<span class="hljs-literal">on</span>: g<br></code></pre></td></tr></table></figure> 说明状态修改成功。</p><p>由于每次开机后都要重新设置网卡的状态才能在下一次关机后再次使用网络唤醒，所以我们可以通过systemd添加一个系统服务在每次开机后修改网卡状态。首先确定ethtool路径： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> ethtool<br></code></pre></td></tr></table></figure> 可见: <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>sbin/ethtool<br></code></pre></td></tr></table></figure>这个因机器而异，因此下面的内容需要根据实际情况修改：</p><p>创建一个 /etc/systemd/system/wol.service文件，在这里写下启动执行一次的服务信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Enable Wake <span class="hljs-literal">On</span> Lan<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-literal">on</span>eshot<br><span class="hljs-attr">ExecStart</span> = /usr/sbin/ethtool --change enp6s0 wol g<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=basic.target<br></code></pre></td></tr></table></figure><p>之后只需要enable该服务就可以: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> wol.service<br></code></pre></td></tr></table></figure></p><p>检查一下对应的状态: <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status wol</span><br></code></pre></td></tr></table></figure> 可以看到： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">○ wakeonlan.service - <span class="hljs-built_in">Enable</span> Wake On<span class="hljs-built_in"> Lan</span><br><span class="hljs-built_in"></span>     Loaded: loaded (/etc/systemd/system/wol.service; enabled; vendor preset: enabled)<br>     Active: inactive (dead) since Tue 2024-02-20 23:32:35 +08; 28min ago<br>   Main PID: 948 (<span class="hljs-attribute">code</span>=exited, <span class="hljs-attribute">status</span>=0/SUCCESS)<br>        CPU: 2ms<br><br>Feb 20 23:32:34<span class="hljs-built_in"> Server </span>systemd[1]: Starting <span class="hljs-built_in">Enable</span> Wake On Lan<span class="hljs-built_in">..</span>.<br>Feb 20 23:32:35<span class="hljs-built_in"> Server </span>systemd[1]: wol.service: Deactivated successfully.<br>Feb 20 23:32:35<span class="hljs-built_in"> Server </span>systemd[1]: Finished <span class="hljs-built_in">Enable</span> Wake On Lan.<br></code></pre></td></tr></table></figure></p><p>说明服务正常运行。</p><h1 id="远程启动">远程启动</h1><h2 id="ubuntu-mac">Ubuntu &amp;&amp; Mac</h2><p>以Ubuntu和Mac为例，在命令行中执行wakeonlan xx:xx:xx:xx:xx:xx（输入Ubuntu机器对应的mac地址）就可以唤醒机器了</p><p>但是前提是安装了wakeonlan</p><h2 id="windows">windows</h2><p>这里我偷懒了，不想自己写一个脚本出来，因此我就用一些现成的工具了。此处我选择的是<ahref="https://www.depicus.com/wake-on-lan/wake-on-lan-gui">WakeOnLanGui</a></p><p>界面如下：</p><img src="/2024/02/20/Ubuntu-Wake-on-Lan/image.png" class="" title="This is a image..."><p>根据实际情况填写MAC地址、被控端域名、子网掩码和端口号（任一）就行了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu Todesk 的一些使用记录</title>
    <link href="/2024/02/20/Ubuntu-Todesk/"/>
    <url>/2024/02/20/Ubuntu-Todesk/</url>
    
    <content type="html"><![CDATA[<h1 id="安装">安装</h1><p>参照：https://www.todesk.com/linux.html 官方文档上说： <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> apt-<span class="hljs-meta">get</span> install ./todesk-<span class="hljs-built_in">v4</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-amd64.deb<br></code></pre></td></tr></table></figure>但是我试了没用（），由于我要用的是远程的ubuntu服务器，因此只能老老实实下载deb包然后通过scp传到服务器上。</p><h1 id="启动">启动</h1><p>启动命令为： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">todesk</span><br></code></pre></td></tr></table></figure></p><p>但是你都作为服务端了，你要gui界面你有看不到，因此只需要保持todeskd.service运行就行了。</p><p>但是我们显然看不到服务端的设备代码和临时密码，秉持着linux数据皆文件的原则，我们找到了他的配置文件，位于：/opt/todesk/config/config.ini</p><p>查看config.ini</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/todesk/config<br><span class="hljs-built_in">cat</span> config.ini<br></code></pre></td></tr></table></figure><p>可以看到： <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[configinfo]</span><br><span class="hljs-attr">passupdate</span>                     = <span class="hljs-number">3</span><br><span class="hljs-attr">screen_img</span>                     =<br><span class="hljs-attr">clientid</span>                       = ********(这里只是我人为的加密)<br><span class="hljs-attr">privatedata</span>                    = ea51f22264b6913deb2b29e925788531500fd14c303ac881eb8bf2104632d95c969ecc074f67273fd5eda82971dc56e5ca9cc57467ae6c4b83<br><span class="hljs-attr">updatepasstime</span>                 = <span class="hljs-number">20240220</span><br><br></code></pre></td></tr></table></figure></p><p>此时并没有tempauthpassex字段。我们通过我们windows端的todesk的配置文件可以看到:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ConfigInfo]</span><br><span class="hljs-attr">passUpdate</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">PrivateScreenLockScreen</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">autoLockScreen</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">downloadtimes</span>=<span class="hljs-number">202309040</span><br><span class="hljs-attr">clientId</span>=********<br><span class="hljs-attr">PrivateData</span>=<span class="hljs-number">98</span>f13012367f8fa56c7b71bce229e7f6fd1d8275b1340122e53293861dc6256651992beeaac16e61a4b5fad7ba2d0d04f7fd75003e78d12651<br><span class="hljs-attr">PluginExpiresDays</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Resolution</span>=<span class="hljs-number">2560</span>x1600<br><span class="hljs-attr">tempAuthPassEx</span>=f2c33773c4e07102cd9b30f1e762842b78a13df40e45bb730cd938953cc078a9d174a5b6ee1ad50b13ebb65a4de17f7e917a40969a966d0f<br><span class="hljs-attr">updatePassTime</span>=<span class="hljs-number">20230904</span><br><span class="hljs-attr">isOpenTempPass</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">language</span>=<span class="hljs-number">936</span><br><span class="hljs-attr">isAdmissionControl</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">WeakPasswordTip</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Version</span>=<span class="hljs-number">4.7</span>.<span class="hljs-number">0.4</span><br><span class="hljs-attr">isUpdate</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">PresetDialogUpdateDate</span>=<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-<span class="hljs-number">20</span><br><span class="hljs-attr">PresetDialogShowCount</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">NewToken</span>=<br><span class="hljs-attr">Token</span>=cb3c958a5d8d8f79e7d3561495b25987<br><span class="hljs-attr">LoginType</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">user</span>=<br><span class="hljs-attr">LoginPhone</span>=<span class="hljs-number">15918991630</span><br><span class="hljs-attr">LoginEmail</span>=<br><span class="hljs-attr">AreaCode</span>=<span class="hljs-number">86</span><br><span class="hljs-attr">UpdateFrequencyPromptBubble</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">UpdateTempPassDefault</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">LastPushTimeEx</span>=<span class="hljs-number">20240220</span><br><span class="hljs-attr">ShowToolbarGuide</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">IsFirstTimeConnect</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">MouseLeaveTip</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">autoLogin</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">AuthMode</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">minsizelock</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">loginlock</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">passex</span>=<span class="hljs-number">8534</span>b3464a478963712d4a727bc9f34ddbe1b59cc1611fa58ec36c741823b03fa7a59cc821dab0cb617c26a737a6179c<br><span class="hljs-attr">RoundBallXPos</span>=<span class="hljs-number">167</span><br><span class="hljs-attr">RoundBallYPos</span>=<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>对比我们ui界面中的临时密码和设备码，可以确定，clientId就是设备代码，而tempAuthPassEx是通过加密后的临时密码</p><p>那么我们就可以通过我们现在已知的临时密码来获取他的加密，并且添加到服务端的配置文件中，这样一来，服务端的密码就已知了，就可以进行连接了。连接之前记得重启todeskd.service和查看其状态来确定其工作是否正常</p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About Ubuntu LTS 22.04 libssl 1.1</title>
    <link href="/2024/02/19/About-Ubuntu-LTS22-04-libssl1-1/"/>
    <url>/2024/02/19/About-Ubuntu-LTS22-04-libssl1-1/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述">问题描述</h1><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="hljs-attribute">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="hljs-attribute">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="hljs-attribute">下列信息可能会对解决问题有所帮助：</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">下列软件包有未满足的依赖关系：</span><br><span class="hljs-attribute"> erlang-crypto</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">依赖: libssl1.1 (&gt;= 1.1.1) 但无法安装它</span><br><span class="hljs-attribute">E</span><span class="hljs-punctuation">:</span> <span class="hljs-string">无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br><br>这几天尝试在ubuntu服务器上安装RabbitMQ的时候出现了以上问题，对此.....<br></code></pre></td></tr></table></figure><h1 id="问题解决">问题解决</h1><p>经过查询资料可知，ubuntu LTS22.04 软件源中，并不包含libssl</p><p>因此，只能手动下载安装。http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.<span class="hljs-number">1</span>-udeb_1.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>ubuntu2.<span class="hljs-number">1</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.<span class="hljs-number">23</span>_amd64.udeb<br><br><span class="hljs-attribute">sudo</span> dpkg -i libssl1.<span class="hljs-number">1</span>-udeb_1.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>ubuntu2.<span class="hljs-number">1</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.<span class="hljs-number">23</span>_amd64.udeb<br></code></pre></td></tr></table></figure></p><p>问题就解决了</p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些网络结构笔记</title>
    <link href="/2023/12/17/Some-Network-Structure/"/>
    <url>/2023/12/17/Some-Network-Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="vgg-net">VGG net</h1><img src="/2023/12/17/Some-Network-Structure/VGGnet-configuration.png" class="" title="this is a img..."><img src="/2023/12/17/Some-Network-Structure/VGGnet.png" class="" title="this is a img..."><h1 id="densenet">DenseNet</h1><img src="/2023/12/17/Some-Network-Structure/DenseNet.webp" class="" title="this is a img..."><h1 id="alexnet">Alexnet</h1><img src="/2023/12/17/Some-Network-Structure/Alexnet.png" class="" title="this is a img..."><h1 id="fcn">FCN</h1><img src="/2023/12/17/Some-Network-Structure/FCN.png" class="" title="this is a img..."><h1 id="resnet">Resnet</h1><img src="/2023/12/17/Some-Network-Structure/Resnet.png" class="" title="this is a img..."><img src="/2023/12/17/Some-Network-Structure/Resnet-1.png" class="" title="this is a img..."><h1 id="unet">Unet</h1><img src="/2023/12/17/Some-Network-Structure/Unet.webp" class="" title="this is a img..."><h1 id="deeplab">DeepLab</h1><img src="/2023/12/17/Some-Network-Structure/DeepLab.png" class="" title="this is a img..."><h1 id="fast-r-cnn">Fast R-CNN</h1><img src="/2023/12/17/Some-Network-Structure/Fast-R-CNN.webp" class="" title="this is a img..."><h1 id="yolo-v5">YOLO v5</h1><img src="/2023/12/17/Some-Network-Structure/YOLOv5.webp" class="" title="this is a img...">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Collected</title>
    <link href="/2023/12/14/Collected/"/>
    <url>/2023/12/14/Collected/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/448115462">变换矩阵</a></p><p><ahref="https://www.zhihu.com/tardis/zm/art/31886934?source_id=1003">SVM</a></p><p><ahref="https://zhuanlan.zhihu.com/p/51011531">特征值和特征向量</a></p><p><a href="https://zhuanlan.zhihu.com/p/599014616">仿射组合</a></p><p><a href="https://zxmls520.github.io/zxmls/#/">Something may beuseful</a></p><p><a href="https://sms-activate.org/cn">rand virtual phonenumber</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用积分</title>
    <link href="/2023/12/14/Calculus/"/>
    <url>/2023/12/14/Calculus/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(\int kdx = kx + C\)</span></p><p><span class="math inline">\(\int x^{\mu}dx = \frac{x^{\mu + 1}}{\mu +1} + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{x} = \ln\left\vertx\right\vert + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{1 + x^2} = \arctan x +C\)</span></p><p><span class="math inline">\(\int\frac{dx}{\sqrt{1 - x^2}} = \arcsin x+ C\)</span></p><p><span class="math inline">\(\int\cos xdx = \sin x + C\)</span></p><p><span class="math inline">\(\int\sin xdx = -\cos x + C\)</span></p><p><span class="math inline">\(\int\sec^2 xdx = \tan x + C\)</span></p><p><span class="math inline">\(\int\csc^2 xdx = -\cot x + C\)</span></p><p><span class="math inline">\(\int\sec x\tan xdx = \sec x +C\)</span></p><p><span class="math inline">\(\int\csc x\cot xdx = -\csc x +C\)</span></p><p><span class="math inline">\(\int e^xdx = e^x + C\)</span></p><p><span class="math inline">\(\int a^xdx = \frac{a^x}{\ln a} +C\)</span></p><p><span class="math inline">\(\int\frac{dx}{a^2 + x^2} =\frac{1}{a}\arctan{\frac{x}{a}} + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{\sqrt{a^2 - x^2}} =\arcsin{\frac{x}{a}} + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{a^2 - x^2} =\frac{1}{2a}\ln\left\vert\frac{a + x}{a - x}\right\vert + C\)</span></p><p><span class="math inline">\(\int\tan xdx = -\ln\left\vert \cosx\right\vert + C\)</span></p><p><span class="math inline">\(\int\cot xdx = \ln\left\vert\sinx\right\vert + C\)</span></p><p><span class="math inline">\(\int\sec xdx = \ln\left\vert\sec x + \tanx\right\vert + C\)</span></p><p><span class="math inline">\(\int\csc xdx = \ln\left\vert\csc x - \cotx\right\vert + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{\sqrt{x^2 + a^2}} = \ln(x +\sqrt{x^2 + a^2}) + C\)</span></p><p><span class="math inline">\(\int\frac{dx}{\sqrt{x^2 - a^2}} =\ln\left\vert x + \sqrt{x^2 - a^2}\right\vert + C\)</span></p>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵左乘和右乘</title>
    <link href="/2023/12/13/left-multiplication-and-right-multiplication-of-matrices/"/>
    <url>/2023/12/13/left-multiplication-and-right-multiplication-of-matrices/</url>
    
    <content type="html"><![CDATA[<h1 id="向量乘矩阵">向量乘矩阵</h1><p>设矩阵A：</p><p><span class="math display">\[A = \begin{bmatrix}a_{11} &amp; a_{12} \\a_{21} &amp; a_{22}\end{bmatrix}\]</span></p><p>设向量x：</p><p><span class="math display">\[x = \begin{bmatrix}x_1\\x_2\end{bmatrix}\]</span></p><p>那么x右乘矩阵A，我们会得到：</p><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} \\a_{21} &amp; a_{22}\end{bmatrix}\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}=x_1\begin{bmatrix}a_{11}\\a_{21}\end{bmatrix}+x_2\begin{bmatrix}a_{12} \\a_{22}\end{bmatrix}\]</span></p><p>由此可见，上述乘法相对于是对矩阵A中的列向量进行线性组合，线性组合的系数就是x对应位置的元素</p><p>那么x左乘矩阵A，我们会得到：</p><p><span class="math display">\[\begin{bmatrix}x_{1} &amp; x_{2}\end{bmatrix}\begin{bmatrix}a_{11} &amp; a_{12} \\a_{21} &amp; a_{22}\end{bmatrix}=x_1\begin{bmatrix}a_{11} &amp; a_{12}\end{bmatrix}+x_2\begin{bmatrix}a_{21} &amp; a_{22}\end{bmatrix}\]</span></p><p>由此可见，向量左乘矩阵A，就相当于对矩阵A中的行向量进行线性组合，线性组合的系数就是向量x上对应位置的元素</p><h1 id="矩阵乘矩阵">矩阵乘矩阵</h1><p><strong>左乘</strong>，是指将第一个矩阵的列向量作为基，将第二个矩阵的列向量进行线性组合。</p><p><strong>右乘</strong>，是指将第一个矩阵的行向量作为基，将第二个矩阵的行向量进行线性组合。</p><p>例如，设矩阵 A 和 B 如下所示：</p><p><span class="math display">\[A=\begin{bmatrix}1 &amp; 2 \\3 &amp; 4\end{bmatrix}B=\begin{bmatrix}5 &amp; 6 \\7 &amp; 8\end{bmatrix}\]</span></p><p>则矩阵 A 左乘矩阵 B 的结果如下所示：</p><p><span class="math display">\[C = A \cdot B = \begin{bmatrix}1 &amp; 2 \\3 &amp; 4\end{bmatrix} \cdot \begin{bmatrix}5 &amp; 6 \\7 &amp; 8\end{bmatrix} = \begin{bmatrix}25 &amp; 22 \\49 &amp; 42\end{bmatrix}\]</span></p><p>矩阵 A 左乘矩阵 B 的结果可以理解为：</p><ul><li>将矩阵 B 的列向量按顺序排列，得到一个列向量组。</li><li>将矩阵 A的每一行向量与列向量组中的每一个向量进行线性组合，得到一个新的列向量。</li><li>将新的列向量组作为矩阵 C 的列向量。</li></ul><p>矩阵 A 右乘矩阵 B 的结果如下所示：</p><p><span class="math display">\[D = B \cdot A = \begin{bmatrix}5 &amp; 6 \\7 &amp; 8\end{bmatrix} \cdot \begin{bmatrix}1 &amp; 2 \\3 &amp; 4\end{bmatrix} = \begin{bmatrix}53 &amp; 64 \\95 &amp; 108\end{bmatrix}\]</span></p><p>矩阵 A 右乘矩阵 B 的结果可以理解为：</p><ul><li>将矩阵 A 的行向量按顺序排列，得到一个行向量组。</li><li>将矩阵 B的每一行向量与行向量组中的每一个向量进行线性组合，得到一个新的行向量。</li><li>将新的行向量组作为矩阵 D 的行向量。</li></ul><h1 id="summary">Summary</h1><ul><li>要将矩阵乘法理解称为变换</li><li>左乘矩阵相当于对原矩阵进行了初等行变换，右乘矩阵相当于对原矩阵进行了初等列变换</li><li>左乘可以说是矩阵中向量组的变换，而右乘是空间的变换，本质是基向量的改变</li></ul>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反向传播优化器总结（The Summary of Backpropagation Optimizer）</title>
    <link href="/2023/12/12/Backpropagation-Optimizer-Summary/"/>
    <url>/2023/12/12/Backpropagation-Optimizer-Summary/</url>
    
    <content type="html"><![CDATA[<h1 id="beginings">Beginings</h1><p>梯度下降算法（Gradient DescentOptimization）是神经网络模型训练最常用的优化算法。对于深度学习模型，基本都是采用梯度下降算法来进行优化训练的。<del>其原理也很简单，就是求导（），将其推广到高维空间就是求偏导</del></p><p>目标函数<span class="math inline">\(J(\theta)\)</span>关于参数<spanclass="math inline">\(\theta\)</span>的梯度就是损失函数（lossfunction）上升最快的方向，那么同样道理，梯度的反方向指向的就是损失函数下降最快的方向。根据这一特点，我们可以写出网络中每个参数的更新方程<span class="math display">\[\theta_j = \theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta)\]</span> <span class="math inline">\(\alpha\)</span>表示学习率（learningrate）,这个参数设置的目的就是为了走太大<del>扯到蛋</del>的，或者就是说防止在接近最低点的位置反复横跳# 梯度下降的三种基本形式其实说到底只有BGD是最基本的，SGD和MBGD其实都是对BGD的优化。但是看在也是很基础的份上我就把他归于基本的梯度下降方式## BGD(批量梯度下降)BGD使用整个训练数据集来计算每一步的梯度。具体来说，它计算损失函数对所有样本的梯度，然后根据该梯度来更新模型参数。但这意味着在每一次迭代中，都要考虑整个数据集，所以计算速度非常慢，无法进行在线学习，即便可以，一个样本加入到大数据集中，对梯度影响也不明显。唯一的优点就是<del>容易写</del>它对整个数据集进行了全局考虑，因此可以更准确地朝着最优参数的方向前进</p><p>它对于凸函数可以收敛到全局极小值，对于非凸函数可以收敛到局部极小值。</p><p>如果用X代表数据集，那么他的更新规则是： <span class="math display">\[\nabla L(X;\theta_l) = \frac{1}{m} \sum_{x_i \epsilon X} \nablal(x_i;\theta_l)\]</span> <span class="math display">\[\theta_{l+1} = \theta_{l} - \alpha \nabla L(X;\theta_l)\]</span></p><h2 id="sgd随机梯度下降">SGD(随机梯度下降)</h2><p>说白了就是在BGD的基础上，每次迭代仅使用一个随机样本来计算梯度和更新模型参数。这也导致了他容易受数据集中一些异常值的影响，导致更新过程不稳定。但是也恰恰是整个不稳定的特性让他有时可以更容易的跳出梯度高原().....这也可以提高计算速度和内存效率。由于每次只使用一个样本，SGD的计算开销较小，特别适用于大型数据集</p><p>更新规则是： <span class="math display">\[\theta_{l+1} = \theta_{l} - \alpha \nabla l(x_i;\theta_l)\]</span> 其中<span class="math inline">\(\nabla l(X;\theta_l)\)</span>是损失函数关于单个样本<span class="math inline">\(x_i\)</span>的梯度</p><p>SGD虽然能达到极小值，但是比其它算法用的时间长，而且可能会被困在鞍点。</p><p>如果需要更快的收敛，或者是训练更深更复杂的神经网络，需要用一种自适应的算法。</p><h2 id="mbgd小批量梯度下降">MBGD(小批量梯度下降)</h2><p>从这个标题出现的位置和他的命名我们就可以大概的猜出来，这个玩意介于BGD和SGD之间，集合了两家之长，降低了更新时的方差，收敛更加稳定。</p><p>MBGD每次迭代时不是使用整个数据集，也不是只使用单个样本，而是使用一个小批量样本。这个小批量的大小通常是一个可调节的超参数，也就是batch_size</p><p>其更新规则是： <span class="math display">\[\theta_{l+1} = \theta_{l} - \alpha \nabla (\frac{1}{b}\sum_{i=1}^bl(x_i;\theta_l))\]</span></p><h1 id="梯度下降法的优化">梯度下降法的优化</h1><h2 id="动量优化算法momentum">动量优化算法（Momentum）</h2><p>它引入了动量项v，它是之前梯度的加权平均，模拟了物体在运动中的积累速度的效果，从而帮助跨越局部最小值并更快地收敛到全局最小值。</p><p>动量项有助于平滑更新过程，减少参数更新的方差，特别是在存在高曲率或噪声的情况下。它还有助于加速梯度下降，特别是在平原上的方向。同时，动量的积累效果有助于在参数空间中跨越局部最小值，因为动量使得更新在原有方向上继续前进。特别适用于复杂的损失函数和参数空间中存在局部极小值的情况。</p><p>对于给定的模型参数<spanclass="math inline">\(\theta\)</span>，动量项v的更新规则如下：</p><p><span class="math display">\[v_{l+1} = \beta v_t + (1 - \beta) \nabla L(\theta_l)\]</span> <span class="math inline">\(\beta\)</span>是动量参数，通常取一个介于0到1之间的值</p><p>相应的，其参数的更新规则为： <span class="math display">\[\theta_{l+1} = \theta_{l} - \alpha v_{l+1}\]</span></p><h2 id="nesterov-accelerated-gradientnag">Nesterov AcceleratedGradient（NAG）</h2><p>这是对动量算法的改进。NAG在更新参数时先根据当前动量位置预估下一步的位置，然后计算梯度进行更新。NAG首先根据当前动量位置<spanclass="math inline">\(v_t\)</span>预估下一步的位置。预估的下一步位置为<spanclass="math inline">\(\theta_l - \beta v_t\)</span>，其中<spanclass="math inline">\(\beta\)</span>是动量参数。其主要优势在于它对动量的使用进行了改进，提供更准确的预估位置，有助于在参数更新时更精确地调整方向。这使得NAG 在一些情况下比标准动量算法表现更好</p><p>参数更新规则为： <span class="math display">\[\theta_{l+1} = \theta_{l} - \alpha \nabla_\theta L(\theta_l - \beta v_l)\]</span> <span class="math display">\[v_{l+1} = \beta v_l + \alpha \nabla_\theta L(\theta_l - \beta v_l)\]</span></p><h2 id="adagrad-adaptive-gradient-algorithm">Adagrad （Adaptive gradientalgorithm）</h2><p>很牛逼的一个东西，自适应学习率。它根据每个参数的历史梯度信息自适应地调整学习率，使得对于稀疏梯度的参数可以具有更大的学习率，而对于频繁出现的参数可以有较小的学习率。适用于稀疏数据和非平稳目标函数，但它可能在训练后期过于减小学习率，导致更新步长过小，难以收敛。因此出现了后面的RMSprop和Adam。但是，RMSprop,Adadelta, Adam 在很多情况下的效果其实是相似的。</p><p>参数更新规则如下： <span class="math display">\[\theta_{l+1} = \theta_l - \frac{\alpha}{\sqrt{G_l + \epsilon}} \cdot\nabla_{\theta} L(\theta_l)\]</span> 其中<spanclass="math inline">\(G_l\)</span>是历史梯度平方的累积，<spanclass="math inline">\(\epsilon\)</span>是一个小的常数用于数值稳定性</p><h2 id="adadelta">Adadelta</h2><p>Adadelta 是是 Adagrad 的一种改进版本，解决了 Adagrad在训练后期学习率过小的问题，不需要手动设置初始学习率，并且对学习率进行了更加平滑和自适应的调整。它使用了对梯度平方的滑动平均，而不是历史梯度平方的累积。这解决了Adagrad学习率过早减小的问题。适用于处理非平稳目标函数和具有不同尺度的参数的情况。</p><p>参数更新规则： <span class="math display">\[\theta_{l+1} = \theta_l - \frac{\sqrt{E[g^2]_t +\epsilon}}{\sqrt{E[\Delta \theta^2]l + \epsilon}}  \nabla_{\theta}L(\theta_l)\]</span></p><p>其中，$ _{} L(_l) $ 是损失函数关于参数 $ $ 的梯度，$ E[g^2]_l <spanclass="math inline">\(是梯度平方的滑动平均，\)</span> E[^2]l$是参数更新的滑动平均</p><h2 id="rmsprop">RMSprop</h2><p>RMSprop是对 Adagrad的改进，通过引入衰减系数来减轻学习率的过早减小问题。使用滑动平均来累积梯度平方，这有助于自适应地调整学习率，对于稀疏梯度和非平稳目标函数效果较好。引入了一个衰减系数ρ，它控制了滑动平均的速度。通常ρ取值为接近于1的数，如0.9。适用于处理非平稳目标函数和具有不同尺度的参数的情况</p><p>参数更新规则： <span class="math display">\[\theta_{l+1} = \theta_l - \frac{\alpha}{ \sqrt{E[g^2]_t + \epsilon}}\nabla_{ \theta} L( \theta_t)\]</span> ## Adam：Adaptive Moment EstimationAdam结合了动量（momentum）和 RMSprop 的思想，引入了动量项，用<spanclass="math inline">\(m_l\)</span>表示，同时引入了RMSprop的思想，使用了梯度平方的滑动平均，用<spanclass="math inline">\(v_l\)</span>表示。随着梯度变的稀疏，Adam 比RMSprop 效果更好。</p><p>参数更新规则： <span class="math display">\[\theta_{t+1} = \theta_t - \frac{\alpha \cdot m_t}{\sqrt{v_t} + \epsilon}\]</span> <span class="math display">\[m_{t+1} = \beta_1 \cdot m_t + (1 - \beta_1) \cdot \nabla_{\theta}L(\theta_t)\]</span> <span class="math display">\[v_{t+1} = \beta_2 \cdot v_t + (1 - \beta_2) \cdot (\nabla_{\theta}L(\theta_t))^2\]</span> 其中<span class="math inline">\(\beta_1 和\beta_2\)</span>都是衰减系数，通常取接近于1的数</p><p>整体来讲，Adam 是最好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>AI_learning</category>
      
      <category>Theories</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用损失函数及一些Notes</title>
    <link href="/2023/12/12/Commonly-used-loss-functions/"/>
    <url>/2023/12/12/Commonly-used-loss-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="begining">Begining</h1><p>很久很久以前，机器学习主要有两大任务：分类和回归任务......</p><h1 id="基本概念note">基本概念（Note）</h1><ul><li>损失函数：就是用来更新参数的衡量指标</li><li>风险函数：就是train过程中的loss，用于衡量样本点平均意义下的好坏。注意要除以batch_size</li><li>泛化函数：就是test过程中的loss</li></ul><h1 id="回归-regression">回归 (Regression)</h1><p>在回归任务中，预测值和实际值都是实数，一般采用残差$ y−f(x)$来度量两者的不一致程度</p><h2 id="均方误差msel2损失">均方误差（MSE）/L2损失</h2><p>说白了就是预测值和实际观测值间差的平方的均值。它只考虑误差的平均大小，不考虑其方向。<span class="math display">\[MSE = \frac{1}{2n} \sum (y_i - \hat{y_i})^2\]</span> 特性： -经过平方，与真实值偏离较多的预测值会受到更为严重的惩罚,所以不够robust()- 容易算梯度......</p><h2 id="均方根误差root-mean-suqare-errorrmse">均方根误差（root meansuqare error,RMSE）</h2><p>没错，跟刚刚那个很像，就是多了个根号() <span class="math display">\[RMSE = \sqrt {\frac{ \sum (y_i - \hat{y_i})^2}{n}}\]</span> 这个玩意和刚刚那个的区别就是惩罚变轻了</p><h2 id="平均绝对误差mael1损失">平均绝对误差MAE/L1损失</h2><p>不考虑方向 <span class="math display">\[MAE = \frac{ \sum_{i=1}^{n} \left | y_i - \hat{y_i} \right |}{n}\]</span> 特性： - 梯度的计算有点烦，需要用到线性规划 - 异常值的反应更小- 梯度一直很大，会遗漏最小值</p><h2 id="平均偏差误差mean-bias-error不常见">平均偏差误差（Mean BiasError）(不常见)</h2><p>注意，这里正负误差可以互相抵消，因为他相比MAE来说没有用绝对值。可以确定模型存在正偏差还是负偏差<span class="math display">\[MBE = \frac{ \sum_{i=1}^{n} (y_i - \hat{y_i})}{n}\]</span></p><h2id="平均绝对百分比误差mean-absolute-pencent-errormape">平均绝对百分比误差（MeanAbsolute Pencent Error，MAPE）</h2><p>相比 RMSE，MAPE 相当于把每个点的误差进行了归一化,降低了个别离群点带来的绝对误差的影响 <span class="math display">\[MAPE = \sum_{i=1}^{n} \left |\frac{y_i - \hat{y_i}}{y_i} \right | *\frac{100}{n}\]</span></p><h2 id="huber函数">Huber函数</h2><p><span class="math display">\[L_{Huber}(f,y) =\begin{cases}(f-y)^2, &amp; \left | f - y \right|  \leqslant \xi\\2\xi\left | f - y \right| - \xi^2, &amp;\left | f - y \right| &gt; \xi\end{cases}\]</span></p><p>这样一来，<span class="math inline">\(\xi\)</span> ~0时，Huber趋近于MAE；<span class="math inline">\(\xi\)</span> ~ <spanclass="math inline">\(\infty\)</span> ， Huber趋近于MSE</p><p>但是他需要训练<spanclass="math inline">\(\xi\)</span>这个超参数......</p><h1 id="分类classification">分类(Classification)</h1><h2 id="损失函数zero-one-lossperception">0-1损失函数（zero-oneloss）——Perception</h2><p>就是预测值和目标值不相等为1，否则为0。我们经常可以在感知机模型里面看到他，属于非凸函数，一般来说也就只能在感知机模型里面看到他<span class="math display">\[L(Y,f(x)) =\begin{cases}\ 1, &amp;Y \neq f(x) \\\ 0, &amp;Y = f(x)\end{cases}\]</span></p><h2 id="logistic损失函数">Logistic损失函数</h2><p>Logistic损失函数是0-1损失函数的另一个代理损失函数，它也是0-1损失函数的凸上界，且该函数处处光滑。但是该损失函数对所有样本点都惩罚，因此对异常值更加敏感。当预测值<spanclass="math inline">\(f \epsilon = [-1,1]\)</span>时，另一个常用的代理损失函数是交叉熵损失函数 <spanclass="math display">\[L(f,y) = \log_2(1+\exp(-fy))\]</span></p><h2 id="对数损失函数loglr">对数损失函数（log）——LR</h2><del>这里懒得手写LaTeX公式了()，直接用图片说明：</del><center><img src="/2023/12/12/Commonly-used-loss-functions/log.png" class="" title="This is a photos..."></center><h2 id="cross-entropy交叉熵损失函数">Cross-Entropy(交叉熵)损失函数</h2><p>交叉熵损失函数也是0-1损失函数的光滑凸上界 <spanclass="math display">\[L(f,y) = \log_2(\frac{1+fy}{2})\]</span></p><h2id="exponential指数损失函数adaboost">Exponential(指数)损失函数(AdaBoost)</h2><p>指数损失函数是AdaBoost里使用的损失函数，同样地，它对异常点较为敏感，缺乏rebust<span class="math display">\[L(f,y) = e^{-fy}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>AI_learning</category>
      
      <category>Theories</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大雾（）</title>
    <link href="/2023/12/11/physics/"/>
    <url>/2023/12/11/physics/</url>
    
    <content type="html"><![CDATA[<h2 id="规则">规则</h2><ul><li>电压从零开始</li><li>数据“严禁造假”seriously ## 考核</li><li>平时分<ul><li>平时实验考评：实验 40%</li><li>实验报告：实验原理、实验内容和步骤</li><li>实验册子（60%）（表格、画图60%，其他40%，心得建议不用）</li></ul></li><li>考试<ul><li>实验笔试：课程结束前一个月左右进行实验理论考试，侧重实验原理、方法和实验基本知识的考核## 预习</li></ul></li><li>自习实验原理并完成实验册子第一部分实验原理的作业</li><li>浏览实验内容和步骤，大致了解实验进程</li><li>课堂上完成实验操作并记录实验数据，建议用铅笔记录数据</li><li>处理实验数据，完成问题与讨论</li><li>方格纸：A3纸两张（画图） ## 数据处理（<strong>考试重点</strong>）课本第一章</li><li>直接测量和间接测量<ul><li>区别就是是不是直接去测</li><li>间接测量量是由直接测量量通过计算获得</li><li>一个物理量必须有数字和单位组成，并且一般写为标准形式</li><li>测量值的小数位和不确定度的小数位是<strong>对齐</strong>的，这是因为不确定度决定了存疑位，测量值中小于存疑位的数字都是没有意义的（*）</li><li>先确定后面的小数位在确定前面的小数位</li></ul></li><li>误差<ul><li>绝对误差 = 测量值 - 真实值</li><li>相对误差 = 测量绝对误差/测量值的真值</li><li>偶然误差 -公式 $ $（*/n-1）</li><li>系统误差</li></ul></li><li>不确定度<ul><li><p>平均值代替真值，并且用不确定度来确定误差</p></li><li><p>游标卡尺的不确定度</p><ul><li>游标卡尺的示值误差也称为仪器误差 = 0.02mm</li></ul></li><li><p>螺旋测微计</p><ul><li>仪器误差为0.004mm（约定）</li></ul></li><li><p>总不确定度 <spanclass="math inline">\(\sqrt{x_偶^2+x_真^2}\)</span></p></li><li><p>间接不确定度</p><ul><li>测量式是单元函数<ul><li>先算直接测量量平均值</li><li>再算间接测量量的平均值</li><li>间接测量量的不确定度为：$ = || * _x $</li></ul></li><li>测量式是多元函数<ul><li>……</li></ul></li></ul></li><li><p>相对不确定度</p><ul><li>如果是测量式是积商形式的函数式，则合成相对不确定度计算数（先取对数，再方和根合成）</li><li>绝对不确定度/平均值</li><li>保留两位有效数字</li></ul></li></ul></li><li>保留小数<ul><li>不确定度保留一位有效数字，测量值小数位和不确定度对齐</li><li>有效数字<ul><li>有效数字的科学计数法</li></ul></li><li>不确定度直接四舍五入， 测量值四舍六入， 逢五配双<ul><li>五前面是奇数就进位，如果是偶数就不进位</li></ul></li><li>运算位数保留<ul><li>相加减看小数位（小数位最少为准），相乘除看有效数字（有效数字最少为准）</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Something</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模型参数量和计算量计算</title>
    <link href="/2023/12/10/The-amount-of-parameters-and-calculations-of-the-neural-network-model/"/>
    <url>/2023/12/10/The-amount-of-parameters-and-calculations-of-the-neural-network-model/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><ul><li><p>FLOPs (Floating-point Operations)浮点运算次数，理解为计算量，可以用来衡量算法的复杂度。一个乘法或一个加法都是一个FLOPs</p></li><li><p>FLOPS(Floating-point Operations Per Second)每秒浮点运算次数，理解为计算速度，是一个衡量硬件性能的指标</p></li><li><p>MACCs(multiply-accumulate operations) 乘-加操作次数，MACCs 大约是FLOPs 的一半。将$ w * x + b $视为一个乘法累加，也称为1 个 MACC</p></li><li><p>MAC(Memory Access Cost) 内存访问成本</p></li><li><p>Params 是指模型训练中需要训练的参数总数</p></li></ul>我们可以将参数量理解为空间复杂度，将计算量理解为时间复杂度 # 全连接层一个全连接权重 W 矩阵为 $ (C_{in}, C_{out}) $， 输入为 <spanclass="math inline">\((B,F,C_{in})\)</span>,输出<spanclass="math inline">\((B,F,C_{out})\)</span>(B 代表batch_size,C代表通道数, F代表输入的特征图的大小),则： <span class="math display">\[Params = (C_{in} + 1 )* C_{out}\]</span> <span class="math display">\[FLOPs = (F * C_{in} + 1) * C_{out}\]</span> 以上计算都很好理解。其中<spanclass="math inline">\(Params\)</span>中<spanclass="math inline">\(C_{in}\)</span>加上1的原因是偏置<spanclass="math inline">\(b\)</span>的存在。如果不懂可以参照这个图：<center><img src="/2023/12/10/The-amount-of-parameters-and-calculations-of-the-neural-network-model/full-connected-layer.jpg" class="" title="This is a img..."></center><h1 id="卷积">卷积</h1>假设输入特征图为$ (B,C_{in},F) <span class="math inline">\(,卷积核为 k *k ,输出通道为\)</span>C_{out}<span class="math inline">\(。## 参数量\)</span>$ Params = k * k * C_{in} * C_{out} <spanclass="math display">\[## 计算量- 单次卷积操作的乘法次数为$ k * k * C_{in}$, 然后相加，加法次数为$k * k* C_{in} - 1$。这个-1其实就是因为因为在$ k×k×C_{in} -1$个乘法操作之间，需要$ k×k×C_{in} -1$次加法操作将它们累加起来。在最后一个乘法操作之后，就不需要再进行一次加法操作了，因此减去1。-刚才我们只计算了输出特征图上一个元素的计算量。那么输入特征图上单个通道上的计算量=单个元素的计算量*元素个数，此时我们需要另外一个经典的公式去计算输出特征图大小和输入特征图大小的关系：\]</span> n_H = + 1 <span class="math display">\[\]</span> n_W = + 1 <span class="math display">\[- 然后再考虑通道数，还有偏置，可知计算量\]</span>FLOPs = (2 * k * k * C_{in} - 1) * (n_H * n_W) *C_{out}(无偏置)<span class="math display">\[\]</span>FLOPs = (2 * k * k * C_{in} - 1 + 1) * n_H * n_W *C_{out}(有偏置)$$<center><img src="/2023/12/10/The-amount-of-parameters-and-calculations-of-the-neural-network-model/conv_layer.jpg" class="" title="This is a img..."></center>]]></content>
    
    
    <categories>
      
      <category>AI_learning</category>
      
      <category>Theories</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vscode 多文件编译配置</title>
    <link href="/2023/12/02/Vscode-Multi-file-compilation-configuration/"/>
    <url>/2023/12/02/Vscode-Multi-file-compilation-configuration/</url>
    
    <content type="html"><![CDATA[<h2 id="正片开始">正片开始</h2><p>默认VSCode 只能编译单个文件，若多个文件一起编译，经常会报 undefinedreference 找不到引用的错误，比如下面的问题：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-string">&quot;C:\Program Files\mingw64\bin\g++.exe&quot;</span> -fdiagnostics-color=always -g <span class="hljs-name">C</span>:\Users\ZeroHzzzz\Desktop\dd\dd.cpp -o <span class="hljs-name">C</span>:\Users\ZeroHzzzz\Desktop\dd\dd.exe<br><span class="hljs-name">C</span>:\Users\ZEROHZ~<span class="hljs-number">1</span>\AppData\Local\Temp\ccYQ5ExK.<span class="hljs-name">o</span>: In function `main<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">C:/Users/ZeroHzzzz/Desktop/dd/dd.cpp:6: undefined reference to `maxn(int, int)&#x27;</span><br>collect2.<span class="hljs-name">exe</span>: <span class="hljs-name">error</span>: ld returned <span class="hljs-number">1</span> exit status <br></code></pre></td></tr></table></figure><p>解决方法如下： - 配置一下<code>.vscode</code>文件夹下的<code>tasks.json</code> 就好了。 -tasks.json的话，就把界面点到代码的界面，然后菜单栏<code>"Terminal"</code>- <code>"Configure Tasks..."</code>生成默认的<code>tasks.json</code></p><p>找到 tasks.json中的 args选项，这个主要是用来配置待编译的文件信息的，<code>$&#123;file&#125;</code>替换成<code>$&#123;workspaceFolder&#125;</code>, 结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>再次运行程序，就可以多文件正常编译了</p><h2 id="addition">Addition</h2><p>但是如果我们还有其它的二级目录，那就还需要修改<code>tasks.json</code>文件。</p><p>【举例】main函数所在<code>test.cpp</code>在一级目录下，其它<code>cpp</code>文件在<code>others</code>目录下，这个时候就需要把<code>tasks.json</code>改成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\others\\*.cpp&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//修改项</span><br>    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CV/PIL读取图片踩坑记录</title>
    <link href="/2023/11/11/CV-PIL-Read-Photos/"/>
    <url>/2023/11/11/CV-PIL-Read-Photos/</url>
    
    <content type="html"><![CDATA[<p>啥也不说了直接上代码（）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>path = <span class="hljs-string">&#x27;./archive\imagesTr\CHNCXR_0640_1.png&#x27;</span><br><br>data_transforms = &#123;<br>        <span class="hljs-string">&quot;train&quot;</span>: transforms.Compose([<br>            transforms.ToTensor()<br>            ]),<br>        <span class="hljs-string">&quot;test&quot;</span>:transforms.Compose([<br>            transforms.ToTensor()<br>            ])<br>    &#125;<br><br>img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)<br><span class="hljs-built_in">print</span>(img.shape)<br>img = data_transforms[<span class="hljs-string">&quot;test&quot;</span>](img)<br><span class="hljs-built_in">print</span>(img.shape)<br><span class="hljs-comment"># img = torch.from_numpy(img)</span><br><br>label = Image.<span class="hljs-built_in">open</span>(path).convert(<span class="hljs-string">&quot;L&quot;</span>)<br>label = data_transforms[<span class="hljs-string">&quot;test&quot;</span>](label)<br><span class="hljs-built_in">print</span>(label.shape)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI_learning</category>
      
      <category>Technology</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vscode - C/C++ Configuration</title>
    <link href="/2023/11/11/Vscode-Configuration-C++/"/>
    <url>/2023/11/11/Vscode-Configuration-C++/</url>
    
    <content type="html"><![CDATA[<h1 id="to-start">To Start</h1><ul><li>安装Vscode</li><li>请前往<a href="https://code.visualstudio.com/"title="Vscode 官网">https://code.visualstudio.com/</a>下载你所需要的Vscode版本</li></ul><p>下载完了之后，你就可以开始配置C++的运行环境了</p><h1 id="install-the-extension">Install the extension</h1><ul><li>打开Vscode</li><li>选择拓展选项卡或者使用快捷键<code>Ctrl+Shift+X</code></li><li>搜索C++</li><li>安装</li></ul><figure><img src="1.png" alt="plugin" /><figcaption aria-hidden="true">plugin</figcaption></figure><h1 id="set-up-for-your-c-environment">Set up for your C++environment</h1><h2 id="下载mingw64文件">下载Mingw64文件</h2><ul><li>打开浏览器</li><li>前往<ahref="https://github.com/niXman/mingw-builds-binaries/releases">Releases· niXman/mingw-builds-binaries (github.com)</a>下载MingW64文件</li><li>选择下列图片中标出的版本</li><li>解压，获得其中的Mingw64文件夹并放在你想放的位置</li></ul><p><img src="2.png" /></p><h2 id="配置环境变量">配置环境变量</h2><ul><li>直接<code>win + S</code>快捷键搜索环境变量，进入该选项卡</li><li>点击环境变量</li><li>在用户变量和系统变量中找到Path，进入编辑</li><li>新建，并将刚才下载的Mingw64中的bin文件夹的路径填入</li><li>完成！</li></ul><p><img src="3.png" /></p><p><img src="4.png" /></p><p><img src="5.png" /></p><p><img src="6.png" /></p><p><img src="7.png" /></p><p><img src="8.png" /></p><p><img src="9.png" /></p><p>点击确定，完成！</p><h1 id="check">Check</h1><ul><li>直接<code>win + R</code>，输入cmd并运行，打开终端</li><li>输入<code>gcc -v</code>，如果出现下列画面就说明配置成功了</li><li>完成！</li></ul><p><img src="10.png" /></p><p><img src="11.png" /></p><h1 id="create-and-run-a-c-file">Create and Run a C++ file</h1><p><img src="12.png" /></p><p>create a new file called <code>helloworld.cpp</code></p><p>复制，粘贴！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="13.png" /></p><p><img src="14.png" /></p><p> 仅在第一次运行 helloworld.cpp时提示您选择编译器。该编译器将成为tasks.json文件中设置的“默认”编译器</p><p><img src="15.png" /></p><p>拿下！</p><p><strong>好好好，现在你就可以尽情的Coding了，可能还有一些其他的零碎配置</strong></p><p><strong>有空我再更新（</strong></p><p>本文转自 <ahref="https://www.cnblogs.com/ZeroHzzzz/articles/17711579.html">https://www.cnblogs.com/ZeroHzzzz/articles/17711579.html</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>综合分测定方法</title>
    <link href="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/"/>
    <url>/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="综合分测定方法">综合分测定方法</h1><h2 id="综合分测评的意义和作用">综合分测评的意义和作用</h2><ul><li>考察综合素质</li><li>为评定奖助学金、荣誉称号的主要依据</li><li>作为推荐优秀应届本科毕业生免试攻读研究生的参考依据</li></ul><h2 id="综合分办法解析">综合分办法解析</h2><ul><li>测评体系<ul><li>学生综合素质评价采用量化标准，指标体系主要包括德育素质、智育素质、体育素质、劳育素质、美育素质、创新与实践素质六部分，满分100 分。</li><li>学生综合素质测评成绩 =<br> 德育素质测评成绩（10分）+智育素质测评成绩（60 分）+<br> 体育素质测评成绩（8分）+劳育素质测评成绩（5 分）+<br> 美育素质测评成绩（5分）+创新与实践素质测评成绩（12 分）</li></ul></li><li>德育素质测评成绩（10 分）<ul><li><p>基本评定分</p><ul><li>由学生个人自我评价、班级成员互评、班主任和班委评价三部分构成，分别占20%、40%、40%。</li></ul></li><li><p>记实加减分</p><ul><li>由集体评定等级分（满分 2 分）、社会责任记实分（满分 2分）、违纪违规扣分、学生荣誉称号加减分四部分构成。</li></ul></li><li><p>addition：社会责任分主要包括：</p><ul><li>通报表扬（当学年限4次，同一事件通报表扬不重复计算，校级及以上通报表扬+0.25/次，院级通报表扬+0.1/次）</li><li>思政学习加减分（青年大学习）</li></ul></li><li><p>扣分：</p><p><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/%E6%89%A3%E5%88%86.png" class="" title="曾经这里有一张图片"></p></li><li><p>荣誉加分：</p><p><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/%E8%8D%A3%E8%AA%89%E5%8A%A0%E5%88%86.png" class="" title="曾经这里有一张图片"></p></li></ul></li><li>智育素质测评成绩（60 分）<ul><li>学生智育素质分 Z=（平均学分绩点×10＋50）*0.6 <img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image.png" class="" title="曾经这里有一张图片"></li></ul></li><li>体育素质测评成绩（8 分）<ul><li>学生体育素质分T = 体育课程成绩(5分)+课外体育活动成绩(3分)</li><li><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-1.png" class="" title="曾经这里有一张图片"></li><li><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-3.png" class="" title="曾经这里有一张图片"></li></ul></li><li>美育素质测评成绩（5分）<ul><li>学生美育素质分=文化艺术实践成绩+文化艺术竞赛成绩</li><li>文化艺术实践成绩<ul><li>文化艺术实践成绩为学生文化艺术类选修课程和参加校内外文化艺术类活动为主要依据，其中文化艺术类选修课程以教务处提供的文化艺术类选修课程清单为准，每选修一门且及格加0.25 分，每学年限加 0.5 分。</li></ul></li><li>文化艺术竞赛成绩 <img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-2.png" class="" title="曾经这里有一张图片"></li></ul></li><li>劳育素质测评成绩（5分）<ul><li>学生劳育素质分 = 日常劳动分（寝室）+志愿服务分+实习实训分</li><li><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-4.png" class="" title="曾经这里有一张图片"></li><li><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-5.png" class="" title="曾经这里有一张图片"></li></ul></li><li>创新与实践素质测评成绩（12 分）<ul><li>学生创新与实践素质分=创新创业成绩+社会实践活动成绩+社会工作成绩+水平等级考试加分</li><li><img src="/2023/11/08/%E7%BB%BC%E5%90%88%E5%88%86%E6%B5%8B%E5%AE%9A%E6%96%B9%E6%B3%95/image-6.png" class="" title="曾经这里有一张图片"></li></ul></li></ul><h2 id="注意事项">注意事项</h2><ul><li>学生综合素质测评每学年进行一次，一般安排在新学年开学一个月内进行（一年级新生除外），转专业学生在上一学年所在班级参加综合素质测评。</li><li>学生参与课程以外的专业实习、综合实习或其他劳动活动，以在有关活动中取得的成绩或奖励为依据，具体需经学院学生评价工作小组认定。</li><li>相关竞赛评定等级以浙江工业大学教务处发文的《高水平学科竞赛项目清单》为依据，参考主办单位性质和证书实际落款。其余未列入本办法的竞赛以学院学生评价工作小组当年认定结果为准，网络竞赛（在线答题类）原则上不予以加分。（网址：http://www.jwc.zjut.edu.cn/217/list.htm）</li><li>各类竞赛获奖者必须以浙江工业大学学生身份参与，各类项目、论文知识产权、专利权人须归属浙江工业大学，否则不予以加分！</li><li>经核实在测评过程中弄虚作假、虚报材料的，根据情节严重程度给予相应处分，并取消当学年所有评奖评优资格。</li><li>除特别说明，各部分累计超出满分的，均以该部分满分计。综合分测评申报材料（除暑期调研类材料外）有效期限为上一年度9 月 1 日至本年度 8 月 31 日，对于在规定期限外的材料不予加分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Something</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Voicemeeter将声音同时输出到多个输出设备</title>
    <link href="/2023/11/04/Voicemeeter/"/>
    <url>/2023/11/04/Voicemeeter/</url>
    
    <content type="html"><![CDATA[<h1 id="一基础知识">一、基础知识</h1><h2 id="输入与输出">输入与输出</h2><ul><li><p>硬件输入：就是现实的电脑上的麦克风、你头戴耳麦的麦克风等硬件录音设备。【硬件输入→（发出）→声音信号】（请注意这里的声音指的是电路中的声音信号，而不是你实际听到的声音。下同。）</p></li><li><p>硬件输出：就是现实的扬声器喇叭、你头戴耳麦的耳机等硬件发声设备。【声音信号→（被接收）→硬件输出】</p></li><li><p>虚拟输入：就是虚拟录音设备，专门监听系统中各种软件发出的声音信号。【声音信号→（被接收）→虚拟输入】</p></li></ul><img src="/2023/11/04/Voicemeeter/virtual_input.jpg" class="" title="这里曾经有一张图片......"><ul><li>虚拟输出：就是虚拟发声设备，有一个虚拟的扬声器，负责向别的设备发出声音信号。【虚拟输出→（发出）→声音信号】</li></ul><img src="/2023/11/04/Voicemeeter/virtual_output.jpg" class="" title="这里曾经有一张图片......"><ul><li>通道：用于接收和转发声音信号的中间人。 ## 设置电脑的输入输出设备自行百度，这里不再赘述</li></ul><h1 id="二软件界面">二、软件界面</h1><img src="/2023/11/04/Voicemeeter/%E8%BD%AF%E4%BB%B6%E7%95%8C%E9%9D%A2.jpg" class="" title="这里曾经有一张图片......"><p>看下图硬件输入通道1下面框出来的按钮：A1、A2、A3、B1、B2都是输出通道，你点亮了哪个，声音信号就会被接入到哪一个输出通道。</p><img src="/2023/11/04/Voicemeeter/%E7%A1%AC%E4%BB%B6%E9%80%9A%E9%81%93%E8%BE%93%E5%85%A5.jpg" class="" title="这里曾经有一张图片......"><p>比如图中，点亮了A1和B1，那么硬件输入通道1的声音信号就会被发送到A1、B1两个输出通道中去。</p><h1 id="三使用">三、使用</h1><p>这里只讲解软件同时输出到多个蓝牙设备的使用方法： - 打开Voicemeeter -配置输出设备</p><img src="/2023/11/04/Voicemeeter/1.jpg" class="" title="这里曾经有一张图片......"><ul><li>在虚拟输入栏中选择输出设备</li></ul><img src="/2023/11/04/Voicemeeter/1.png" class="" title="这里曾经有一张图片......"><ul><li>调节音量</li></ul><img src="/2023/11/04/Voicemeeter/3.png" class="" title="这里曾经有一张图片......"><ul><li>run！</li></ul><h1 id="addition">Addition</h1><p>如果想了解更多关于voicemeeter相关的知识，可到： <ahref="http://vb-audio.cn/post/36.html">http://vb-audio.cn/post/36.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Voicemeeter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo搭建博客（GitHub）</title>
    <link href="/2023/10/27/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88GitHub%EF%BC%89/"/>
    <url>/2023/10/27/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88GitHub%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><ul><li>GitHub账号</li><li>安装git</li><li>安装node</li></ul><h1 id="创建仓库">创建仓库</h1><ul><li>创建仓库，并将仓库命名为 username.github.io注意这里的username（）</li></ul><h1 id="安装hexo">安装hexo</h1><ul><li>安装hexo <code>npm install -g hexo-cli</code></li><li>check <code>hexo -v</code></li><li>创建hexo项目并初始化 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hexo init [hexo-<span class="hljs-keyword">blog(你新建的本地博客文件夹的名字，如果不输入默认为当前文件夹)]</span><br><span class="hljs-keyword"></span>cd hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure> # 主题hexo默认主题为landscape，可以前往hexo官网寻找你心仪的主题 <ahref="https://hexo.io/themes/">Themes</a></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">[github</span>地址] [存放路径]<br><span class="hljs-comment"># 例如</span><br><span class="hljs-comment"># git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></code></pre></td></tr></table></figure><p>在根目录的 _config.yml 文件中找到theme字段并将它改成你主题的名字<code>theme: next</code></p><p>本地启动： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span><br>hexo s<br></code></pre></td></tr></table></figure> <img src="1.png" alt="Hello, World!" /></p><h1 id="修改参数">修改参数</h1><p>根据themes提供的文档修改参数</p><h1 id="writing">Writing</h1><p>新建文章 <code>hexo new post 测试文章</code> 然后就开始写吧</p><h1 id="本地预览">本地预览</h1><ul><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果<code>hexo s</code></li></ul><h1 id="deloy">Deloy</h1><ul><li>安装hexo-deployer-git<code>npm install hexo-deployer-git --save</code></li><li>修改根目录下的 _config.yml，配置 GitHub相关信息,token获取方式自行百度 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yaorongke/yaorongke.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY   <span class="hljs-meta"># 应该可写可不写</span><br></code></pre></td></tr></table></figure></li><li>发布 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span> -d<br></code></pre></td></tr></table></figure> # Addition ## 使用Fluid主题的一些文章属性设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs title">---<br>title: Hexo Fluid主题使用笔记<br><br>tags:<br>  - Hexo<br>  [Hexo, Fluid]  # 推荐使用这种方法<br><br>categories:<br>  - Hexo<br>  - Fluid # 注意以上这两个标题不是并列关系，而是包含关系<br>  - Hexo<br>    - Fluid  # 注意以上这两个标题是并列关系<br>  - [Hexo, Fluid]  # 并列关系<br><br>excerpt: 这是摘要 # 摘要还可以在正文通过 &lt;!-- more --&gt; 进行分割<br><br>hide: true # 隐藏文章，隐藏后依然可以通过文章链接访问<br><br>sticky: 100 # 数值越大排序越靠前<br><br>index_img: /img/example.jpg # 文章在首页的封面图，支持外链<br><br>banner_img: /img/post_banner.jpg # 文章详情页顶部大图，支持外链<br><br>toc: true # 生成文章目录，不填为true<br>---<br><br></code></pre></td></tr></table></figure> ## 一些有意思的东西 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs hexo">// 便签<br><br>&#123;% note success %&#125;<br>文字 或者 `markdown` 均可<br>&#123;% endnote %&#125;<br>或者使用 HTML 形式：<br>&lt;p class=&quot;note note-primary&quot;&gt;标签&lt;/p&gt;<br><br><br>//行内标签<br><br>&#123;% label primary @text %&#125;<br>或者<br>&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt;<br><br><br>//复选框<br><br>&#123;% cb text, checked?, incline? %&#125;<br><br>text：显示的文字<br>checked：默认是否已勾选，默认 false<br>incline: 是否内联（可以理解为后面的文字是否换行），默认 false<br><br><br>//按钮<br><br>&#123;% btn url, text, title %&#125;<br><br>或者：<br><br>&lt;a class=&quot;btn&quot; href=&quot;url&quot; title=&quot;title&quot;&gt;text&lt;/a&gt;<br><br>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）<br></code></pre></td></tr></table></figure></li></ul><h1 id="eof">EOF</h1>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加图片的几种方式</title>
    <link href="/2023/10/27/Hexo-Add-photos/"/>
    <url>/2023/10/27/Hexo-Add-photos/</url>
    
    <content type="html"><![CDATA[<h1 id="update-2024.05.02">Update 2024.05.02:</h1><p>最近期中考完也是化悲愤为力量把一些陈年老bug修了之前提到的图片引用问题得到了解决： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-marked --save<br></code></pre></td></tr></table></figure>此处的save参数是为了npm的局部安装，因为我们大概率在其他地方不用安装这玩意安装了这东西之后，我们在_config..yml中将下面几个东西修改一下。如果没有就加上<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>   <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>   <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>然后就可以通过正常的markdown语法在资源文件夹中引用图片了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">！[<span class="hljs-string">Description</span>](<span class="hljs-link">path</span>) //注意这里的path是相对于资源文件夹的path<br></code></pre></td></tr></table></figure><h1 id="前言">前言</h1><p>在写文章的时候我们常常会使用图片来传达一些只可意会不可言传的含义....因此需要图片</p><h1 id="绝对路径">绝对路径</h1><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。路径：source/images/image.jpg <code>![](/images/image.jpg)</code></p><p>这样图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h1 id="相对路径">相对路径</h1><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p><p>在根目录的_config.yml中：</p><p><code>post_asset_folder: true</code>但是据我惨痛的经历显示，下面这种写法是错误的:<code>![photo](passage_name/Photo.png)</code> 因此我翻阅了hexo的<ahref="https://hexo.io/zh-cn/docs/">文档</a>，里面是这么写的</p><img src="/2023/10/27/Hexo-Add-photos/1.png" class="" title="这里曾经有一张图片....."><p>但是不知道为啥这个艾斯比东西就是没有用....</p><p>因此我还是只能采用官方推荐的这种写法：<code>&#123;% asset_img example.jpg failed_description %&#125;</code></p><p>事后经过一翻谷歌搜索发现用md直接导入图片导致失败的原因可能是因为只是将图片放入文件夹，hexo生成静态界面时并没有处理该图片，所以运行后就找不到图片了....给我整无语了。但是我发现他文件路径是这样的:<code>https://zerohzzzz.github.io/[passage_name]/1.png</code>而用<code>&#123;% %&#125;</code>方式导入图片，图片的路径是这样的：<code>https://zerohzzzz.github.io/2023/10/27/[passage_name]/1.png</code></p><p><del>这个艾斯比东西果然*****</del></p><p>但是这个问题似乎在插件的新版本中得到了解决，有兴趣可以看看<ahref="https://github.com/boboidream/hexo-easy-images">hexo-easy-images</a>，但我认为有<code>&#123;% %&#125;</code>方式就已经足够了</p><h1 id="addition">Addition</h1><p><ahref="http://codecook.site/2020/12/05/hexo+typora%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">hexo+typora的图片路径问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Technologies_exploration</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
